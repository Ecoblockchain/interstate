/*jslint nomen: true, vars: true */
/*global red,esprima,able,uid,console,window */

var RedSet = (function (root) {
    "use strict";
    //
    // ============== UTILITY FUNCTIONS ============== 
    //
    var construct = function (constructor, args) {
        var F = function () { return constructor.apply(this, args); };
        F.prototype = constructor.prototype;
        return new F();
    };
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
    var slice = ArrayProto.slice,
        toString = ObjProto.toString,
        nativeForEach      = ArrayProto.forEach,
        nativeMap          = ArrayProto.map;
    var eqeqeq = function (a, b) { return a === b; };
    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    var isArray = Array.isArray || function (obj) {
        return toString.call(obj) === '[object Array]';
    };
    var isString = function (obj) {
        return toString.call(obj) === '[object String]';
    };
    var extend = function (obj) {
        var i, prop, len = arguments.length;
        for (i = 1; i < len; i += 1) {
            var source = arguments[i];
            for (prop in source) {
                if (source.hasOwnProperty(prop)) {
                    obj[prop] = source[prop];
                }
            }
        }
        return obj;
    };
    
    var defaulthash = function (key) { return key.toString(); };
    var get_str_hash_fn = function (prop_name) {
        return function (key) {
            return key[prop_name]();
        };
    };
    var Set = function (options) {
        options = extend({
            hash: defaulthash,
            equals: eqeqeq,
            value: []
        }, options);
        this._equality_check = options.equals;
        this._hash = isString(options.hash) ? get_str_hash_fn(options.hash) : options.hash;
    
        this._hashed_values = {};
        this.value = [];
        this.add.apply(this, options.value);
    };
    
    (function (My) {
        var proto = My.prototype;
        proto.add = function () {
            var lenj = arguments.length;
            var value_len = this.value.length;
            var info, j;
            for (j = 0; j < lenj; j += 1) {
                var item = arguments[j];
                info = this.add_to_hash(item, value_len);
                if (info) {
                    this.value[value_len] = info;
                    value_len += 1;
                }
            }
            return this;
        };
        proto.add_at = function (index) {
            var lenj = arguments.length;
            var info, i, j;
            for (j = 1; j < lenj; j += 1) {
                var item = arguments[j];
                info = this.add_to_hash(item, index);
                if (info) {
                    this.value.splice(index, 0, info);
                    index += 1;
                }
            }
    
            var len = this.value.length;
            for (i = index; i < len; i += 1) {
                this.value[i].index = i;
            }
    
            return this;
        };
        proto.remove = function () {
            var leni = arguments.length;
            var i, j, k;
            for (i = 0; i < leni; i += 1) {
                var arg = arguments[i];
                var hash_val = this._hash(arg);
    
                var hashed_values = this._hashed_values[hash_val];
                if (hashed_values) {
                    var lenj = hashed_values.length;
                    for (j = 0; j < lenj; j += 1) {
                        var hvj = hashed_values[j];
                        if (this._equality_check(hvj.item, arg)) {
                            if (lenj === 1) {
                                delete this._hashed_values[hash_val];
                            } else {
                                hashed_values.splice(j, 1);
                            }
                            var hvj_index = hvj.index;
                            this.value.splice(hvj_index, 1);
                            var len = this.value.length;
                            for (k = hvj_index; k < len; k += 1) {
                                this.value[k].index = k;
                            }
                            break;
                        }
                    }
                }
            }
            return this;
        };
        proto.contains = function (item) {
            var hash_val = this._hash(item);
            var hash_arr = this._hashed_values[hash_val];
            if (isArray(hash_arr)) {
                var i, len = hash_arr.length, eq = this._equality_check;
                for (i = 0; i < len; i += 1) {
                    if (eq(hash_arr[i].item, item)) {
                        return true;
                    }
                }
                return false;
            } else {
                return false;
            }
        };
        proto.add_to_hash = function (item, index) {
            var hash_val = this._hash(item);
            var hash_arr = this._hashed_values[hash_val];
    
            var info = {
                item: item,
                index: index
            };
            if (isArray(hash_arr)) {
                var i, len = hash_arr.length, eq = this._equality_check;
                for (i = 0; i < len; i += 1) {
                    if (eq(hash_arr[i].item, item)) {
                        return false;
                    }
                }
                hash_arr[i] = info;
            } else {
                this._hashed_values[hash_val] = [info];
            }
            return info;
        };
        proto.each = function (func, context) {
            context = context || window;
            var i;
            for (i = 0; i < this.value.length; i += 1) {
                if (func.call(context, this.value[i].item, i) === false) {
                    break;
                }
            }
            return this;
        };
        proto.len = function () {
            return this.value.length;
        };
        proto.item = function (i) {
            return this.value[i] ? this.value[i].item : undefined;
        };
        proto.toArray = function () {
            var len = this.value.length;
            var rv = [];
            var i;
            for (i = 0; i < len; i += 1) {
                rv[i] = this.value[i].item;
            }
            return rv;
        };
    }(Set));
    
    return Set;
}(this));

/*jslint nomen: true, vars: true */
/*global window */

var RedMap = (function (root) {
    "use strict";
    
    //
    // ============== UTILITY FUNCTIONS ============== 
    //
    var construct = function (constructor, args) {
        var F = function () { return constructor.apply(this, args); };
        F.prototype = constructor.prototype;
        return new F();
    };
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
    var slice = ArrayProto.slice,
        toString = ObjProto.toString,
        nativeForEach      = ArrayProto.forEach,
        nativeMap          = ArrayProto.map;
    
    // Establish the object that gets returned to break out of a loop iteration.
    var breaker = {};
    
    // Return a unique id when called
    var uniqueId = (function () {
        var id = 0;
        return function () { id += 1; return id; };
    }());
    
    //Bind a function to a context
    var bind = function (func, context) {
        return function () { return func.apply(context, arguments); };
    };
    
    // Remove every item from an array
    var clear = function (arr) {
        arr.length = 0;
    };
      
    // Is a given value a number?
    var isNumber = function (obj) {
        return toString.call(obj) === '[object Number]';
    };
    
    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    var isArray = Array.isArray || function (obj) {
        return toString.call(obj) === '[object Array]';
    };
      
    // Is a given value a DOM element?
    var isElement = function (obj) {
        return !!(obj && (obj.nodeType === 1 || obj.nodeType === 8 || obj.nodeType === 3));
    };
      
    // Is a given value a function?
    var isFunction = function (obj) {
        return toString.call(obj) === '[object Function]';
    };
    
    var isString = function (obj) {
        return toString.call(obj) === '[object String]';
    };

    var the_o = Object;
    // Is a given variable an object?
    var isObject = function (obj) {
        return obj === the_o(obj);
    };
    
    // Is a given variable an arguments object?
    var isArguments = function (obj) {
        return toString.call(obj) === '[object Arguments]';
    };
     
    // Keep the identity function around for default iterators.
    var identity = function (value) {
        return value;
    };
    
    // Set a constructor's prototype
    var proto_extend = function (subClass, superClass) {
        var F = function () {};
        F.prototype = superClass.prototype;
        subClass.prototype = new F();
        subClass.prototype.constructor = subClass;
        
        subClass.superclass = superClass.prototype;
        if (superClass.prototype.constructor === Object.prototype.constructor) {
            superClass.prototype.constructor = superClass;
        }
    };
    
    var hOP = Object.prototype.hasOwnProperty;
    var has = function (obj, key) {
        return hOP.call(obj, key);
    };
    
    var each = function (obj, iterator, context) {
        var i, key, l;
        if (!obj) { return; }
        if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
            for (i = 0, l = obj.length; i < l; i += 1) {
                if (has(obj, i) && iterator.call(context, obj[i], i, obj) === breaker) { return; }
            }
        } else {
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    if (iterator.call(context, obj[key], key, obj) === breaker) { return; }
                }
            }
        }
    };
    var map = function (obj, iterator, context) {
        var results = [];
        if (!obj) { return results; }
        if (nativeMap && obj.map === nativeMap) { return obj.map(iterator, context); }
        each(obj, function (value, index, list) {
            results[results.length] = iterator.call(context, value, index, list);
        });
        if (obj.length === +obj.length) { results.length = obj.length; }
        return results;
    };
        
    // Retrieve the values of an object's properties.
    var values = function (obj) {
        return map(obj, identity);
    };
    
    // Safely convert anything iterable into a real, live array.
    var toArray = function (obj) {
        if (!obj) { return []; }
        if (isArray(obj)) { return slice.call(obj); }
        if (isArguments(obj)) { return slice.call(obj); }
        if (obj.toArray && isFunction(obj.toArray)) { return obj.toArray(); }
        return values(obj);
    };
    
    var last = function (arr) {
        return arr[arr.length - 1];
    };
    
    var extend = function (obj) {
        var i, prop, len = arguments.length;
        var on_each_func = function (val, prop) {
            obj[prop] = val;
        };
        for (i = 1; i < len; i += 1) {
            each(arguments[i], on_each_func);
        }
        return obj;
    };
        
    // Return the first item in arr where test is true
    var index_where = function (arr, test, start_index) {
        var i, len = arr.length;
        if (isNumber(start_index)) {
            start_index = Math.round(start_index);
        } else {
            start_index = 0;
        }
        for (i = start_index; i < len; i += 1) {
            if (test(arr[i], i)) { return i; }
        }
        return -1;
    };
        
    var eqeqeq = function (a, b) { return a === b; };
    // Return the first item in arr equal to item (where equality is defined in equality_check)
    var index_of = function (arr, item, start_index, equality_check) {
        equality_check = equality_check || eqeqeq;
        return index_where(arr, function (x) { return equality_check(item, x); }, start_index);
    };
        
    // Remove an item in an array
    var remove = function (arr, obj) {
        var index = index_of(arr, obj);
        if (index >= 0) { arr.splice(index, 1); }
        return index;
    };
    // Clone
    var clone = function (obj) {
        if (!isObject(obj)) { return obj; }
        return isArray(obj) ? obj.slice() : extend({}, obj);
    };
    
    var defaulthash = function (key) { return key.toString(); };
    var get_str_hash_fn = function (prop_name) {
        return function (key) {
            return key[prop_name]();
        };
    };
    var Map = function (options) {
        options = extend({
            hash: defaulthash,
            equals: eqeqeq,
            value: {},
            values: [],
            keys: []
        }, options);
        each(options.value, function (v, k) {
            options.keys.push(k);
            options.values.push(v);
        }, this);
        this._equality_check = options.equals;
        this._hash = isString(options.hash) ? get_str_hash_fn(options.hash) : options.hash;
    
        
        this._khash = {};
        this._ordered_values = [];
    
        var index = 0;
        each(options.keys, function (k, i) {
            var v = options.values[i];
            var hash = this._hash(k);
            var hash_arr = this._khash[hash];
    
            var info = { key: k, value: v };
            if (hash_arr) {
                hash_arr.push(info);
            } else {
                this._khash[hash] = [info];
            }
            this._ordered_values[index] = info;
            index += 1;
        }, this);
    };
    
    (function (My) {
        var proto = My.prototype;
        proto.put = function (key, value) {
			var i;
            var hash = this._hash(key),
				hash_arr = this._khash[hash],
                info = {key: key, value: value};

            if (hash_arr) {
                var len = hash_arr.length;
                for (i = 0; i < len; i += 1) {
                    var item_i = hash_arr[i];
                    if (this._equality_check(item_i.key, key)) {
                        item_i.value = value;
                        return this;
                    }
                }
    
                hash_arr.push(info);
                this._ordered_values.push(info);
                return this;
            } else {
                this._khash[hash] = [info];
                this._ordered_values.push(info);
                return this;
            }
        };
        proto.remove = function (key) {
            var i, item_i, len, rv;
            var hash = this._hash(key);
            var hash_arr = this._khash[hash];
            if (hash_arr) {
				len = hash_arr.length;
                for (i = 0; i < len; i += 1) {
                    item_i = hash_arr[i];
                    if (this._equality_check(item_i.key, key)) {
						//console.log(hash_arr, hash);
                        hash_arr.splice(i, 1);
                        if (len === 1) {
                            delete this._khash[hash];
                        }

						//Remove from ordered values before returning
						len = this._ordered_values.length;
						for (i = 0; i < len; i += 1) {
							item_i = this._ordered_values[i];
							if (this._equality_check(item_i.key, key)) {
								this._ordered_values.splice(i, 1);
								i--;
								len--;
								rv = item_i.value;
							}
						}
                        return rv;
                    }
                }
            }
            return rv;
        };
		proto.clear = function() {
			this._ordered_values.splice(0, this._ordered_values.length);
			each(this._khash, function(val, key) {
				delete this._khash[key];
			}, this);
		};
        proto.get = function (key) {
            var hash = this._hash(key);
            var hash_arr = this._khash[hash];
            var i;
            if (hash_arr) {
                var len = hash_arr.length;
                for (i = 0; i < len; i += 1) {
                    var item_i = hash_arr[i];
                    if (this._equality_check(item_i.key, key)) {
                        return item_i.value;
                    }
                }
            }
            return undefined;
        };
        proto.has = function (key) {
            var i;
            var hash = this._hash(key);
            var hash_arr = this._khash[hash];
            if (hash_arr) {
                var len = hash_arr.length;
                for (i = 0; i < len; i += 1) {
                    var item_i = hash_arr[i];
                    if (this._equality_check(item_i.key, key)) {
                        return true;
                    }
                }
            }
            return false;
        };
        proto.get_or_put = function (key, create_fn, create_fn_context) {
            var hash = this._hash(key);
            var hash_arr = this._khash[hash];
            var context = create_fn_context || this;
            var value, i, info;
            if (hash_arr) {
                var len = hash_arr.length;
                for (i = 0; i < len; i += 1) {
                    var item_i = hash_arr[i];
                    if (this._equality_check(item_i.key, key)) {
                        return item_i.value;
                    }
                }
                value = create_fn.call(context, key);
                info = {key: key, value: value};
                hash_arr.push(info);
                this._ordered_values.push(info);
                return value;
            } else {
                value = create_fn.call(context, key);
                info = {key: key, value: value};
                this._khash[hash] = [info];
                this._ordered_values.push(info);
                return value;
            }
        };
        proto.keys = function () {
            var i;
            var rv = new Array(this._ordered_values.length);
            for (i = this._ordered_values.length - 1; i >= 0; i -= 1) {
                rv[i] = this._ordered_values[i].key;
            }
            return rv;
        };
        proto.values = function () {
            var i;
            var rv = new Array(this._ordered_values.length);
            for (i = this._ordered_values.length - 1; i >= 0; i -= 1) {
                rv[i] = this._ordered_values[i].value;
            }
            return rv;
        };
        proto.each = proto.forEach = function (func, context) {
            context = context || window;
			var ovs = slice.call(this._ordered_values);
            each(ovs, function (ov) {
                func.call(context, ov.value, ov.key, ov.index);
            });
            return this;
        };
		proto.destroy = function() {};
    }(Map));
    
    return Map;
}(this));

/*jslint nomen: true, vars: true */
/*global red,esprima,able,uid,console,window */

(function () {
	"use strict";
	var i;

	var symbols = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c",
					"d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p",
					"q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C",
					"D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P",
					"Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];

	var time = (new Date()).getTime();

	var prefix_length = 6;
	var sym_length = symbols.length;
	var prefix = "";
	for (i = 0; i < prefix_length - 2; i += 1) {
		var rand_index = Math.floor(Math.random() * sym_length);
		prefix += symbols[rand_index];
	}
	var random_prefix = "$" + prefix + "_";
	//prefix_length = 0; random_prefix = "";

	var current_uid = 0;
	window.uid = function () {
		current_uid += 1;
		return random_prefix + current_uid;
	};

	window.uid.strip_prefix = function (uid_str) {
		return parseInt(uid_str.slice(prefix_length));
	};
	window.uid.get_prefix = function () {
		return prefix;
	};
}());

//     ConstraintJS (CJS) 0.9.7-beta
//     ConstraintJS may be freely distributed under the MIT License
//     http://cjs.from.so/

/* jslint nomen: true, vars: true */
/* jshint -W093 */
/* global document */
/** @expose cjs */
var cjs = (function (root) {
"use strict";

// Utility functions
// -----------------

// Many of the functions here are from http://underscorejs.org/
// Save bytes in the minified (but not gzipped) version:
var ArrayProto = Array.prototype, ObjProto = Object.prototype,
	FuncProto = Function.prototype, StringProto = String.prototype;

// Create quick reference variables for speed access to core prototypes.
var slice         = ArrayProto.slice,
	toString      = ObjProto.toString,
	concat        = ArrayProto.concat,
	push          = ArrayProto.push;

// All **ECMAScript 5** native function implementations that we hope to use
// are declared here.
var nativeSome    = ArrayProto.some,
	nativeIndexOf = ArrayProto.indexOf,
	nativeLastIndexOf = ArrayProto.lastIndexOf,
	nativeEvery   = ArrayProto.every,
	nativeForEach = ArrayProto.forEach,
	nativeKeys    = Object.keys,
	nativeFilter  = ArrayProto.filter,
	nativeReduce  = ArrayProto.reduce,
	nativeMap     = ArrayProto.map,
	nativeTrim    = StringProto.trim;

//Bind a function to a context
var bind = function (func, context) { return function () { return func.apply(context, arguments); }; },
	bindArgs = function(func) { var args = rest(arguments, 1); return function() { return func.apply(this, args); }; },
	trim = function(str){
		return nativeTrim ? nativeTrim.call(str) : String(str).replace(/^\s+|\s+$/g, '');
    },
	doc	= root.document,
	sTO = function(a,b) { return root.setTimeout(a,b); },
	cTO = function(a,b) { return root.clearTimeout(a,b); },
	// Binary and unary operators will be used for constraint modifiers and for templates,
	// which allow these operators to be used in constraints
	unary_operators = { "+": function (a) { return +a; }, "-": function (a) { return -a; },
						"~": function (a) { return ~a; }, "!": function (a) { return !a; }
	},
	binary_operators = {"===": function (a, b) { return a === b;}, "!==":function (a, b) { return a !== b; },
						"==":  function (a, b) { return a == b; }, "!=": function (a, b) { return a != b; },
						">":   function (a, b) { return a > b;  }, ">=": function (a, b) { return a >= b; },
						"<":   function (a, b) { return a < b;  }, "<=": function (a, b) { return a <= b; },
						"+":   function (a, b) { return a + b;  }, "-":  function (a, b) { return a - b; },
						"*":   function (a, b) { return a * b;  }, "/":  function (a, b) { return a / b; },
						"%":   function (a, b) { return a % b;  }, "^":  function (a, b) { return a ^ b; },
						"&&":  function (a, b) { return a && b; }, "||": function (a, b) { return a || b; },
						"&":   function (a, b) { return a & b;  }, "|":  function (a, b) { return a | b; },
						"<<":  function (a, b) { return a << b; }, ">>": function (a, b) { return a >> b; },
						">>>": function (a, b) { return a >>> b;}
	};


var getTextContent, setTextContent;
if(doc && !('textContent' in doc.createElement('div'))) {
	getTextContent = function(node) {
		return node && node.nodeType === 3 ? node.nodeValue : node.innerText;
	};
	setTextContent = function(node, val) {
		if(node && node.nodeType === 3) {
			node.nodeValue = val;
		} else {
			node.innerText = val;
		}
	};
} else {
	getTextContent = function(node) { return node.textContent; };
	setTextContent = function(node, val) { node.textContent = val; };
}

var aEL = function(node, type, callback) {
	if(node.addEventListener) {
		node.addEventListener(type, callback);
	} else {
		node.attachEvent("on"+type, callback);
	}
}, rEL = function(node, type, callback) {
	if(node.removeEventListener) {
		node.removeEventListener(type, callback);
	} else {
		node.detachEvent("on"+type, callback);
	}
};

// Establish the object that gets returned to break out of a loop iteration.
var breaker = {};

// Creating a unique id for constraints allows for quicker referencing
var uniqueId = (function () {
	var id = 0;
	return function () { return id++; };
}());

// Create a (shallow-cloned) duplicate of an object.
var clone = function(obj) {
	if (!isObject(obj)) { return obj; }
	return isArray(obj) ? obj.slice() : extend({}, obj);
};

// Returns the keys of an object
var keys = nativeKeys || function (obj) {
	if (obj !== Object(obj)) { throw new TypeError('Invalid object'); }
	var keys = [], key, len = 0;
	for (key in obj) {
		if (hOP.call(obj, key)) {
			keys[len++] = key;
		}
	}
	return keys;
};

// Get the last element of an array. Passing **n** will return the last N
// values in the array.
var last = function(array, n) {
	if (!array) {
		return void 0;
	} else if (n===undefined) {
		return array[array.length - 1];
	} else {
		return slice.call(array, Math.max(array.length - n, 0));
	}
};

// Determine if at least one element in the object matches a truth test.
// Delegates to **ECMAScript 5**'s native `some` if available.
var any = function(obj, iterator, context) {
	var result = false;
	if (!obj) { return result; }
	if (nativeSome && obj.some === nativeSome) { return obj.some(iterator, context); }
	each(obj, function(value, index, list) {
		if (result || (result = iterator.call(context, value, index, list))) { return breaker; }
	});
	return !!result;
};

// Returns everything but the first entry of the array.
// Especially useful on the arguments object. Passing an **n** will return
// the rest N values in the array.
var rest = function(array, n) {
	return slice.call(array, n === undefined ? 1 : n);
};

// Trim out all falsy values from an array.
var compact = function(array) {
	return filter(array, identity);
};

// Determine whether all of the elements match a truth test.
// Delegates to **ECMAScript 5**'s native `every` if available.
var every = function(obj, iterator, context) {
	iterator = iterator || identity;
	var result = true;
	if (!obj) {
		return result;
	} else if (nativeEvery && obj.every === nativeEvery) {
		return obj.every(iterator, context);
	} else {
		each(obj, function(value, index, list) {
			if (!(result = result && iterator.call(context, value, index, list))) {
				return breaker;
			}
		});
		return !!result;
	}
};

// Recursive call for flatten (from underscore)
var recursiveFlatten = function(input, shallow, output) {
	if (shallow && every(input, isArray)) {
		return concat.apply(output, input);
	}
	each(input, function(value) {
		if (isArray(value) || isArguments(value)) {
			if(shallow) {
				push.apply(output, value);
			} else {
				recursiveFlatten(value, shallow, output);
			}
		} else {
			output.push(value);
		}
	});
	return output;
};

// Initial call to the recursive flatten function
var flatten = function(input, shallow) {
	return recursiveFlatten(input, shallow, []);
};

// Retrieve the values of an object's properties.
var values = function (obj) {
	var values = [];
	var key;
	for (key in obj) {
		if (obj.hasOwnProperty(key)) {
			values.push(obj[key]);
		}
	}
	return values;
};

// Is a given value a number?
var isNumber = function (obj) {
		return toString.call(obj) === '[object Number]';
	},
	// Is a given value an array?
	// Delegates to ECMA5's native Array.isArray
	isArray = Array.isArray || function (obj) {
		return toString.call(obj) === '[object Array]';
	},
	// Is a given value a function?
	isFunction = function (obj) {
		return toString.call(obj) === '[object Function]';
	},
	// Is the given value a String?
	isString = function (obj) {
		return toString.call(obj) === '[object String]';
	},
	// Is a given variable an object?
	isObject = function (obj) {
		return obj === Object(obj);
	},
	// Is a given value a DOM element?
	isElement = function(obj) {
		return !!(obj && obj.nodeType === 1);
	},
	// Any element of any type?
	isAnyElement = function(obj) {
		return !!(obj && (obj.nodeType > 0));
	},
	// Is a given variable an arguments object?
	isArguments = function (obj) {
		return toString.call(obj) === '[object Arguments]';
	};
 
// Keep the identity function around for default iterators.
var identity = function (value) {
	return value;
};

// Safely convert anything iterable into a real, live array.
var toArray = function (obj) {
	if (!obj) { return []; }
	if (isArray(obj)) { return slice.call(obj); }
	if (isArguments(obj)) { return slice.call(obj); }
	if (obj.toArray && isFunction(obj.toArray)) { return obj.toArray(); }
	return map(obj, identity);
};

// `hasOwnProperty` proxy, useful if you don't know if obj is null or not
var hOP = ObjProto.hasOwnProperty,
	has = function (obj, key) {
		return hOP.call(obj, key);
	},
	hasAny = function(obj) {
		return any(rest(arguments), function(x) { return has(obj, x); });
	};

// Run through each element and calls `iterator` where `this` === `context`

var each = function(obj, iterator, context) {
	var i, length;
	if (!obj) { return; }
	if (nativeForEach && obj.forEach === nativeForEach) {
		obj.forEach(iterator, context);
	} else if (obj.length === +obj.length) {
		i=0; length = obj.length;
		for (; i < length; i++) {
			if (iterator.call(context, obj[i], i, obj) === breaker) return;
		}
	} else {
		var kys = keys(obj);
		i=0; length = kys.length;
		
		for (; i < length; i++) {
			if (iterator.call(context, obj[kys[i]], kys[i], obj) === breaker) return;
		}
	}
	return obj;
};

// Run through each element and calls 'iterator' where 'this' === context
// and returns the return value for every element
var map = function (obj, iterator, context) {
	var results = [];
	if (!obj) { return results; }
	if (nativeMap && obj.map === nativeMap) { return obj.map(iterator, context); }
	each(obj, function (value, index, list) {
		results[results.length] = iterator.call(context, value, index, list);
	});
	if (obj.length === +obj.length) { results.length = obj.length; }
	return results;
};

// Return all the elements that pass a truth test.
// Delegates to **ECMAScript 5**'s native `filter` if available.
var filter = function(obj, iterator, context) {
	var results = [];
	if (!obj) { return results; }
	if (nativeFilter && obj.filter === nativeFilter) { return obj.filter(iterator, context); }
	each(obj, function(value, index, list) {
		if (iterator.call(context, value, index, list)) { results.push(value); }
	});
	return results;
};

// Extend a given object with all the properties in passed-in object(s).
var extend = function (obj) {
	each(slice.call(arguments, 1), function(source) {
		if (source) {
			for (var prop in source) {
				if(source.hasOwnProperty(prop)) {
					obj[prop] = source[prop];
				}
			}
		}
	});
	return obj;
};
	
// Return the first item in arr where test is true
var indexWhere = function (arr, test, start_index) {
		var i, len = arr.length;
		for (i = start_index || 0; i < len; i++) {
			if (test(arr[i], i)) { return i; }
		}
		return -1;
	},
	lastIndexWhere = function(arr, test) {
		var i, len = arr.length;
		for (i = len-1; i >= 0; i--) {
			if (test(arr[i], i)) { return i; }
		}
		return -1;
	};

// The default equality check function
var eqeqeq = function (a, b) { return a === b; };

// Return the first item in arr equal to item (where equality is defined in equality_check)
var indexOf = function (arr, item, start_index, equality_check) {
		if(!equality_check && !start_index && nativeIndexOf && arr.indexOf === nativeIndexOf) {
			return arr.indexOf(item);
		} else {
			equality_check = equality_check || eqeqeq;
			return indexWhere(arr, function (x) { return equality_check(item, x); }, start_index);
		}
	}, lastIndexOf = function(arr, item, equality_check) {
		if(nativeLastIndexOf && arr.lastIndexOf === nativeLastIndexOf) {
			return arr.lastIndexOf(item);
		} else {
			equality_check = equality_check || eqeqeq;
			return lastIndexWhere(arr, function (x) { return equality_check(item, x); });
		}
	};
	
// Remove an item in an array
var remove = function (arr, obj) {
		return removeIndex(arr, indexOf(arr, obj));
	},
	removeIndex = function(arr, index) {
		if (index >= 0) { return arr.splice(index, 1)[0]; }
		return index;
	};

// Fold down a list of values into a single value
var reduce = function(obj, iterator, memo) {
	var initial = arguments.length > 2;
	if (!obj) obj = [];
	if (nativeReduce && obj.reduce === nativeReduce) {
		return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
	}
	each(obj, function(value, index, list) {
		memo = iterator(memo, value, index, list);
	});
	return memo;
};

var sparse_indexof = function(arr,item,start_index,equals) {
	//indexOf is wonky with sparse arrays
	var i = start_index,len = arr.length;
	while(i<len) {
		if(equals(arr[i], item)) {
			return i;
		}
		i++;
	}
	return -1;
},
popsym = function (index, x, y, symbols, r, n, equality_check) {
	// Longest common subsequence between two arrays, based on
	// the [rosetta code implementation](http://rosettacode.org/wiki/Longest_common_subsequence#JavaScript)
		var s = x[index],
			pos = symbols[s] + 1;
		pos = sparse_indexof(y, s, pos > r ? pos : r, equality_check || eqeqeq);
		if (pos < 0) { pos = n; }
		symbols[s] = pos;
		return pos;
	},
	indexed_lcs = function (x, y, equality_check) {
		var symbols = {}, r = 0, p = 0, p1, L = 0, idx, i,
			m = x.length, n = y.length, S = new Array(m < n ? n : m);
		if (n === 0 || m === 0) { return []; }
		p1 = popsym(0, x, y, symbols, r, n, equality_check);
		for (i = 0; i < m; i++) {
			p = (r === p) ? p1 : popsym(i, x, y, symbols, r, n, equality_check);
			p1 = popsym(i + 1, x, y, symbols, r, n, equality_check);

			if (p > p1) {
				i++;
				idx = p1;
			} else {
				idx = p;
			}

			if (idx === n || i === m) {
				p=popsym(i, x, y, symbols, r, n, equality_check);
			} else {
				r = idx;
				S[L] = {item: x[i], indicies: [i, idx]};
				L++;
			}
		}
		return S.slice(0,L);
	};

// "Subtracts" `y` from `x` (takes `x-y`) and returns a list of items in `x` that aren't in `y`
var diff = function (x, y, equality_check) {
	var i, j, xi,
		y_clone = clone(y),
		x_len = x.length,
		y_len = y.length,
		diff = [],
		diff_len = 0;

	// If there aren't any items, then the difference is the same as `x`.
	// not bothering to return a clone here because diff is private none of my code
	// modifies the return value
	if(y_len === 0 || x_len === 0) {
		return x;
	}

	for (i = 0; i < x_len; i += 1) {
		xi = x[i];
		j = indexOf(y_clone, xi, 0, equality_check);
		if(j >= 0) {
			removeIndex(y_clone, j);
			// If there's nothing left to subtract, just add the rest of x to diff and return
			if(--y_len === 0) {
				diff.push.apply(diff, rest(x, i+1));
				break;
			}
		} else {
			diff[diff_len] = xi;
			diff_len++;
		}
	}
	return diff;
};

// Returns the items that are in both x and y, but also accounts for the count of equivalent items (as defined by equality_check)
// Examples:
// `x = [1,2,2,3]`, `y = [1,2,4]` -> `[1,2]`;
// `x = [1,1,1]`,   `y = [1,1]`   -> `[1,1]`
var dualized_intersection = function (x, y, equality_check) {
	var i, j, xi,
		y_clone = clone(y),
		x_len = x.length,
		y_len = y.length,
		intersection = [];

	for (i = 0; i < x_len && y_len > 0; i++) {
		xi = x[i];
		j = indexOf(y_clone, xi, 0, equality_check);
		if(j >= 0) {
			intersection.push([xi, removeIndex(y_clone, j)]);
			y_len--;
		}
	}

	return intersection;
};

// Utility functions for `array_source_map`
var get_index_moved = function(info) {
		var item = info[1].item;
		return {item: item, from: info[0].index, to: info[1].index, from_item: info[0].item, to_item: item};
	}, 
	add_indicies = function(arr) {
		// suppose you have array `arr` defined by:
		// arr = []; arr[10] = 'hi';
		// Looping through arr with arr.forEach (or cjs's map) would only produce the 10th item.
		// this function is declared to make sure every item is looped through
		var i = 0, len = arr.length, rv = [];
		while(i<len) {
			rv[i] = {item: arr[i], index: i};
			i++;
		}
		return rv;
	},
	add_from_to_indicies = function(info) {
		return {item: info.item, from: info.indicies[0], to: info.indicies[1]};
	},
	get_index = function(x) { return x.index; },
	get_to = function(x) { return x.to; },
	add_from_and_from_item = function(x) {
		return { from: x.index, from_item: x.item };
	};

// Get where every item came from and went to and return that map
var array_source_map = function (from, to, equality_check) {
	var eq = equality_check || eqeqeq,
		item_aware_equality_check = function (a, b) { return eq(a ? a.item : a, b ? b.item : b); },
		indexed_from = add_indicies(from),
		indexed_to = add_indicies(to),
		indexed_common_subsequence = map(indexed_lcs(from, to), add_from_to_indicies),
		indexed_removed = diff(indexed_from, indexed_common_subsequence, item_aware_equality_check),
		indexed_added = diff(indexed_to, indexed_common_subsequence, item_aware_equality_check),
		indexed_moved = map(dualized_intersection(indexed_removed, indexed_added, item_aware_equality_check), get_index_moved);

	indexed_added = diff(indexed_added, indexed_moved, item_aware_equality_check);
	indexed_removed = diff(indexed_removed, indexed_moved, item_aware_equality_check);

	var added_indicies = map(indexed_added, get_index),
		moved_indicies = map(indexed_moved, get_to),
		ics_indicies = map(indexed_common_subsequence, get_to),
		to_mappings = [],
		i = 0, len = to.length, info, info_index, item;
	while(i<len) {
		item = to[i];
		// Added items
		if ((info_index = indexOf(added_indicies, i)) >= 0) {
			info = indexed_added[info_index];
			to_mappings[i] = { to: i, to_item: item, item: item };
		} else if ((info_index = indexOf(moved_indicies, i)) >= 0) {
			info = indexed_moved[info_index];
			to_mappings[i] = { to: i, to_item: item, item: item, from: info.from, from_item: info.from_item };
		} else if ((info_index = indexOf(ics_indicies, i)) >= 0) {
			info = indexed_common_subsequence[info_index];
			to_mappings[i] = { to: i, to_item: item, item: item, from: info.from, from_item: from[info.from] };
		}
		i++;
	}

	return to_mappings.concat(map(indexed_removed, add_from_and_from_item));
};

// These utility functions help compute the array diff (without having to re-declare them every time get_array_diff is called
var has_from = function(x) { return x.hasOwnProperty("from"); },
	not_has_from = function(x) { return !has_from(x); },
	has_to = function(x) { return x.hasOwnProperty("to"); },
	not_has_to = function(x) { return !has_to(x); },
	has_from_and_to = function(x) { return has_from(x) && has_to(x); },
	unequal_from_to = function(x) { return has_from_and_to(x) && x.from !== x.to; },
	sort_by_from_fn = function(a, b) {
		// This is equivalent to (but faster than):

		//     if (a_has_from && b_has_from) { return a.from - b.from; }
		//     else if (a_has_from && !b_has_from) { return -1; }
		//     else if (!a_has_from && b_has_from) { return 1; }
		//     else { return 0; }
		var a_has_from = has_from(a), b_has_from = has_from(b);
		return a_has_from && b_has_from ? a.from - b.from : b_has_from - a_has_from;
	};

/**
 *
 * `arrayDiff` returns an object with attributes:
 * `removed`, `added`, and `moved`.
 * Every item in `removed` has the format: `{item, index}`
 * Every item in `added` has the format: `{item, index}`
 * Every item in `moved` has the format: `{from_index, to_index}`
 * Every item in `index_changed` has the format: `{from_index, to_index}`
 *
 * When `oldArray` removes every item in `removed`, adds every item in `added`,
 * and moves every item in `moved` (in that order), it will result in an array
 * that is equivalent to `newArray`. Note: this function is used internally to
 * determine how to keep DOM nodes in sync with an underlying model with the
 * smallest number of modifications to the DOM tree.
 *
 * @method cjs.arrayDiff
 * @param {array[*]} from_val - The 'former' array
 * @param {array[*]} to_val - The 'new' array
 * @param {function} [equality_check] - A function that checks for equality between items
 * @return {Object} - added, removed, and moved items
 *
 * @example Taking the diff between `old_array` and `new_array` with the default equality check
 *
 *     var old_array = ['a','b','c'],
 *         new_array = ['c','b','d'],
 *         diff = cjs.arrayDiff(old_array, new_array);
 *		
 *     // diff === {
 *     //   added: [ { item: 'd', to: 2, to_item: 'd' } ],
 *     //   removed: [ { from: 0, from_item: 'a' } ],
 *     //   moved: [ { item: 'c', from: 2, insert_at: 0, move_from: 1, to: 0 } ],
 *     //   index_changed: [ { from: 2, from_item: 'c', item: 'c', to: 0, to_item: 'c' } ]
 *     // }
 *		
 */
var get_array_diff = function (from_val, to_val, equality_check) {
	var source_map = array_source_map(from_val, to_val, equality_check),
		rearranged_array = clone(source_map).sort(sort_by_from_fn),

		added = filter(source_map, not_has_from), // back to front
		removed = filter(rearranged_array, not_has_to).reverse(), // back to front
		index_changed = filter(source_map, unequal_from_to),
		moved = [];

	each(removed, function (info) { removeIndex(rearranged_array, info.from); });
	each(added, function (info) { rearranged_array.splice(info.to, 0, info); });
	
	each(source_map, function (info, index) {
		if (has_from_and_to(info)) {
			if (rearranged_array[index] !== info) {
				var rearranged_array_info_index = indexOf(rearranged_array, info, index);
				rearranged_array.splice(index, 0, removeIndex(rearranged_array, rearranged_array_info_index));
				moved.push({move_from: rearranged_array_info_index, insert_at: index, item: info.item, from: info.from, to: info.to});
			}
		}
	});
	rearranged_array = null;
	return { added: added, removed: removed, moved: moved, index_changed: index_changed , mapping: source_map};
};

// Convert dashed to camelCase; used by the css and data modules
// Microsoft forgot to hump their vendor prefix (#9572)
var rdashAlpha = /-([a-z]|[0-9])/ig, rmsPrefix = /^-ms-/,
	fcamelCase = function(all, letter) { return String(letter).toUpperCase(); },
	camel_case = function(string) { return string.replace( rmsPrefix, "ms-" ).replace(rdashAlpha, fcamelCase); };

// ConstraintJS Core Functionality
// -------------------------------

var Constraint, // Declare here, will be defined later
	ArrayConstraint,
	MapConstraint,
	is_constraint,
	is_array,
	is_map,
	
	// Save the previous value of the `cjs` variable.
	old_cjs = root.cjs,
	/**
	 * `cjs` is ConstraintJS's only *visible* object; every other method an property is a property of `cjs`.
	 * The `cjs` object itself can also be called to create a constraint object.
	 *
	 * @method cjs
	 * @param {object} value - A map of initial values
	 * @param {object} options - A set of options to control how the array constraint is evaluated
	 * @return {cjs.ArrayConstraint} A new array constraint
	 * @see cjs.noConflict
	 *
	 * @example Creating an array constraint
	 *
	 *     var cjs_arr = cjs([1,2,3]);
	 *         cjs_arr.item(0); // 1
	 */

	/**
	 * Input value constraint
	 *
	 * @method cjs^2
	 * @param {dom} node - The DOM node whose value to follow
	 * @return {cjs.Binding} A constraint whose value is the current value of the input
	 *
	 * @example Creating an input value constraint
	 *
	 *     var inp_elem = document.getElementById('myTextInput'),
	 *         cjs_val = cjs(inp_elem);
	 */
	/**
	 * Create a map constraint
	 *
	 * @method cjs^3
	 * @param {object} value - A map of initial values
	 * @param {object} options - A set of options to control how the map constraint is evaluated
	 * @return {cjs.MapConstraint} A new map constraint
	 *
	 * @example Creating a map constraint
	 *
	 *     var cobj_obj = cjs({
	 *         foo: 1
	 *     });
	 *     cobj.get('foo'); // 1
	 *     cobj.put('bar', 2);
	 *     cobj.get('bar') // 2
	 */
	/**
	 * Create a standard constraint
	 *
	 * @method cjs^4
	 * @param {object} value - The constraint's value
	 * @param {object} options - A set of options to control how the constraint is evaluated
	 * @return {cjs.Constraint} A new constraint
	 * 
	 * @example Creating an empty constraint
	 *
	 *     var x = cjs(),
	 *         y = cjs(1),
	 *         z = cjs(function() {
	 *             return y.get() + 1;
	 *         });
	 *     x.get(); // undefined
	 *     y.get(); // 1
	 *     z.get(); // 2
	 *
	 * @example With options
	 *
	 *     var yes_lit = cjs(function() { return 1; },
	 *                         { literal: true }),
	 *     var not_lit = cjs(function() { return 1; },
	 *                         { literal: false });
	 *     yes_lit.get(); // (function)
	 *     not_lit.get(); // 1
	 */
	cjs = function (arg0, arg1) {
		if(isArray(arg0)) {
			return new ArrayConstraint(extend({
				value: arg0
			}, arg1));
		} else if(isPolyDOM(arg0)) {
			return cjs.inputValue(arg0);
		} else if(is_constraint(arg0)) {
			return new Constraint(arg0, arg1);
		} else if(isObject(arg0) && !isFunction(arg0)) {
			return new MapConstraint(extend({
				value: arg0
			}, arg1));
		} else {
			return new Constraint(arg0, arg1);
		}
	},
	get_constraint_val = function(x) {
		return is_constraint(x) ? x.get() : x;
	};

// Constraint Solver
// -----------------
// Implements constraint solving, as described in:
// [Integrating pointer variables into one-way constraint models](http://doi.acm.org/10.1145/180171.180174)

//   Edge from A -> B means A sends data to B

var constraint_solver = {
	// `stack` keeps track of the list of constraints that is currently being fetched. If constraint A is fetched while B is on the top of the stack
	// then A is added to the top of the stack and B is marked as dependent on A
	stack: [],

	// node is the Constraint whose value we are fetching and auto_add_outgoing specifies whether dependencies FROM node should
	// be automatically added
	getValue: function (auto_add_outgoing, getter_arg) {
		var node = this,
			stack = constraint_solver.stack,
			stack_len = stack.length,
			demanding_var, dependency_edge, tstamp;
		
		if (stack_len > 0) { // There's a constraint that's asking for my value
			// Let's call it demanding_var
			demanding_var = stack[stack_len - 1];
			dependency_edge = node._outEdges[demanding_var._id];
			tstamp = demanding_var._tstamp+1;

			// If there's already a dependency set up, mark it as still being used by setting its timestamp to the demanding
			// variable's timestamp + `1` (because that variable's timestamp will be incrememted later on, so they will be equal)
			// 
			// Code in the this.nullify will check this timestamp and remove the dependency if it's out of date
			if(dependency_edge) {
				// Update timestamp
				dependency_edge.tstamp = tstamp;
			} else {
				// Make sure that the dependency should be added
				if (node._options.auto_add_outgoing_dependencies !== false &&
						demanding_var._options.auto_add_incoming_dependencies !== false &&
						auto_add_outgoing !== false) {
					// and add it if it should
					node._outEdges[demanding_var._id] =
						demanding_var._inEdges[node._id] = {from: node, to: demanding_var, tstamp: tstamp};
				}
			}
		}

		// This node is waiting for an asyncronous value
		if(node._paused_info) {
			// So return its temporary value until then
			return node._paused_info.temporaryValue;
		} else if (!node._valid) {
			// If the node's cached value is invalid...
			// Set the timestamp before fetching in case a constraint depends on itself
			node._tstamp++;

			// Push node onto the stack to make it clear that it's being fetched
			stack[stack_len] = node;

			// Mark it as valid
			node._valid = true;

			if (node._options.cache_value !== false) {
				// Check if dynamic value. If it is, then call it. If not, just fetch it
				// set this to the node's cached value, which will be returned
				node._cached_value = node._options.literal ? node._value :
											(isFunction(node._value) ? node._value.call(node._options.context || node, node, getter_arg) :
																		get_constraint_val(node._value));

				// The node paused as if this was going to be an asyncronous value but it ended up being syncronous.
				// Use that to set the value
				if(node._sync_value) {
					node._cached_value = node._sync_value.value;
					delete node._sync_value;
				} else if(constraint_solver._paused_node && constraint_solver._paused_node.node === node) {
					// The node said it would have an asyncronous value and it did
					// Save the paused information to the node and remove it from the constraint solver
					node._paused_info = constraint_solver._paused_node;
					delete constraint_solver._paused_node;
					//Restore the stack to avoid adding a self-dependency
					stack.length = stack_len;
					// And return the temporary value
					return node._paused_info.temporaryValue;
				}
			} else if(isFunction(node._value)) {
				// if it's just a non-cached function call, just call the function
				node._value.call(node._options.context);
			}

			// Pop the item off the stack
			stack.length = stack_len;
		}

		return node._cached_value;
	},

	// Called when a constraint's getter is paused
	pauseNodeGetter: function(temporaryValue) {
		constraint_solver._paused_node = {
			temporaryValue: temporaryValue,
			node: this
		};
	},
	// Called when a constraint's getter is resumed
	resumeNodeGetter: function(value) {
		var node = this, old_stack;

		// Hey! The node said its value would be asyncronous but it ended up being syncronous
		// We know because, it paused and then resumed before the constraint solver's paused node information could even
		// be removed.
		if(constraint_solver._paused_node && constraint_solver._paused_node.node === node) {
			delete constraint_solver._paused_node;
			node._sync_value = { value: value };
		} else {
			// Nullify every dependent node and update this node's cached value
			old_stack = constraint_solver.stack;

			delete node._paused_info;
			node._tstamp++;
			node._valid = true;

			constraint_solver.stack = [node];

			if (node._options.cache_value !== false) {
				// Check if dynamic value. If it is, then call it. If not, just fetch it
				// set this to the node's cached value, which will be returned
				node._cached_value = node._options.literal ? value :
											(isFunction(value) ? value.call(node._options.context || node, node) :
																		cjs.get(value));
			} else if(isFunction(node._value)) {
				// if it's just a non-cached function call, just call the function
				value.call(node._options.context);
			}

			constraint_solver.nullify.apply(constraint_solver, map(node._outEdges, function(edge) {
				return edge.to;
			}));
			constraint_solver.stack = old_stack;
		}
	},
	
	// Utility function to mark a listener as being in the call stack. `this` refers to the constraint node here
	add_in_call_stack: function(nl) {
		var nl_priority = nl.priority;

		nl.in_call_stack++;
		nl.node._num_listeners_in_call_stack++;

		if(isNumber(nl_priority)) {
			var i = 0, len = this.nullified_call_stack.length, item, item_priority;
			while(i < len) {
				item = this.nullified_call_stack[i];
				if(item) {
					item_priority = item.priority;
					if(item_priority === false || item_priority < nl_priority) {
						this.nullified_call_stack.splice(i, 0, nl);
						return;
					}
				}
				i++;
			}
		}
		this.nullified_call_stack.push(nl);
	},
	nullify: function() {
		// Unfortunately, running nullification listeners can, in some cases cause nullify to be indirectly called by itself
		// (as in while running `nullify`). The variable is_root will prevent another call to `run_nullification_listeners` at
		// the bottom of this function
		var i, outgoingEdges, toNodeID, invalid, curr_node, equals, old_value, new_value, changeListeners,
			to_nullify = slice.call(arguments),
			to_nullify_len = to_nullify.length,
			is_root = !this._is_nullifying,curr_node_id;

		if (is_root) {
			// This variable is used to track `is_root` for any potential future calls
			this._is_nullifying = true;
		}

		// Using a list instead of a recursive call because the call stack can get tall and annoying for debugging with
		// recursive calls
		for (i = 0; i < to_nullify_len; i+= 1) {
			curr_node = to_nullify[i]; // the constraint we are currently nullifying
			to_nullify[i] = false; // To save space, stop keeping track of the object (also useful for debugging occasionally)

			// We only care to nullify if the current node is actually valid
			if (curr_node._valid) {
				curr_node._valid = false; // Mark it as invalid...
				invalid = true;

				// The user can also optionally check if the node should be nullified. This is useful if a large number of nodes
				// depend on this node, and the potential cost of nullifying/re-evaluating them is higher than the cost of
				// re-evaluating this node
				if (curr_node._options.cache_value !== false && curr_node._options.check_on_nullify === true) {
					// Only mark as invalid if the old value is different from the current value.
					equals = curr_node._options.equals || eqeqeq;
					old_value = curr_node._cached_value;
					new_value = curr_node.get(undefined, true);

					if (equals(old_value, new_value)) {
						invalid = false;
					}
				}

				// If I'm still invalid, after a potential check
				if (invalid) {
					// Add all of the change listeners to the call stack, and mark each change listener
					// as being in the call stack
					changeListeners = curr_node._changeListeners;
					each(changeListeners, this.add_in_call_stack, this);

					// Then, get every outgoing edge and add it to the nullify queue
					outgoingEdges = curr_node._outEdges;
					curr_node_id = curr_node._id;
					for (toNodeID in outgoingEdges) {
						if (has(outgoingEdges, toNodeID)) {
							var outgoingEdge = outgoingEdges[toNodeID];
							var dependentNode = outgoingEdge.to;

							// If the edge's timestamp is out of date, then this dependency isn't used
							// any more and remove it
							if (outgoingEdge.tstamp < dependentNode._tstamp) {
								delete curr_node._outEdges[toNodeID];
								delete dependentNode._inEdges[curr_node_id];
							} else {
								// But if the dependency still is being used, then add it to the nullification
								// queue
								to_nullify[to_nullify_len] = dependentNode;
								to_nullify_len += 1;
							}
						}
					}
				}
			}
		}

		// If I'm the first one, then run the nullification listeners and remove the is_nullifying flag
		if (is_root) {
			// If nobody told us to wait, then run the nullification listeners
			if (this.semaphore >= 0 && this.nullified_call_stack.length > 0) {
				this.run_nullified_listeners();
			}
			delete this._is_nullifying;
		}
	},
	
	/**
	 * 
	 * Remove the edge going from `fromNode` to `toNode`
	 * @method cjs.removeDependency
	 */
	removeDependency: function(fromNode, toNode) {
		delete fromNode._outEdges[toNode._id];
		delete toNode._inEdges[fromNode._id];
	},

	// Use a semaphore to decide when running the nullification listeners is appropriate
	semaphore: 0,

	/**
	 * Tells the constraint solver to delay before running any `onChange` listeners
	 *
	 * Note that `signal` needs to be called the same number of times as `wait` before
	 * the `onChange` listeners will run.
	 * @method cjs.wait
	 * @see cjs.signal
	 * @see cjs.onChange
	 * @example
	 *     var x = cjs(1);
	 *     x.onChange(function() {
	 *         console.log('x changed');
	 *     });
	 *     cjs.wait();
	 *     x.set(2);
	 *     x.set(3);
	 *     cjs.signal(); // output: x changed
	 */
	wait: function() {
		this.semaphore -= 1;
	},
	/**
	 * Tells the constraint solver it is ready to run any `onChange` listeners.
	 * Note that `signal` needs to be called the same number of times as `wait` before
	 * the `onChange` listeners will run.
	 * @method cjs.signal
	 * @see cjs.wait
	 * @see cjs.onChange
	 * @example
	 *     var x = cjs(1);
	 *     x.onChange(function() {
	 *         console.log('x changed');
	 *     });
	 *     cjs.wait();
	 *     cjs.wait();
	 *     x.set(2);
	 *     x.set(3);
	 *     cjs.signal();
	 *     cjs.signal(); // output: x changed
	 */
	signal: function () {
		this.semaphore += 1;
		// When we signal that we're ready, try running the call stack
		if (this.semaphore >= 0 && this.nullified_call_stack.length > 0) {
			this.run_nullified_listeners();
		}
	},
	// The list of nullified listeners to run
	nullified_call_stack: [],
	// Tracks whether we are in the middle of running the nullification listeners
	running_listeners: false,
	// Clear all of the dependencies
	clearEdges: function(node, silent) {
		var loud = silent !== true,
			node_id = node._id,
			edge, key, inEdges = node._inEdges,
			outEdges = node._outEdges;

		if(loud) { this.wait(); }

		// Clear the incoming edges
		for(key in inEdges) {
			if(has(inEdges, key)) {
				delete inEdges[key].from._outEdges[node_id];
				delete inEdges[key];
			}
		}

		// and the outgoing edges
		for(key in outEdges) {
			if(has(outEdges, key)) {
				var toNode = outEdges[key].to;
				if (loud) { constraint_solver.nullify(toNode); }
				
				delete toNode._inEdges[node_id];
				delete outEdges[key];
			}
		}

		if(loud) { this.signal(); }
	},
	run_nullified_listeners: function () {
		var nullified_info, callback, context;
		// Make sure `run_nullified_listeners` isn't indirectly called by itself
		if (!this.running_listeners) {
			this.running_listeners = true;
			while (this.nullified_call_stack.length > 0) {
				nullified_info = this.nullified_call_stack.shift();
				callback = nullified_info.callback;
				context = nullified_info.context || root;

				nullified_info.in_call_stack--;
				nullified_info.node._num_listeners_in_call_stack--;
				// If in debugging mode, then call the callback outside of a `try` statement
				if(cjs.__debug) {
					callback.apply(context, nullified_info.args);
				} else {
					try {
						// Call the nullification callback with any specified arguments
						callback.apply(context, nullified_info.args);
					} catch(e) {
						if(has(root, "console")) {
							root.console.error(e);
						}
					}
				}
			}
			this.running_listeners = false;
		}
	},
	remove_from_call_stack: function(info) {
		while(info.in_call_stack > 0) {
			remove(this.nullified_call_stack, info);
			info.in_call_stack--;
			info.node._num_listeners_in_call_stack--;
		}
	}
};

// Constraint Variables
// --------------------

/**
 * ***Note***: The preferred way to create a constraint is with the `cjs.constraint` function (lower-case 'c')
 * `cjs.Constraint` is the constructor for the base constraint. Valid properties for `options` are:
 *
 * - `auto_add_outgoing_dependencies`: allow the constraint solver to determine when things depend on me. *default:* `true`
 * - `auto_add_incoming_dependencies`: allow the constraint solver to determine when things I depend on things. *default:* `true`
 * - `cache_value`: whether or not to keep track of the current value. *default:* `true`
 * - `check_on_nullify`: when nullified, check if my value has actually changed (requires immediately re-evaluating me). *default*: `false`
 * - `context`: if `value` is a function, the value of `this`, when that function is called. *default:* `window`
 * - `equals`: the function to check if two values are equal, *default:* `===`
 * - `literal`: if `value` is a function, the value of the constraint should be the function itself (not its return value). *default:* `false`
 * - `run_on_add_listener`: when `onChange` is called, whether or not immediately validate the value. *default:* `true`
 *
 * @class cjs.Constraint
 * @classdesc A constraint object communicates with the constraint solver to store and maintain constraint values
 * @param {*} value - The initial value of the constraint or a function to compute its value
 * @param {Object} [options] - A set of options to control how and when the constraint's value is evaluated:
 */
Constraint = function (value, options) {
	// These are all hidden values that should not be referred to directly
	this._options = extend({
		context: root
	}, options); // keeps track of the above options
	this._value = value; // Constant or a function
	this._id = uniqueId(); // different for every constraint, helps with optimizing speed
	this._outEdges = {}; // The nodes that depend on me, key is link to edge object (with properties toNode, fromNode=this)
	this._inEdges = {}; // The nodes that I depend on, key is link to edge object (with properties toNode=this, fromNode)
	this._changeListeners = []; // A list of callbacks that will be called when I'm nullified
	this._tstamp = 0; // Marks the last time I was updated
	this._num_listeners_in_call_stack = 0; // the number of listeners that are in the call stack

	if(this._options.literal || (!isFunction(this._value) && !is_constraint(this._value))) {
		// We already have a value that doesn't need to be computed
		this._valid = true; // Tracks whether or not the cached value if valid
		this._cached_value = this._value; // Caches the node's value
	} else {
		this._valid = false;
		this._cached_value = undefined;
	}
};

(function(My) {
	var proto = My.prototype;
	/** @lends cjs.Constraint.prototype */

	/**
	 * Get the current value of this constraint. For computed constraints, if the constraint is invalid, its value will be re-computed.
	 *
	 *
	 * @method get
	 * @param {boolean} [autoAddOutgoing=true] - Whether to automatically add a dependency from this constraint to ones that depend on it.
	 * @return {*} The current constraint value
	 * @see set
	 *
	 * @example
	 *     var x = cjs(1);
	 *     x.get(); // 1
	 */
	proto.get = constraint_solver.getValue;

	/**
	 * Change the current value of the constraint. Other constraints that depend on its value will be invalidated.
	 *
	 * @method set
	 * @see cjs.Constraint
	 * @param {*} value - The initial value of the constraint or a function to compute its value
	 * @param {Object} [options] - A set of options to control how and when the constraint's value is evaluated:
	 * @return {cjs.Constraint} - `this`
	 * @see get
	 * @see invalidate
	 *
	 * @example
	 *    var x = cjs(1);
	 *    x.get(); // 1
	 *    x.set(function() { return 2; });
	 *    x.get(); // 2
	 *    x.set('c');
	 *    x.get(); // 'c'
	 */
	proto.set = function (value, options) {
		var old_value = this._value;
		this._value = value;

		// If it's a value
		if (this._options.literal || (!isFunction(value) && !is_constraint(value))) {
			// Then use the specified equality check
			var equality_check = this._options.equal || eqeqeq;
			if(!equality_check(old_value, value)) {
				// And nullify if they aren't equal
				constraint_solver.nullify(this);
			}
		} else if(old_value !== value) { // Otherwise, check function equality
			// And if they aren't the same function, nullify
			constraint_solver.nullify(this);
		}

		return this;
	};

	/**
	 * Change how this constraint is computed (see Constraint options)
	 *
	 * @method setOption
	 * @see cjs.Constraint
	 * @param {Object} options - An object with the options to change
	 * @return {cjs.Constraint} - `this`
	 *
	 * @example
	 *     var x = cjs(function() { return 1; });
	 *     x.get(); // 1
	 *     x.setOption({
	 *         literal: true,
	 *         auto_add_outgoing_dependencies: false
	 *     });
	 *     x.get(); // (function)
	 */
	/**
	 * @method setOption^2
	 * @see cjs.Constraint
	 * @param {String} key - The name of the option to set
	 * @param {*} value - The option's new value
	 * @return {cjs.Constraint} - `this`
	 *
	 * @example
	 *     var x = cjs(function() { return 1; });
	 *     x.get(); // 1
	 *     x.setOption("literal", true);
	 *     x.get(); // (function)
	 */
	var invalidation_arguments = ["context", "literal"];
	proto.setOption = function(arg0, arg1) {
		var to_invalidate;
		if(isString(arg0)) {
			this._options[arg0] = arg1;
			to_invalidate = indexOf(invalidation_arguments, arg0) >= 0;
		} else {
			var keys = keys(arg0);
			extend(this._options, arg0);
			to_invalidate = any(invalidation_arguments, function(ia) {
				return keys.indexOf(ia) >= 0;
			});
		}

		// Nullify my value regardless of what changed
		// changing context, literal, etc. might change my value
		return to_invalidate ? this.invalidate() : this;
	};

	/**
	 * Mark this constraint's value as invalid. This signals that the next time its value is fetched,
	 * it should be recomputed, rather than returning the cached value.
	 *
	 * An invalid constraint's value is only updated when it is next requested (for example, via `.get()`).
	 *
	 * @method invalidate
	 * @return {cjs.Constraint} - `this`
	 * @see isValid
	 *
	 * @example Tracking the window height
	 *     var height = cjs(window.innerHeight);
	 *     window.addEventListener("resize", function() {
	 *         height.invalidate();
	 *     });
	 */
	proto.invalidate = function () {
		constraint_solver.nullify(this);
		return this;
	};

	/**
	 * Find out if this constraint's value needs to be recomputed (i.e. whether it's invalid).
	 *
	 * An invalid constraint's value is only updated when it is next requested (for example, via `.get()`).
	 *
	 * @method isValid
	 * @return {boolean} - `true` if this constraint's current value is valid. `false` otherwise.
	 * @see invalidate
	 *
	 * @example
	 *     var x = cjs(1),
	 *         y = x.add(2);
	 *     y.get();     // 3
	 *     y.isValid(); // true
	 *     x.set(2);
	 *     y.isValid(); // false
	 *     y.get();     // 4
	 *     y.isValid(); //true
	 */
	proto.isValid = function () {
		return this._valid;
	};

	/**
	 * Removes every dependency to this node
	 *
	 * @method remove
	 * @param {boolean} [silent=false] - If set to `true`, avoids invalidating any dependent constraints.
	 * @return {cjs.Constraint} - `this`
	 * @see destroy
	 */
	proto.remove = function (silent) {
		constraint_solver.clearEdges(this, silent);
		this._valid = false;			// In case it gets used in the future, make sure this constraint is marked as invalid
		this._cached_value = undefined; // and remove the cached value
		return this;
	};
	
	/**
	 * Removes any dependent constraint, clears this constraints options, and removes every change listener. This is
	 * useful for making sure no memory is deallocated
	 *
	 * @method destroy
	 * @param {boolean} [silent=false] - If set to `true`, avoids invalidating any dependent constraints.
	 * @return {cjs.Constraint} - `this`
	 * @see remove
	 *
	 * @example
	 *     var x = cjs(1);
	 *     x.destroy(); // ...x is no longer needed
	 */
	proto.destroy = function (silent) {
		if(this._num_listeners_in_call_stack > 0) {
			each(this._changeListeners, function(cl) {
				// remove it from the call stack
				if (cl.in_call_stack>0) {
					constraint_solver.remove_from_call_stack(cl);
					if(this._num_listeners_in_call_stack === 0) {
						return breaker;
					}
				}
			}, this);
		}
		this.remove(silent);
		this._changeListeners = [];
		return this;
	};

	/**
	 * Signal that this constraint's value will be computed later. For instance, for asyncronous values.
	 *
	 * @method pauseGetter
	 * @param {*} temporaryValue - The temporary value to use for this node until it is resumed
	 * @return {cjs.Constraint} - `this`
	 * @see resumeGetter
	 */
	proto.pauseGetter  = function () {
		constraint_solver.pauseNodeGetter.apply(this, arguments);
		return this;
	};
	/**
	 * Signal that this Constraint, which has been paused with `pauseGetter` now has a value.
	 *
	 * @method resumeGetter
	 * @param {*} value - This node's value
	 * @return {cjs.Constraint} - `this`
	 * @see pauseGetter
	 *
	 */
	proto.resumeGetter = function () {
		constraint_solver.resumeNodeGetter.apply(this, arguments);
		return this;
	};

	/**
	 * Call `callback` as soon as this constraint's value is invalidated. Note that if the constraint's value
	 * is invalidated multiple times, `callback` is only called once.
	 *
	 * @method onChange
	 * @param {function} callback
	 * @param {*} [thisArg=window] - The context to use for `callback`
	 * @param {*} ...args - The first `args.length` arguments to `callback`
	 * @return {cjs.Constraint} - `this`
	 * @see offChange
	 *
	 * @example
	 *     var x = cjs(1);
	 *     x.onChange(function() {
	 *         console.log("x is " + x.get());
	 *     });
	 *     x.set(2); // x is 2
	 */
	proto.onChange = function(callback, thisArg) {
		return this.onChangeWithPriority.apply(this, ([false]).concat(toArray(arguments)));
	};
	proto.onChangeWithPriority = function(priority, callback, thisArg) {
		var args = slice.call(arguments, 3); // Additional arguments
		if(!isNumber(priority)) {
			priority = false;
		}
		this._changeListeners.push({
			callback: callback, // function
			context: thisArg, // 'this' when called
			args: args, // arguments to pass into the callback
			in_call_stack: 0, // internally keeps track of if this function will be called in the near future
			node: this,
			priority: priority
		});
		if(this._options.run_on_add_listener !== false) {
			// Make sure my current value is up to date but don't add outgoing constraints.
			// That way, when it changes the callback will be called
			this.get(false);
		}
		return this;
	};
	
	/**
	 * Removes the first listener to `callback` that was created by `onChange`. `thisArg` is optional and
	 * if specified, it only removes listeners within the same context. If thisArg is not specified,
	 * the first `callback` is removed. 
	 *
	 * @method offChange
	 * @param {function} callback
	 * @param {*} [thisArg] - If specified, only remove listeners that were added with this context
	 * @return {cjs.Constraint} - `this`
	 * @see onChange
	 *
	 *     var x = cjs(1),
	 *         callback = function(){};
	 *     x.onChange(callback);
	 *     // ...
	 *     x.offChange(callback);
	 */
	proto.offChange = function (callback, thisArg) {
		var cl, i;
		for(i = this._changeListeners.length-1; i>=0; i-=1) {
			cl = this._changeListeners[i];
			// Same callback and either the same context or context wasn't specified
			if(cl.callback === callback && (!thisArg || cl.context === thisArg)) {
				// Then get rid of it
				removeIndex(this._changeListeners, i);
				// And remove it if it's in the callback
				if (cl.in_call_stack>0) {
					constraint_solver.remove_from_call_stack(cl);
				}
				delete cl.node;
				// Only searching for the last one
				break;
			}
		}
		return this;
	};

	/**
	 * Change this constraint's value in different states
	 *
	 * @method inFSM
	 * @param {cjs.FSM} fsm - The finite-state machine to depend on
	 * @param {Object} values - Keys are the state specifications for the FSM, values are the value for those specific states
	 * @return {cjs.Constraint} - `this`
	 *
	 * @example
	 *     var fsm = cjs.fsm("state1", "state2")
	 *                  .addTransition("state1", "state2",
	 *                        cjs.on("click"));
	 *     var x = cjs().inFSM(fsm, {
	 *         state1: 'val1',
	 *         state2: function() { return 'val2'; }
	 *     });
	 */
	proto.inFSM = function(fsm, values) {
		each(values, function(v, k) {
			// add listeners to the fsm for that state that will set my getter's value
			fsm.on(k, function() {
				this.set(v);
			}, this);

			if(fsm.is(k)) {
				this.set(v);
			}
		}, this);
		
		return this;
	};

	/**
	 * Returns the last value in the array `[this].concat(args)` if every value is truthy. Otherwise, returns `false`.
	 * Every argument won't necessarily be evaluated. For instance:
	 *
	 * - `x = cjs(false); cjs.get(x.and(a))` does not evaluate `a`
	 *
	 * @method and
	 * @param {*} ...args - Any number of constraints or values to pass the "and" test
	 * @return {cjs.Constraitnboolean|*} - A constraint whose value is `false` if this or any passed in value is falsy. Otherwise, the last value passed in.
	 *
	 * @example
	 *
	 *     var x = c1.and(c2, c3, true);
	 */
	proto.and = function() {
		var args = ([this]).concat(toArray(arguments)),
			len = args.length;

		return new My(function() {
			var i = 0, val;
			for(;i<len; i++) {
				// If any value is falsy, return false
				if(!(val = cjs.get(args[i]))) {
					return false;
				}
			}
			// Otherwise, return the last value fetched
			return val;
		});
	};

	/**
	 * Inline if function: similar to the javascript a ? b : c expression
	 *
	 * @method iif
	 * @param {*} true_val - The value to return if `this` is truthy
	 * @param {*} other_val - The value to return if `this` is falsy
	 * @return {cjs.Constraint} - A constraint whose value is `false` if this or any passed in value is falsy. Otherwise, the last value passed in.
	 *
	 * @example
	 *
	 *     var x = is_selected.iif(selected_val, nonselected_val);
	 */
	proto.iif = function(true_val, other_val) {
		var me = this;
		return new My(function() {
			return me.get() ? cjs.get(true_val) : cjs.get(other_val);
		});
	};

	/**
	 * Returns the first truthy value in the array `[this].concat(args)`. If no value is truthy, returns `false`.
	 * Every argument won't necessarily be evaluated. For instance:
	 *
	 * - `y = cjs(true); cjs.get(y.or(b))` does not evaluate `b`
	 *
	 * @method or
	 * @param {*} ...args - Any number of constraints or values to pass the "or" test
	 * @return {cjs.Constraint} - A constraitn whose value is the first truthy value or `false` if there aren't any
	 *
	 * @example
	 *
	 *     var x = c1.or(c2, c3, false);
	 */
	proto.or = function() {
		var args = ([this]).concat(toArray(arguments)),
			len = args.length;

		return new My(function() {
			var i = 0, val;
			for(;i<len; i++) {
				// Return the first value (including this) that is truthy
				if((val = cjs.get(args[i]))) {
					return val;
				}
			}
			//Nothing was truthy, so return false
			return false;
		});
	};

	/**
	 * @ignore
	 * Creates a new function that takes in any number of arguments and creates a constraint whose result
	 * is calling `modifier_fn` on `this` plus every argument
	 */
	var createConstraintModifier = function(modifier_fn) {
		return function() {
			var args = ([this]).concat(toArray(arguments));
			return new My(function() {
				return modifier_fn.apply(this, map(args, cjs.get));
			});
		};
	};

	var get_prop = function(a, b) { return a ? a[b] : undefined; };
	/**
	 * Property constraint modifier.
	 *
	 * @method prop
	 * @param {strings} ...args - Any number of properties to fetch
	 * @return {*} - A constraint whose value is `this[args[0]][args[1]]...`
	 * @example
	 * 
	 *     w = x.prop("y", "z"); // means w <- x.y.z
	 */
	proto.prop = createConstraintModifier(function(me) { return reduce(rest(arguments), get_prop, me); });

	/**
	 * Integer conversion constraint modifier.
	 * @method toInt
	 * @return {*} - A constrant whose value is parseInt(this)
	 * @example Given `<input />` element `inp_elem`
	 *
	 *     var inp_val = cjs(inp_elem).toInt();
	 */
	proto.toInt = createConstraintModifier(function(me) { return parseInt.apply(this, arguments); });

	/**
	 * Float conversion constraint modifier.
	 * @method toFloat
	 * @return {*} - A constraint whose value is parseFloat(this)
	 * @example Given `<input />` element `inp_elem`
	 *
	 *     var inp_val = cjs(inp_elem).toFloat();
	 */
	proto.toFloat = createConstraintModifier(function(me) { return parseFloat.apply(this, arguments); });

	// For all the arithmetic operators, allow any number of arguments to be passed in. For example:
	/**
	 * Addition constraint modifier
	 * @method add
	 * @param {number} ...args - Any number of constraints or numbers
	 * @return {number} - A constraint whose value is `this.get() + args[0].get() + args[1].get() + ...`
	 * @example
	 *
	 *     x = y.add(1,2,z); // x <- y + 1 + 2 + z
	 * @example The same method can also be used to add units to values
	 *
	 *     x = y.add("px"); // x <- ypx
	 */
	proto.add = createConstraintModifier(function() { return reduce(arguments, binary_operators["+"], 0); });
	/**
	 * Subtraction constraint modifier
	 * @method sub
	 * @param {number} ...args - Any number of constraints or numbers
	 * @return {number} - A constraint whose value is `this.get() - args[0].get() - args[1].get() - ...`
	 * @example
	 *
	 *     x = y.sub(1,2,z); // x <- y - 1 - 2 - z
	 */
	proto.sub = createConstraintModifier(function(me) { return reduce(rest(arguments), binary_operators["-"], me); });
	/**
	 * Multiplication constraint modifier
	 * @method mul
	 * @param {number} ...args - Any number of constraints or numbers
	 * @return {number} - A constraint whose value is `this.get() * args[0].get() * args[1].get() * ...`
	 * @example
	 *
	 *     x = y.mul(1,2,z); //x <- y * 1 * 2 * z
	 */
	proto.mul = createConstraintModifier(function(me) { return reduce(rest(arguments), binary_operators["*"], me); });
	/**
	 * Division constraint modifier
	 * @method div
	 * @param {number} ...args - Any number of constraints or numbers
	 * @return {number} - A constraint whose value is `this.get() / args[0].get() / args[1].get() / ...`
	 * @example
	 *
	 *     x = y.div(1,2,z); // x <- y / 1 / 2 / z
	 */
	proto.div = createConstraintModifier(function(me) { return reduce(rest(arguments), binary_operators["/"], me); });

	/**
	 * Absolute value constraint modifier
	 * @method abs
	 * @return {number} - A constraint whose value is `Math.abs(this.get())`
	 * @example
	 *
	 *     x = c1.abs(); // x <- abs(c1)
	 */
	/**
	 * Floor
	 * @method floor
	 * @return {number} - A constraint whose value is `Math.floor(this.get())`
	 * @example
	 *
	 *     x = c1.floor(); // x <- floor(c1)
	 */
	/**
	 * Ceil
	 * @method ceil
	 * @return {number} - A constraint whose value is `Math.ceil(this.get())`
	 * @example
	 *
	 *     x = c1.ceil(); // x <- ceil(c1)
	 */
	/**
	 * Round
	 * @method round
	 * @return {number} - A constraint whose value is `Math.round(this.get())`
	 * @example
	 *
	 *     x = c1.round(); // x <- round(c1)
	 */
	/**
	 * Square root
	 * @method sqrt
	 * @return {number} - A constraint whose value is `Math.sqrt(this.get())`
	 * @example
	 *
	 *     x = c1.sqrt(); // x <- sqrt(c1)
	 */
	/**
	 * Arccosine
	 * @method acos
	 * @return {number} - A constraint whose value is `Math.acos(this.get())`
	 * @example
	 *
	 *     angle = r.div(x).acos()
	 */
	/**
	 * Arcsin
	 * @method asin
	 * @return {number} - A constraint whose value is `Math.asin(this.get())`
	 * @example
	 *
	 *     angle = r.div(y).asin()
	 */
	/**
	 * Arctan
	 * @method atan
	 * @return {number} - A constraint whose value is `Math.atan(this.get())`
	 * @example
	 *
	 *     angle = y.div(x).atan()
	 */
	/**
	 * Arctan2
	 * @method atan2
	 * @param {number|cjs.Constraint} x
	 * @return {number} - A constraint whose value is `Math.atan2(this.get()/x.get())`
	 * @example
	 *
	 *     angle = y.atan2(x)
	 */
	/**
	 * Cosine
	 * @method cos
	 * @return {number} - A constraint whose value is `Math.cos(this.get())`
	 * @example
	 *
	 *     dx = r.mul(angle.cos())
	 */
	/**
	 * Sine
	 * @method sin
	 * @return {number} - A constraint whose value is `Math.sin(this.get())`
	 * @example
	 *
	 *     dy = r.mul(angle.sin())
	 */
	/**
	 * Tangent
	 * @method tan
	 * @return {number} - A constraint whose value is `Math.tan(this.get())`
	 * @example
	 *
	 *     dy = r.mul(angle.sin())
	 */
	/**
	 * Max
	 * @method max
	 * @param {number} ...args - Any number of constraints or numbers
	 * @return {number} - A constraint whose value is the **highest** of `this.get()`, `args[0].get()`, `args[1].get()`...
	 * @example
	 *
	 *     val = val1.max(val2, val3);
	 */
	/**
	 * Min
	 * @method min
	 * @param {number} ...args - Any number of constraints or numbers
	 * @return {number} - A constraint whose value is the **lowest** of `this.get()`, `args[0].get()`, `args[1].get()`...
	 * @example
	 *
	 *     val = val1.min(val2, val3);
	 */
	/**
	 * Power
	 * @method pow
	 * @param {number} x - The exponent
	 * @return {number} - A constraint whose value is `Math.pow(this.get(), x.get())`
	 * @example
	 *
	 *     d = dx.pow(2).add(dy.pow(2)).sqrt()
	 */
	/**
	 * Natural Log (base e)
	 * @method log
	 * @return {number} - A constraint whose value is `Math.log(this.get())`
	 * @example
	 *
	 *     num_digits = num.max(2).log().div(Math.log(10)).ceil()
	 */
	/**
	 * Exp (E^x)
	 * @method exp
	 * @return {number} - A constraint whose value is `Math.exp(this.get())`
	 * @example
	 *
	 *     neg_1 = cjs(i*pi).exp()
	 */
	each(["abs", "acos", "asin", "atan", "atan2", "cos", "max", "min", "sin", "tan",
			"pow", "round", "floor", "ceil", "sqrt", "log", "exp"], function(op_name) {
		proto[op_name] = createConstraintModifier(bind(Math[op_name], Math));
	});

	/**
	 * Coerce an object to a number
	 * @method pos
	 * @return {number} - A constraint whose value is `+(this.get())`
	 * @example
	 *
	 *     numeric_val = val.pos()
	 */
	/**
	 * Negative operator
	 * @method neg
	 * @return {number} - A constraint whose value is `-(this.get())`
	 * @example
	 *
	 *     neg_val = x.neg()
	 */
	/**
	 * Not operator
	 * @method not
	 * @return {boolean} - A constraint whose value is `!(this.get())`
	 * @example
	 *
	 *     opposite = x.not()
	 */
	/**
	 * Bitwise not operator
	 * @method bitwiseNot
	 * @return {number} - A constraint whose value is `~(this.get())`
	 * @example
	 *
	 *     inverseBits = val.bitwiseNot()
	 */
	/**
	 * Equals unary operator
	 * @method eq
	 * @param {*} other - A constraint or value to compare against
	 * @return {boolean} - A constraint whose value is `this.get() == other.get()`
	 *
	 * @example
	 *
	 *     isNull = val.eq(null)
	 */
	/**
	 * Not equals operator
	 * @method neq
	 * @param {*} other - A constraint or value to compare against
	 * @return {boolean} - A constraint whose value is `this.get() != other.get()`
	 *
	 * @example
	 *
	 *     notNull = val.neq(null)
	 */
	/**
	 * Strict equals operator
	 * @method eqStrict
	 * @param {*} other - A constraint or value to compare against
	 * @return {boolean} - A constraint whose value is `this.get() === other.get()`
	 *
	 * @example
	 *
	 *     isOne = val.eqStrict(1)
	 */
	/**
	 * Not strict equals binary operator
	 * @method neqStrict
	 * @param {*} other - A constraint or value to compare against
	 * @return {boolean} - A constraint whose value is `this.get() !== other.get()`
	 *
	 * @example
	 *
	 *     notOne = val.neqStrict(1)
	 */
	/**
	 * @method gt
	 * @param {*} other - A constraint or value to compare against
	 * @return {boolean} - A constraint whose value is `this.get() > other.get()`
	 *
	 * @example
	 *
	 *     isPositive = val.gt(0)
	 */
	/**
	 * @method lt
	 * @param {*} other - A constraint or value to compare against
	 * @return {boolean} - A constraint whose value is `this.get() < other.get()`
	 * 
	 * @example
	 *
	 *     isNegative = val.lt(0)
	 */
	/**
	 * @method ge
	 * @param {*} other - A constraint or value to compare against
	 * @return {boolean} - A constraint whose value is `this.get() >= other.get()`
	 *
	 * @example
	 *
	 *     isBig = val.ge(100)
	 */
	/**
	 * @method le
	 * @param {*} other - A constraint or value to compare against
	 * @return {boolean} - A constraint whose value is `this.get() <= other.get()`
	 *
	 * @example
	 *
	 *     isSmall = val.le(100)
	 */
	/**
	 * @method xor
	 * @param {*} other - A constraint or value to compare against
	 * @return {number} - A constraint whose value is `this.get() ^ other.get()`
	 */
	/**
	 * @method bitwiseAnd
	 * @param {*} other - A constraint or value to compare against
	 * @return {number} - A constraint whose value is `this.get() & other.get()`
	 */
	/**
	 * @method bitwiseOr
	 * @param {*} other - A constraint or value to compare against
	 * @return {number} - A constraint whose value is `this.get() | other.get()`
	 */
	/**
	 * @method mod
	 * @param {*} other - A constraint or value to compare against
	 * @return {number} - A constraint whose value is `this.get() % other.get()`
	 * @example
	 *		isEven = x.mod(2).eq(0);
	 *
	 */
	/**
	 * @method rightShift
	 * @param {*} other - A constraint or value to compare against
	 * @return {number} - A constraint whose value is `this.get() >> other.get()`
	 */
	/**
	 * @method leftShift
	 * @param {*} other - A constraint or value to compare against
	 * @return {number} - A constraint whose value is `this.get() << other.get()`
	 */
	/**
	 * @method unsignedRightShift
	 * @param {*} other - A constraint or value to compare against
	 * @return {number} - A constraint whose value is `this.get() >>> other.get()`
	 */
	each({
		u: { // Unary operators
			pos: "+", neg: "-", not: "!", bitwiseNot: "~"
		},
		bi: { // Binary operators
			eqStrict: "===",neqStrict:  "!==",	eq:        "==",neq: "!=",
			gt:      ">",	ge:         ">=",	lt:        "<",	le: "<=",
			xor:     "^",	bitwiseAnd: "&",	bitwiseOr: "|",	mod: "%",
			rightShift:">>",leftShift:  "<<",	unsignedRightShift: ">>>"
		}
	},	function(ops, operator_prefix) {
		var op_list = operator_prefix === "u" ? unary_operators : binary_operators;
		each(ops, function(key, op_name) {
			proto[op_name] = createConstraintModifier(op_list[key]);
		});
	});

	/**
	 * Object type modifier
	 * @method typeOf
	 * @param {*} other - a constraint or value to compare against
	 * @return {*} - a constraint whose value is `typeof this.get()`
	 * @example
	 *
	 *     var valIsNumber = val.typeOf().eq('[object Number]')
	 */
	proto.typeOf = createConstraintModifier(function(a) { return typeof a;});

	/**
	 * Object instance check modifier
	 * @method instanceOf
	 * @param {*} other - a constraint or value to compare against
	 * @return {boolean} - a constraint whose value is `this.get() instanceof other.get()`
	 * @example
	 *
	 *     var valIsArray = val.instanceof(Array)
	 */
	proto.instanceOf = createConstraintModifier(function(a, b) { return a instanceof b;});

} (Constraint));
/** @lends */

// Create some exposed utility functions
/**
 * Determine whether an object is a constraint
 * @method cjs.isConstraint
 * @param {*} obj - An object to check
 * @return {boolean} - `obj instanceof cjs.Constraint`
 */
is_constraint = function(obj) { return obj instanceof Constraint; };

// Expore core functions
// -------------------------
extend(cjs, {
	/**
	 * Constraint constructor
	 *
	 * @method cjs.constraint
	 * @constructs cjs.Constraint
	 * @param {*} value - The initial value of the constraint or a function to compute its value
	 * @param {Object} [options] - A set of options to control how and when the constraint's value is evaluated
	 * @return {cjs.Constraint} - A new constraint object
	 * @see cjs.Constraint
	 */
	constraint: function(value, options) { return new Constraint(value, options); },
	/** @expose cjs.Constraint */
	Constraint: Constraint,
	/** @expose cjs.isConstraint */
	isConstraint: is_constraint,

	/**
	 * Create a new constraint whose value changes by state
	 *
	 * @method cjs.inFSM
	 * @param {cjs.FSM} fsm - The finite-state machine to depend on
	 * @param {Object} values - Keys are the state specifications for the FSM, values are the value for those specific states
	 * @return {cjs.Constraint} - A new constraint object
	 * @see cjs.Constraint.prototype.inFSM
	 *
	 * @example
	 *
	 *     var fsm = cjs.fsm("state1", "state2")
	 *                  .addTransition("state1", "state2",
	 *                       cjs.on("click"));
	 *     var x = cjs.inFSM(fsm, {
	 *         state1: 'val1',
	 *         state2: function() { return 'val2'; }
	 *     });
	 */
	inFSM: function(fsm, values) {
		return (new Constraint()).inFSM(fsm, values);
	},

	/**
	 * Gets the value of an object regardless of if it's a constraint (standard, array, or map) or not.
	 *
	 * @method cjs.get
	 * @param {*} obj - The object whose value to return
	 * @param {boolean} [autoAddOutgoing=true] - Whether to automatically add a dependency from this constraint to ones that depend on it.
	 * @return {*} - The value
	 *
	 * @see cjs.isConstraint
	 * @see cjs.Constraint.prototype.get
	 * @see cjs.isArrayConstraint
	 * @see cjs.ArrayConstraint.prototype.toArray
	 * @see cjs.isMapConstraint
	 * @see cjs.MapConstraint.prototype.toObject
	 *
	 * @example
	 *     var w = 1,
	 *         x = cjs(2),
	 *         y = cjs(['a','b']),
	 *         z = cjs({c: 2});
	 *
	 *     cjs.get(w); // 1
	 *     cjs.get(x); // 2
	 *     cjs.get(y); // ['a','b'] 
	 *     cjs.get(z); // {c: 2}
	 */
	get: function (obj, arg0) {
		if(is_constraint(obj))	{ return obj.get(arg0); }
		else if(is_array(obj))	{ return obj.toArray(); }
		else if(is_map(obj))	{ return obj.toObject(); }
		else					{ return obj; }
	},

	/** @expose cjs.wait */
	wait: bind(constraint_solver.wait, constraint_solver),
	/** @expose cjs.signal */
	signal: bind(constraint_solver.signal, constraint_solver),
	/** @expose cjs.removeDependency */
	removeDependency: constraint_solver.removeDependency,

	/** @expose cjs.arrayDiff */
	arrayDiff: get_array_diff, // expose this useful function

	/**
	 * The version number of ConstraintJS
	 * @property {string} cjs.version
	 * @see cjs.toString
	 */
	version: "0.9.7-beta", // This template will be filled in by the builder

	/**
	 * Print out the name and version of ConstraintJS
	 *
	 * @method cjs.toString
	 * @return {string} - `ConstraintJS v(version#)`
	 * @see cjs.version
	 */
	toString: function() { return "ConstraintJS v" + cjs.version; },

	/** @private */
	__debug: true,

	/**
	 * Restore the previous value of `cjs`
	 *
	 * @method cjs.noConflict
	 * @return {object} - `cjs`
	 *
	 * @example Renaming `cjs` to `ninjaCJS`
	 *
	 *     var ninjaCJS = cjs.noConflict();
	 *     var x = ninjaCJS(1);
	 * @see cjs
	 */
	noConflict: has(root, "cjs") ?  function() {
										// If there was a previous `cjs` property then track it
										// and allow `cjs.noConflict` to restore its previous value
										if(root.cjs === cjs) { root.cjs = old_cjs; }
										// and return a reference to `cjs` if the user wants it
										return cjs;
									} :
									// ...otherwise, `cjs.noConflict` will just delete the old value
									function() {
										delete root.cjs;
										return cjs;
									}
});

// Array Constraints
// -----------------

var isPositiveInteger = function (val) {
	return isNumber(val) && Math.round(val) === val && val >= 0;
};

/**
 * ***Note:*** The preferred constructor for arrays is `cjs.array`
 *
 * This class is meant to emulate standard arrays, but with constraints
 * It contains many of the standard array functions (push, pop, slice, etc)
 * and makes them constraint-enabled.
 *
 *     x[1] = y[2] + z[3] === x.item(1, y.item(2) + z.item(3))
 *
 * Options:
 *
 * - `equals`: the function to check if two values are equal, *default:* `===`
 * - `value`: an array for the initial value of this constraint
 *
 * @class cjs.ArrayConstraint
 * @classdesc A class that adds constraint to arrays
 * @param {Object} [options] - A set of options to control how the array constraint is evaluated
 *
 * @see cjs
 * @see cjs.array
 */
ArrayConstraint = function (options) {
	options = extend({
		equals: eqeqeq, // How to check for equality, useful for indexOf, etc
		value: [] // starting value
	}, options);

	// Every value in the array is a constraint
	this._value = map(options.value, function(val) {
		return new Constraint(val, {literal: true});
	});

	// When we fetch an item in the array that doesn't exist, it gets added to
	// the unsubstantiated items list to create a dependency
	this._unsubstantiated_items = [];

	this.$len = new Constraint(this._value.length); // Keep track of the array length in a constraint
	this.$equality_check = new Constraint(options.equals, {literal: true}); // How to check for equality again...
};

(function (my) {
	var proto = my.prototype;
	/**
	 * Any iterator in forEach can return this object to break out of its loop.
	 * @property {object} cjs.ArrayConstraint.BREAK
	 */
	my.BREAK = {};

	/** @lends cjs.ArrayConstraint.prototype */


	// Get a particular item in the array
	var _get = function (arr, key) {
		var val = arr._value[key];
		if (val === undefined) { // Even if arr[key] is set to undefined, it would be a constraint
			// Create a dependency so that if the value for this key changes
			// later on, we can detect it in the constraint solver
			val = new Constraint(undefined, {literal: true});
			arr._unsubstantiated_items[key] = val;
		}
		return val.get();
	};

	// For internal use; set a particular item in the array
	var _put = function (arr, key, val) {
		cjs.wait(); // Don't run any nullification listeners until this function is done running
		var $previous_value = arr._value[key];

		// If there's an unsubstantiated item; use that, so that dependencies still work
		if ($previous_value === undefined && arr._unsubstantiated_items[key]) {
			$previous_value = arr._value[key] = arr._unsubstantiated_items[key];
			delete arr._unsubstantiated_items[key];
		}

		if (is_constraint($previous_value)) {
			// If there was a previous value, just set it
			var prev_val = $previous_value.get();
			$previous_value.set(val);
		} else {
			// Otherwise, just create a new value
			arr._value[key] = new Constraint(val, {literal: true});
		}
		_update_len(arr); // Make sure the length hasn't changed
		cjs.signal(); // OK, run nullification listeners now if necessary
		return val;
	};

	// Remove every element of the array
	var _clear = function (arr, silent) {
		var $val;
		cjs.wait();

		// Keep on popping and don't stop!
		while (arr._value.length > 0) {
			$val = arr._value.pop();
			var len = arr._value.length;
			if (is_constraint($val)) {
				$val.destroy(silent); // Clear memory for every element
			}
		}
		_update_len(arr);

		cjs.signal();
		return this;
	};

	var _update_len = function (arr) {
		// The setter will automatically not update if the value is the same
		arr.$len.set(arr._value.length);
	};


	/**
	 * Change the equality check; useful for indexOf
	 *
	 * @method setEqualityCheck
	 * @param {function} equality_check - A new function to check for equality between two items in this array
	 * @return {cjs.ArrayConstraint} `this`
	 */
	proto.setEqualityCheck = function (equality_check) {
		this.$equality_check.set(equality_check);
		return this;
	};

	/**
	 * The forEach() method executes a provided function once per array element.
	 * 
	 * @method forEach
	 * @param {function} callback - Function to execute for each element.
	 * @param {*} thisArg - Object to use as `this` when executing `callback`.
	 * @return {cjs.ArrayConstraint} `this`
	 * @example
	 *     var arr = cjs(['a','b','c']);
	 *     arr.forEach(function(val, i) {
	 *         console.log(val);
	 *         if(i === 1) {
	 *             return cjs.ArrayConstraint.BREAK;
	 *         }
	 *     }); // 'a' ... 'b'
	 */
	proto.forEach = function (callback, thisArg) {
		var i, len = this.length();
		thisArg = thisArg || root; // Set thisArg to window if not specified
		for (i = 0; i < len; i += 1) {
			if (callback.call(thisArg, _get(this, i), i) === my.BREAK) { // "break" equivalent
				return this;
			}
		}
		return this;
	};

	/**
	 *  The map() method creates a new array (not array constraint) with the results of calling a provided
	 *  function on every element in this array.
	 * 
	 * @method map
	 * @param {function} callback - Function that produces an element of the new Array from an element of the current one.
	 * @param {*} thisArg - Object to use as `this` when executing `callback`.
	 * @return {array} - The result of calling `callback` on every element
	 * @example
	 *     var arr = cjs([1,2,3]);
	 *     arr.map(function(x) { return x+1;}) // [2,3,4]
	 */
	proto.map = function (callback, thisArg) {
		var rv = [];
		thisArg = thisArg || root;
		this.forEach(function(val, i) {
			rv[i] = callback.call(thisArg, val, i);
		});
		return rv;
	};

	/**
	 * Replaces the whole array
	 *
	 * @method setValue
	 * @param {array} arr - The new value
	 * @return {cjs.ArrayConstraint} - `this`
	 * @example
	 *     var arr = cjs([1,2,3]);
	 *     arr.toArray(); //[1,2,3]
	 *     arr.setValue(['a','b','c']);
	 *     arr.toArray(); //['a','b','c']
	 */
	proto.setValue = function (arr) {
		cjs.wait(); // Don't run nullified functions quite yet
		_clear(this);
		this.push.apply(this, arr);
		cjs.signal(); // OK, now run them
		return this;
	};

	/**
	 * Convert my value to a standard JavaScript array
	 *
	 * @method item
	 * @return {array} - A standard JavaScript array
	 * @see toArray
	 * @example
	 *     var arr = cjs([1,2,3]);
	 *     arr.item(); //[1,2,3]
	 */
	/**
	 * Get item `key`
	 *
	 * @method item^2
	 * @param {number} key - The array index
	 * @return {*} - The value at index `key`
	 * @example
	 *     var arr = cjs(['a','b']);
	 *     arr.item(0); //['a']
	 */
	/**
	 * Set item i
	 *
	 * @method item^3
	 * @param {number} key - The array index
	 * @param {*} value - The new value
	 * @return {*} - `value`
	 * @example
	 *     var arr = cjs(['a','b']);
	 *     arr.item(0,'x');
	 *     arr.toArray(); // ['x','b']
	 */
	proto.item = function (key, val) {
		if(arguments.length === 0) { // Just return an array if called with no arguments
			return this.toArray();
		} else if (arguments.length === 1) { // Get if called with one argument
			return _get(this, key);
		} else if (arguments.length > 1) { // Put if called with more than one argument
			return _put(this, key, val);
		}
	};

	/**
	 * Clear this array and try to clean up any memory.
	 *
	 * @method destroy
	 * @param {boolean} [silent=false] - If set to `true`, avoids invalidating any dependent constraints.
	 */
	proto.destroy = function (silent) {
		_clear(this, silent);
		this.$len.destroy(silent);
	};

	/**
	 * Get the length of the array.
	 *
	 * @method length
	 * @return {number} - The length of the array
	 * @example
	 *     var arr = cjs(['a','b']);
	 *     arr.length(); // 2
	 */
	proto.length = function () {
		return this.$len.get(); // Remember that length is a constraint
	};
	
	/**
	 * The push() method mutates an array by appending the given elements and returning the new length of the array.
	 *
	 * @method push
	 * @param {*} ...elements - The set of elements to append to the end of the array
	 * @return {number} - The new length of the array
	 *
	 * @see pop
	 * @see shift
	 * @see unshift
	 * @see splice
	 * @example
	 *     var arr = cjs(['a','b']);
	 *     arr.push('c','d'); // 4
	 *     arr.toArray(); // ['a','b','c','d']
	 */
	proto.push = function () {
		var i, len = arguments.length, value_len = this._value.length;
		//Make operation atomic
		cjs.wait();
		// Add every item that was passed in
		for (i = 0; i < len; i++) {
			_put(this, value_len+i, arguments[i]);
		}
		cjs.signal();
		return this.length(); // return the new length
	};

	/**
	 * The pop() method removes the last element from an array and returns that element.
	 *
	 * @method pop
	 * @return {*} - The value that was popped off or `undefined`
	 * 
	 * @see push
	 * @see shift
	 * @see unshift
	 * @see splice
	 * @example
	 *     var arr = cjs(['a','b']);
	 *     arr.pop(); // 'b'
	 *     arr.toArray(); // ['a']
	 */
	proto.pop = function () {
		var rv, $value = this._value.pop(); // $value should be a constraint
		cjs.wait();

		if (is_constraint($value)) { // if it's a constraint return the value.
										// otherwise, return undefined
			rv = $value.get();
			$value.destroy();
		}
		// And set the proper length
		_update_len(this);

		// Ok, ready to go again
		cjs.signal();
		
		return rv;
	};

	/**
	 * Converts this array to a JavaScript array
	 *
	 * @method toArray
	 * @return {array} - This object as a JavaScript array
	 * @example
	 *     var arr = cjs(['a','b']);
	 *     arr.toArray(); // ['a', 'b']
	 */
	proto.toArray = function () {
		return this.map(identity); // just get every element
	};

	/**
	 * Returns the *first* item where calling filter is truthy
	 * 
	 * @method indexWhere
	 * @param {function} filter - The function to call on every item
	 * @param {*} thisArg - Object to use as `this` when executing `callback`.
	 * @return {number} - The first index where calling `filter` is truthy or `-1`
	 * @example
	 *     var arr = cjs(['a','b','b']);
	 *     arr.indexWhere(function(val, i) {
	 *         return val ==='b';
	 *     }); // 1
	 */
	proto.indexWhere = function (filter, thisArg) {
		var i, len = this.length(), $val;
		thisArg = thisArg || this;

		for (i = 0; i < len; i += 1) {
			$val = this._value[i];
			if (filter.call(thisArg, $val.get(), i)) { return i; }
		}

		return -1; // -1 if not found
	};
	/**
	 * Returns the *last* item where calling filter is truthy
	 * 
	 * @method lastIndexWhere
	 * @param {function} filter - The function to call on every item
	 * @param {*} thisArg - Object to use as `this` when executing `callback`.
	 * @return {number} - The last index where calling `filter` is truthy or `-1`
	 *
	 * @example
	 *     var arr = cjs(['a','b','a']);
	 *     arr.lastIndexWhere(function(val, i) {
	 *         return val ==='a';
	 *     }); // 2
	 */
	proto.lastIndexWhere = function (filter, thisArg) {
		var i, len = this.length(), $val;
		thisArg = thisArg || this;

		for (i = len - 1; i >= 0; i -= 1) {
			$val = this._value[i];
			if (filter.call(thisArg, $val.get(), i)) { return i; }
		}

		return -1; // -1 if not found
	};

	/**
	 * Returns the *first* index of `item`
	 * 
	 * @method indexOf
	 * @param {*} item - The item we are searching for
	 * @param {function} [equality_check] - How to check whether two objects are equal, defaults to the option that was passed in)
	 * @return {number} - The item's index or `-1`
	 *
	 * @example
	 *     var arr = cjs(['a','b','a']);
	 *     arr.indexOf('a'); // 0
	 */
	proto.indexOf = function (item, equality_check) {
		equality_check = equality_check || this.$equality_check.get();
		var filter = function (x) { return equality_check(x, item); };
		return this.indexWhere(filter);
	};

	/**
	 * Returns the *last* index of `item`
	 * 
	 * @method lastIndexOf
	 * @param {*} item - The item we are searching for
	 * @param {function} [equality_check] - How to check whether two objects are equal, defaults to the option that was passed in)
	 * @return {number} - The item's index or `-1`
	 * @example
	 *     var arr = cjs(['a','b','a']);
	 *     arr.indexOf('a'); // 2
	 */
	proto.lastIndexOf = function (item, equality_check) {
		equality_check = equality_check || this.$equality_check.get();
		var filter = function (x) { return equality_check(x, item); };
		return this.lastIndexWhere(filter);
	};

	/**
	 * Return `true` if `filter` against any item in my array is truthy
	 * 
	 * @method some
	 * @param {function} filter - The function to check against
	 * @param {*} thisArg - Object to use as `this` when executing `filter`.
	 * @return {boolean} - `true` if some item matches `filter`. `false` otherwise
	 * @see every
	 * @example
	 *     var arr = cjs([1,3,5]);
	 *     arr.some(function(x) { return x%2===0; }); // false
	 */
	proto.some = function(filter, thisArg) {
		return this.indexWhere(filter, thisArg) >= 0;
	};

	/**
	 * Return `true` if `filter` against every item in my array is truthy
	 * 
	 * @method every
	 * @param {function} filter - The function to check against
	 * @param {*} thisArg - Object to use as `this` when executing `filter`.
	 * @return {boolean} - `true` if some item matches `filter`. `false` otherwise
	 * @see some
	 * @example
	 *     var arr = cjs([2,4,6]);
	 *     arr.some(function(x) { return x%2===0; }); // true
	 */
	proto.every = function(filter, thisArg) {
		var rv = true;
		this.forEach(function() {
			if(!filter.apply(thisArg, arguments)) { // break on the first non-obeying element
				rv = false;
				return my.BREAK;
			}
		});
		return rv;
	};

	/**
	 * The splice() method changes the content of an array, adding new elements while removing old elements.
	 *
	 * @method splice
	 * @param {number} index - Index at which to start changing the array. If greater than the length of the array,
	 * no elements will be removed.
	 * @param {number} howMany - An integer indicating the number of old array elements to remove.
	 * If howMany is 0, no elements are removed. In this case, you should specify at least one new element.
	 * If howMany is greater than the number of elements left in the array starting at index,
	 * then all of the elements through the end of the array will be deleted.
	 * @param {*} ...elements - The elements to add to the array. If you don't specify any elements,
	 * splice simply removes elements from the array.
	 * @return {array.*} - An array containing the removed elements. If only one element is removed,
	 * an array of one element is returned. If no elements are removed, an empty array is returned.
	 *
	 * @see push
	 * @see pop
	 * @see shift
	 * @see unshift
	 * @example
	 *     var arr = cjs(['a','b','c']);
	 *     arr.splice(0,2,'x','y'); //['a','b']
	 *     arr.toArray(); // ['x','y','c']
	 */
	proto.splice = function (index, howmany) {
		var i;
		if (!isNumber(howmany)) { howmany = 0; }
		if (!isPositiveInteger(index) || !isPositiveInteger(howmany)) {
			throw new Error("index and howmany must be positive integers");
		}
		var to_insert = slice.call(arguments, 2),
			to_insert_len = to_insert.length;

		// Don't run any listeners until we're done
		cjs.wait();
		// It's useful to keep track of if the resulting shift size is negative because
		// that will influence which direction we loop in
		var resulting_shift_size = to_insert_len - howmany;

		// removed will hold the items that were removed
		var removed = map(this._value.slice(index, index + howmany), function(x) {
			return x ? x.get() : undefined;
		});

		// If we have to remove items
		if (resulting_shift_size < 0) {
			var value_len = this._value.length,
				insertion_max = index + to_insert_len,
				movement_max = value_len + resulting_shift_size;

			// If it's in the insertion range, use the user-specified insert
			for (i = index; i<insertion_max; i += 1) {
				_put(this, i, to_insert[i - index]);
			}

			// Otherwise, use put (don't use splice here to make sure that 
			// item i has the same constraint object (for dependency purposes)
			for (; i<movement_max; i += 1) {
				_put(this, i, _get(this, i - resulting_shift_size));
			}

			// Then, just get rid of the last resulting_shift_size elements
			for (; i<value_len; i += 1) {
				var $value = this._value.pop(); // $value should be a constraint
				if (is_constraint($value)) {  // and dealocate
					$value.destroy();
				}
			}
		} else {
			for (i = this._value.length + resulting_shift_size - 1; i >= index; i -= 1) {
				if (i < index + to_insert_len) {
					// If it's in the insertion range...
					_put(this, i, to_insert[i - index]);
				} else {
					// If not...
					_put(this, i, _get(this, i - resulting_shift_size));
				}
			}
		}

		if(resulting_shift_size !== 0) { // Don't bother if no resulting shift
			_update_len(this);
		}

		cjs.signal(); // And finally run any listeners
		return removed;
	};

	/**
	 * The shift() method removes the first element from an array and returns that element.
	 * This method changes the length of the array.
	 *
	 * @method shift
	 * @return {*} - The element that was removed
	 *
	 * @see unshift
	 * @see push
	 * @see pop
	 * @see splice
	 * @example
	 *     var arr = cjs(['a','b','c']);
	 *     arr.shift(); // 'a'
	 *     arr.toArray(); //['b','c']
	 */
	proto.shift = function () {
		var rv_arr = this.splice(0, 1);
		return rv_arr[0];
	};

	/**
	 * The unshift() method adds one or more elements to the beginning of an array and returns the new length
	 * of the array.
	 *
	 * @method unshift
	 * @param {*} ...elements - The elements to be added
	 * @return {number} - The new array length
	 *
	 * @see shift
	 * @see push
	 * @see pop
	 * @see splice
	 * @example
	 *     var arr = cjs(['a','b','c']);
	 *     arr.unshift('x','y'); // 5
	 *     arr.toArray(); //['x','y','a','b','c']
	 */
	proto.unshift = function () {
		this.splice.apply(this, ([0, 0]).concat(toArray(arguments)));
		return this.length();
	};

	/**
	 * The concat() method returns a new array comprised of this array joined with other array(s) and/or value(s).
	 *
	 * @method concat
	 * @param {*} ...values - Arrays and/or values to concatenate to the resulting array.
	 * @return {array} The concatenated array
	 * @example
	 *     var arr1 = cjs(['a','b','c']),
	 *     arr2 = cjs(['x']);
	 *     arr1.concat(arr2); // ['a','b','c','x']
	 */
	proto.concat = function () {
		// Every argument could either be a JS array or array constraint
		var args = map(arguments, function(arg) {
			return is_array(arg) ? arg.toArray() : arg;
		});
		var my_val = this.toArray();
		return my_val.concat.apply(my_val, args);
	};

	/**
	 * The slice() method returns a portion of an array.
	 *
	 * @method slice
	 * @param {number} [begin=0] - Zero-based index at which to begin extraction.
	 * @param {number} [end=this.length] - Zero-based index at which to end extraction. slice extracts up to but not including end.
	 * @return {array} A JavaScript array
	 * @example
	 *     var arr = cjs(['a','b','c']);
	 *     arr.slice(1); // ['b','c']
	 */
	proto.slice = function () {
		// Just call the normal slice with the same arguments
		var sliced_arr = this._value.slice.apply(this._value, arguments);
		return map(sliced_arr, function(x) {
			return x ? x.get() : undefined;
		});
	};

	/**
	 * Return a constraint whose value is bound to my value for key
	 *
	 * @method itemConstraint
	 * @param {number|Constraint} key - The array index
	 * @return {Constraint} - A constraint whose value is `this[key]`
	 * @example
	 *     var arr = cjs(['a','b','c']);
	 *     var first_item = arr.itemConstraint(0);
	 *     first_item.get(); // 'a'
	 *     arr.item(0,'x');
	 *     first_item.get(); // 'x'
	 */
	proto.itemConstraint = function(key) {
		return new Constraint(function() {
			// Call cjs.get on the key so the key can also be a constraint
			return this.item(cjs.get(key));
		}, {
			context: this
		});
	};

	/**
	 * The filter() method creates a new array with all elements that pass the test implemented by the provided function.
	 *
	 * @method filter
	 * @param {function} callback - Function to test each element of the array.
	 * @param {*} [thisObject] - Object to use as this when executing callback.
	 * @return {array} A filtered JavaScript array
	 */
	/**
	 * The join() method joins all elements of an array into a string.
	 *
	 * @method join
	 * @param {string} [separator=','] - Specifies a string to separate each element of the array.
	 * The separator is converted to a string if necessary. If omitted, the array elements are separated with a comma.
	 * @return {string} The joined string
	 */
	/**
	 * The sort() method sorts the elements of an array in place and returns the array.
	 * The default sort order is lexicographic (not numeric).
	 *
	 * @method sort
	 * @param {function} [compreFunction] - Specifies a function that defines the sort order. If omitted,
	 * the array is sorted lexicographically (in dictionary order) according to the string conversion of each element.
	 * @return {array} A sofrted JavaScript array
	 */
	/**
	 * The reverse() method reverses an array in place. The first array element becomes the last and the last becomes the first.
	 *
	 * @method reverse
	 * @return {array} A JavaScript array whose value is the reverse of mine
	 */
	/**
	 * The toString() method returns a string representing the specified array and its elements.
	 *
	 * @method toString
	 * @return {string} A string representation of this array.
	 */
	each(["filter", "join", "sort", "reverse", "toString"], function (fn_name) {
		// All of these functions will just convert to an array and return that
		proto[fn_name] = function () {
			var my_val = this.toArray();
			return my_val[fn_name].apply(my_val, arguments);
		};
	});
}(ArrayConstraint));
/** @lends */

/**
 * Determine whether an object is an array constraint
 * @method cjs.isArrayConstraint
 * @param {*} obj - An object to check
 * @return {boolean} - `true` if `obj` is a `cjs.ArrayConstraint`, `false` otherwise
 */
is_array = function(obj) {
	return obj instanceof ArrayConstraint;
};

extend(cjs, {
	/**
	 * Create an array constraint
	 * @method cjs.array
	 * @constructs cjs.ArrayConstraint
	 * @param {Object} [options] - A set of options to control how the array constraint is evaluated
	 * @return {cjs.ArrayConstraint} - A new array constraint object
	 * @see cjs.ArrayConstraint
	 * @example
	 *     var arr = cjs.array({
	 *         value: [1,2,3]
	 *     });
	 */
	array: function (options) { return new ArrayConstraint(options); },
	/** @expose cjs.ArrayConstraint */
	ArrayConstraint: ArrayConstraint,
	/** @expose cjs.isArrayConstraint */
	isArrayConstraint: is_array
});

// Map Constraints
// ---------------

// Maps use hashing to improve performance. By default, the hash is a simple toString
// function
var defaulthash = function (key) { return key+""; };

// A string can also be specified as the hash, so that the hash is the result of calling
// that property of the object
var get_str_hash_fn = function (prop_name) {
	return function (key) {
		return key[prop_name]();
	};
};

/**
 * ***Note:*** the preferred way to create a map constraint is with `cjs.map`
 * This class is meant to emulate JavaScript objects ({}) but with constraints
 *
 * Options:
 *
 * - `hash`: a key hash to use to improve performance when searching for a key (default: `x.toString()`)
 * - `valuehash`: a value hash to use improve performance when searching for a value (default: `false`)
 * - `equals`: How to check for equality when searching for a key (default: `===`)
 * - `valueequals`: How to check for equality when searching for a value (default: `===`)
 * - `value`: An optional starting value (default: `{}`)
 * - `keys`: An optional starting set of keys (default: `[]`)
 * - `values`: An optional starting set of values (default: `[]`)
 * - `literal_values`: True if values that are functions should return a function rather than that function's return value. (default: `false`)
 * - `create_unsubstantiated`: Create a constraint when searching for non-existent keys. (default: `true`)
 *
 * @class cjs.MapConstraint
 * @classdesc A class that adds constraint to objects
 * @param {Object} [options] - A set of options to control how the map constraint is evaluated
 */
MapConstraint = function (options) {
	options = extend({
		hash: defaulthash, // Improves performance when searching by key
		valuehash: false, // Function if we should hash values, which improves performance when searching by value. By default, we don't hash values
		equals: eqeqeq, // Equality check when searching by key
		valueequals: eqeqeq, // Equality check when searching by value
		value: {}, // Optional starting value
		keys: [], // Rather than passing in 'value', keys and values can be equal-length arrays specifying keys...
		values: [], // and values
		literal_values: false, // true if every value should be literal
		create_unsubstantiated: true // Create a value when a key isn't found
	}, options);

	options.keys = clone(options.keys);
	options.values = clone(options.values);
	var set_keys = {};

	//ensure no duplicate keys
	each(options.keys, function(key) { set_keys[key] = true; });

	// Append all of the keys and values passed to the keys and values arrays
	each(options.value, function (v, k) {
		if(!set_keys[k]) {
			options.keys.push(k);
			options.values.push(v);
		}
	}, this);

	set_keys = false;

	// Convert to boolean
	this._default_literal_values = !!options.literal_values;
	this.$equality_check = new Constraint(options.equals, {literal: true});
	this.$vequality_check = new Constraint(options.valueequals, {literal: true});

	// Get my hash
	this._hash = isString(options.hash) ? get_str_hash_fn(options.hash) : options.hash;
	this._create_unsubstantiated = options.create_unsubstantiated;

	this._khash = {};

	// If we're hashing values, then set this._valuehash as a function
	if (options.valuehash) {
		this._vhash = {};
		if (isFunction(options.valuehash)) {
			this._valuehash = options.valuehash;
		} else if (isString(options.valuehash)) {
			this._valuehash = get_str_hash_fn(options.valuehash);
		} else {
			this._valuehash = defaulthash;
		}
	} else {
		this._vhash = false;
	}

	var is_literal = this._default_literal_values;

	// Keeps track of the values and maintains the proper order
	this._ordered_values = map(options.keys, function (k, i) {
		var v = options.values[i];
		// Have key (k) and value (v)
		var info = {
			key: new Constraint(k, {literal: true}),
			value: new Constraint(v, {literal: is_literal}),
			index: new Constraint(i, {literal: true})
		};

		// Properly put the entry into the key hash
		var hash = this._hash(k);
		var hash_val = this._khash[hash];
		if (hash_val) {
			hash_val.push(info);
		} else {
			this._khash[hash] = [info];
		}

		// If we hash values too, properly put the entry into the value hash
		if (this._vhash) {
			var value_hash = this._valuehash(v);
			var vhash_val = this._vhash[value_hash];
			if (vhash_val) {
				vhash_val.push(info);
			} else {
				this._vhash[value_hash] = [info];
			}
		}
		// And finally, set return info for this._ordered_values[i]
		return info;
	}, this);

	// Keeps track of requested values that aren't set
	this._unsubstantiated_values = {};

	// Array to store keys
	this.$keys = new Constraint(function () {
			var rv = [];
			this.forEach(function (value, key, index) {
				rv[index] = key;
			});
			return rv;
		}, {context: this});

	// Array to store values
	this.$values = new Constraint(function() {
		var rv = [];
		this.forEach(function (value, key, index) {
			rv[index] = value;
		});
		return rv;
	}, {context: this});

	// Full entries (includes keys and values)
	this.$entries = new Constraint(function() {
		var rv = [];
		this.forEach(function (value, key, index) {
			rv[index] = {key: key, value: value};
		});
		return rv;
	}, {context: this});

	// Number of keys
	this.$size = new Constraint(function() {
		return this._ordered_values.length;
	}, {context: this});
};

(function (my) {
	/**
	 * Any iterator in forEach can return this object to break out of its loop.
	 * @property {object} cjs.MapConstraint.BREAK
	 */
	my.BREAK = ArrayConstraint.BREAK;

	var proto = my.prototype;
	/** @lends cjs.MapConstraint.prototype */

	// Utility function to return information about a key
	var _find_key = function (key, fetch_unsubstantiated, create_unsubstantiated, literal) {
		// Get the hash
		var hash = this._hash(key),
			rv = {
				h: hash, // the actual hash value
				hv: false, // the hash array at the hash value
				i: -1, // the index of the key in the hash array
				ui: -1, // the index in the unsubstantiated array
				uhv: false // the unsubstantiated hash array
			},
			eq = this.$equality_check.get(),
			index_where_fn = function (a, b) {
				return eq(a.key.get(), key);
			},
			hash_values = this._khash[hash];

		if (hash_values) { // We found a potential hash array
			var key_index = indexWhere(hash_values, index_where_fn);
			rv.hv = hash_values;
			if(key_index >= 0) { // Wohoo! we also found the key in there
				rv.i = key_index;
				return rv;
			}
		}

		// Haven't returned yet, so we didn't find the entry. Look for an unsubstantiated
		// value instead.
		if (fetch_unsubstantiated !== false) { //Not found
			var unsubstantiated_values = this._unsubstantiated_values[hash],
				unsubstantiated_index = -1;

			if (unsubstantiated_values) {
				rv.uhv = unsubstantiated_values;
				unsubstantiated_index = indexWhere(unsubstantiated_values, index_where_fn);
				if(unsubstantiated_index >= 0) {
					rv.ui = unsubstantiated_index;
					return rv;
				}
			}

			// We haven't returned yet, so we didn't find an unsubstantiated value either
			// Check to see if we should create one.
			if(create_unsubstantiated === true) {
				var is_literal = this._default_literal_values,
					unsubstantiated_info = {
						key: new Constraint(key, {literal: true}),
						value: new Constraint(undefined,  {literal: literal === undefined ? this._default_literal_values : !!literal}), // will be undefined
						index: new Constraint(-1, {literal: true}) // with a negative index
					};

				if(unsubstantiated_values) { // The hash was found but not the particular value
					// Add it onto the end
					unsubstantiated_index = unsubstantiated_values.length;
					unsubstantiated_values[unsubstantiated_index] = unsubstantiated_info;
				} else {
					// The hash wasn't found; create a new array
					unsubstantiated_index = 0;
					this._unsubstantiated_values[hash] = unsubstantiated_values = [unsubstantiated_info];
				}
			}
			rv.uhv = unsubstantiated_values || false; // Want to return false if not found
			rv.ui = unsubstantiated_index;
		}
		return rv;
	};

	// Responsible for setting a key properly
	var _do_set_item_ki = function (ki, key, value, index, literal) {
		// ki is the key information from _find_key
		var i, value_hash, vhash_val, info,
			key_index = ki.i, // where the key is in the hash array
			hash_values = ki.hv, // the hash array
			hash = ki.h; // the hash value

		if (key_index >= 0) { // The key was already in this map
			// get the information
			info = hash_values[key_index];

			if (this._vhash) { // If we're hashing values, the new value has to get re-hashed
				var old_value = info.value.get(),
					old_value_hash = this._valuehash(old_value),
					old_vhash_val = this._vhash[old_value_hash];
				value_hash = this._valuehash(value);

				if (old_vhash_val) { // This should probably always be true, unless something went wrong...
					var len = old_vhash_val.length;
					for (i = 0; i < len; i += 1) {
						if (old_vhash_val[i] === info) { // wohoo, found it
							old_vhash_val.splice(i, 1);
							if (old_vhash_val.length === 0) {
								delete this._vhash[old_value_hash]; // don't keep the old hash array
							}
							break;
						}
					}
				}

				// Put the new value has in
				vhash_val = this._vhash[value_hash]; // hash array
				if (vhash_val) {
					vhash_val.push(info); // add onto the hash array
				} else {
					this._vhash[value_hash] = [info]; // create a new hash array
				}
			}

			info.value.set(value); // set the value constraint to the new value

			if (isPositiveInteger(index)) { // But they also specified an index...
				var old_index = info.index.get();
				if(old_index !== index) { // great...now we have to move it too
					// take out the old value
					this._ordered_values.splice(old_index, 1);
					// and re-add it
					this._ordered_values.splice(index, 0, info);

					// Properly iterate regardless of whether moving higher or lower
					var low = Math.min(old_index, index);
					var high = Math.max(old_index, index);
					// update the indicies of every thing between that might have been affected
					for (i = low; i <= high; i += 1) {
						_set_index(this._ordered_values[i], i);
					}
					this.$keys.invalidate(); // Keys are now invalid
				}
			}
		} else {
			// They didn't specify an index or at least they specified it wrong...
			if (!isPositiveInteger(index)) {
				index = this._ordered_values.length; // just set it to the 
			}
			// Check to see if there was an unsubstantiated item
			var unsubstantiated_index = ki.ui;

			if (unsubstantiated_index >= 0) { // Found it! Now let's remove it from the list of unsubstantiated items
				var unsubstantiated_hash_values = ki.uhv,
					unsubstantiated_info = unsubstantiated_hash_values[unsubstantiated_index];

				unsubstantiated_hash_values.splice(unsubstantiated_index, 1);
				if (unsubstantiated_hash_values.length === 0) {
					delete this._unsubstantiated_values[hash];
				}

				info = unsubstantiated_info; // re-use the same object to keep dependencies
			} else {
				// Nothing in unsubstantiated; just create it from scratch
				info = {
					key: new Constraint(key, {literal: true}),
					value: new Constraint(value, {literal: literal === undefined ? this._default_literal_values : !!literal}),
					index: new Constraint(index, {literal: true})
				};
			}

			if(hash_values) { // There was already a hash array
				hash_values.push(info);
			} else { // Have to create the hash array
				hash_values = this._khash[hash] = [info];
			}

			//If we're hashing values...
			if (this._vhash) {
				value_hash = this._valuehash(value);
				vhash_val = this._vhash[value_hash];
				// Add the item to the value hash
				if (vhash_val) {
					vhash_val.push(info);
				} else {
					this._vhash[value_hash] = [info];
				}
			}

			//  insert into values
			this._ordered_values.splice(index, 0, info);

			if (unsubstantiated_index >= 0) {
				info.value.set(value); // but update its value and index
				info.index.set(index);
			}

			// Push the index of every item that I spliced before up
			for (i = index + 1; i < this._ordered_values.length; i += 1) {
				_set_index(this._ordered_values[i], i);
			}
			// Now, size and keys are invalid
			this.$size.invalidate();
			this.$keys.invalidate();
		}
		this.$values.invalidate();
		this.$entries.invalidate();
	};

	// Cange an info's specified index
	var _set_index = function (info, to_index) {
		info.index.set(to_index);
	};

	// Deallocate memory from constraints
	var _destroy_info = function (infos, silent) {
		each(infos, function (info) {
			info.key.destroy(silent);
			info.value.destroy(silent);
			info.index.destroy(silent);
		});
	};

	// removes the selected item and destroys its value to deallocate it
	var _remove_index = function (index, silent) {
		var info = this._ordered_values[index];
		_destroy_info(this._ordered_values.splice(index, 1), silent);
		if(silent !== true) {
			this.$size.invalidate();
		}
	};
	
	/**
	 * Get the keys on this object.
	 *
	 * @method keys
	 * @return {array.*} - The set of keys
	 * @see values
	 * @see entries
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.keys(); // ['x','y']
	 */
	proto.keys = function () { return this.$keys.get(); };

	/**
	 * Get the values on this object.
	 *
	 * @method values
	 * @return {array.*} - The set of values
	 * @see keys
	 * @see entries
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.values(); // [1,2]
	 */
	proto.values = function () { return this.$values.get(); };

	/**
	 * Get every key and value of this object as an array.
	 *
	 * @method entries
	 * @return {array.object} - A set of objects with properties `key` and `value`
	 * @see keys
	 * @see values
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.entries(); // [{key:'x',value:1},
	 *                    //  {key:'y',value:2}]
	 */
	proto.entries = function () { return this.$entries.get(); };

	/**
	 * Get the number of entries in this object.
	 *
	 * @method size
	 * @return {number} - The number of entries
	 * @see isEmpty
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.size(); // 2
	 */
	proto.size = function () { return this.$size.get(); };
	
	/**
	 * Check if this object has any entries
	 *
	 * @method isEmpty
	 * @return {boolean} - `true` if there are no entries, `false` otherwise
	 * @see size
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.isEmpty(); // false
	 */
	proto.isEmpty = function () { return this.size() === 0; };

	/**
	 * Set the entry for `key` to `value` (`this[key]=value`)
	 *
	 * @method put
	 * @param {*} key - The entry's key
	 * @param {*} value - The entry's value
	 * @param {number} [index=this.size] - The entry's index
	 * @param {boolean} [literal] - Whether to treat the value as literal
	 * @return {cjs.MapConstraint} - `this`
	 * @see get
	 * @see getOrPut
	 * @see item
	 * @see remove
	 * @see clear
	 *
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.put("z", 3, 1);
	 *     map.keys(); // ['x','z','y']
	 */
	proto.put = function (key, value, index, literal) {
		cjs.wait();
		// Find out if there's a key or unsubstantiated info but don't create it
		var ki = _find_key.call(this, key, true, false, literal);
		// And do the work of putting
		_do_set_item_ki.call(this, ki, key, value, index, literal);
		cjs.signal();
		return this;
	};

	/**
	 * Remove a key's entry (like `delete this[key]`)
	 *
	 * @method remove
	 * @param {*} key - The entry's key
	 * @return {cjs.MapConstraint} - `this`
	 *
	 * @see put
	 * @see clear
	 *
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.remove("x");
	 *     map.keys(); // ['y']
	 */
	proto.remove = function (key, silent) {
		// Find out if there's an actual key set
		var ki = _find_key.call(this, key, false, false),
			key_index = ki.i,
			hash_values = ki.hv,
			i, info, ordered_index, value_hash, vhash_val;

		// If the item was found
		if (key_index >= 0) {
			cjs.wait();

			info = hash_values[key_index]; // The info about the value
			ordered_index = info.index.get(); // The map's index (not the index in the hash array)

			hash_values.splice(key_index, 1); // Remove info from the hash array
			if (hash_values.length === 0) { // If there isn't anything in the hash array,
				delete this._khash[ki.h]; // remove it
			}

			// If the value is also hashed..
			if (this._vhash) {
				// Find the value hash information
				value_hash = this._valuehash(info.value.get()); // the lookup key for the value hash
				vhash_val = this._vhash[value_hash]; // the value hash array
				if (vhash_val) { // Found the value hash
					var len = vhash_val.length;
					for (i = 0; i < len; i += 1) {
						if (vhash_val[i] === info) { // found the actual item
							vhash_val.splice(i, 1); // remove it from the array
							if (vhash_val.length === 0) {
								delete this._vhash[value_hash]; // and if it's empty, remove the whole value hash array
							}
							break; // Wohoo!
						}
					}
				}
			}

			_remove_index.call(this, ordered_index, silent); // remove ordered_index (splices the ordered array)
			for (i = ordered_index; i < this._ordered_values.length; i += 1) {
				_set_index(this._ordered_values[i], i); // and update the index for every item
			}

			// And now all of these constraint variables are invalid.
			if(!silent) {
				this.$size.invalidate();
				this.$keys.invalidate();
				this.$values.invalidate();
				this.$entries.invalidate();
			}

			// OK, now you can run any nullified listeners
			cjs.signal();
		}
		return this;
	};
	
	/**
	 * Get the item at key (like this[key])
	 *
	 * @method get
	 * @param {*} key - The entry's key
	 * @return {*|undefined} - the value at that entry or `undefined`
	 *
	 * @see item
	 * @see put
	 * @see getOrPut
	 *
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.get("x"); // 1
	 */
	proto.get = function (key) {
		// Try to find the key and search in any unsubstantiated values
		var ki = _find_key.call(this, key, true, this._create_unsubstantiated),
			key_index = ki.i,
			hash_values = ki.hv;

		if (key_index >= 0) { // Found it; get the item in the hash's value
			var info = hash_values[key_index];
			return info.value.get();
		} else if(this._create_unsubstantiated) {
			var unsubstantiated_info = ki.uhv[ki.ui]; // use the unsubstantiated getter to create a dependency
			return unsubstantiated_info.value.get();
		} else { // not found and can't create unsubstantiated item
			return undefined;
		}
	};

	/**
	 * Convert my value to a standard JavaScript object. The keys are converted using `toString`
	 *
	 * @method item
	 * @return {object} - A standard JavaScript object
	 * @see toObject
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.item(); // {x:1,y:2}
	 */
	/**
	 * Get item `key`
	 *
	 * @method item^2
	 * @param {number} key - The object key
	 * @return {*} - The value at index `key`
	 *
	 * @see get
	 * @see put
	 * @see getOrPut
	 * 
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.item('x'); // 1
	 */     
	/**
	 * Set item i
	 *
	 * @method item^3
	 * @param {number} key - The object key
	 * @param {*} value - The new value
	 * @return {cjs.MapConstraint} - `this`
	 *
	 * @see get
	 * @see put
	 * @see getOrPut
	 *
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.item('z', 3);
	 *     map.keys(); //['x','y','z']
	 */
	proto.item = function (arg0, arg1, arg2) {
		if(arguments.length === 0) { // no arguments? return an object
			return this.toObject();
		} else if (arguments.length === 1) { // One, try to get the keys values
			return this.get(arg0);
		} else { // more than two, try to set
			return this.put(arg0, arg1, arg2);
		}
	};

	/**
	 * Return a constraint whose value is bound to my value for key
	 *
	 * @method itemConstraint
	 * @param {*|Constraint} key - The array index
	 * @return {Constraint} - A constraint whose value is `this[key]`
	 *
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     var x_val = map.itemConstraint('x');
	 *     x_val.get(); // 1
	 *     map.item('x', 3);
	 *     x_val.get(); // 3
	 */
	proto.itemConstraint = function(key) {
		return new Constraint(function() {
			// Call cjs.get on the key so the key can also be a constraint
			return this.get(cjs.get(key));
		}, {
			context: this
		});
	};

	/**
	 * Clear every entry of this object.
	 *
	 * @method clear
	 * @return {cjs.MapConstraint} - `this`
	 * @see remove
	 * @see isEmpty
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.isEmpty(); // false
	 *     map.clear();
	 *     map.isEmpty(); // true
	 */
	proto.clear = function (silent) {
		if (this.size() > 0) { // If I actually have something
			cjs.wait();
			// Keep removing items
			while (this._ordered_values.length > 0) {
				_remove_index.call(this, 0, silent);
			}
			// And get rid of every key hash
			each(this._khash, function (arr, hash) {
				delete this._khash[hash];
			}, this);
			// and value hash if applicable
			if (this._vhash) {
				each(this._vhash, function (arr, hash) {
					delete this._vhash[hash];
				}, this);
			}

			// and everything should be invalid
			if(!silent) {
				this.$keys.invalidate();
				this.$values.invalidate();
				this.$entries.invalidate();
				this.$size.invalidate();
			}

			cjs.signal(); // ready to run nullification listeners
		}
		return this;
	};

	/**
	 * The forEach() method executes a provided function once per entry.
	 * If cjs.MapConstraint.BREAK is returned for any element, we stop looping
	 * 
	 * @method forEach
	 * @param {function} callback - Function to execute for each entry.
	 * @param {*} thisArg - Object to use as `this` when executing `callback`.
	 * @return {cjs.MapConstraint} - `this`
	 * @example
	 *     var map = cjs({x:1,y:2,z:3});
	 *     map.forEach(function(val, key) {
	 *         console.log(key+':'+val);
	 *         if(key === 'y') {
	 *             return cjs.MapConstraint.BREAK;
	 *         }
	 *     }); // x:1 ... y:2
	 */
	proto.forEach = function (func, thisArg) {
		var i, info, len = this.size(),
			ov_clone = this._ordered_values.slice();
		thisArg = thisArg || this;
		for (i = 0; i < len; i += 1) {
			info = ov_clone[i];
			if (info && func.call(thisArg, info.value.get(), info.key.get(), info.index.get()) === my.BREAK) { // break if desired
				break;
			}
		}
		return this;
	};

	/**
	 * Change the default equality check when getting a key
	 * 
	 * @method setEqualityCheck
	 * @param {function} equality_check - The new key equality check
	 * @return {cjs.ArrayConstraint} - `this`
	 */
	proto.setEqualityCheck = function (equality_check) {
		this.$equality_check.set(equality_check);
		return this;
	};

	/**
	 * Change the default value equality check when getting a value
	 * 
	 * @method setValueEqualityCheck
	 * @param {function} vequality_check - The new value equality check
	 * @return {cjs.ArrayConstraint} - `this`
	 */
	proto.setValueEqualityCheck = function (vequality_check) {
		this.$vequality_check.set(vequality_check);
		return this;
	};

	/**
	 * Change the hash function when getting a key
	 * 
	 * @method setHash
	 * @param {function|string} hash - The new hashing function (or a string representing a property name for every key to use as the hash)
	 * @return {cjs.ArrayConstraint} - `this`
	 */
	proto.setHash = function (hash) {
		cjs.wait();
		// First, empty out the old key hash and unsubstantiated values
		this._hash = isString(hash) ? get_str_hash_fn(hash) : hash;
		this._khash = {};
		// Then, for every one of my values, re-hash
		each(this._ordered_values, function (info) {
			var key = info.key.get();
			var hash = this._hash(key);
			var hash_val = this._khash[hash];
			if (hash_val) {
				hash_val.push(info);
			} else {
				this._khash[hash] = [info];
			}
		}, this);

		// And re-hash for every unsubstantiated value
		var new_unsubstantiated_values = {};
		each(this._unsubstantiated_values, function(unsubstantiated_value_arr) {
			each(unsubstantiated_value_arr, function(info) {
				var key = info.key.get();
				var hash = this._hash(key);
				var hash_val = this.new_unsubstatiated_values[hash];
				if(hash_val) {
					hash_val.push(info);
				} else {
					new_unsubstantiated_values[hash] = [info];
				}
			}, this);
		}, this);
		this._unsubstantiated_values = new_unsubstantiated_values;

		cjs.signal();
		return this;
	};

	/**
	 * Change the hash function when getting a value
	 * 
	 * @method setValueHash
	 * @param {function|string} hash - The new hashing function (or a string representing a property name for every key to use as the hash)
	 * @return {cjs.ArrayConstraint} - `this`
	 */
	proto.setValueHash = function (vhash) {
		this._valuehash = isString(vhash) ? get_str_hash_fn(vhash) : vhash;
		// Empty out the old value hash
		this._vhash = {};

		if (this._valuehash) {
			// And reset the value hash for every element
			each(this._ordered_values, function (info) {
				var value = info.value.get();
				var hash = this._valuehash(value);
				var hash_val = this._vhash[hash];
				if (hash_val) {
					hash_val.push(info);
				} else {
					this._vhash[hash] = [info];
				}
			}, this);
		}

		return this;
	};

	/**
	 * Get the index of the entry with key = `key`
	 * 
	 * @method indexOf
	 * @param {*} key - The key to search for.
	 * @return {number} - The index of the entry with key=`key` or `-1`
	 *
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.indexOf('z'); // -1
	 */
	proto.indexOf = function (key) {
		// get hash information
		var ki = _find_key.call(this, key, true, this._create_unsubstantiated),
			key_index = ki.i,
			hash_values = ki.hv;
		if (key_index >= 0) { // Found! return the proper item's index
			var info = hash_values[key_index];
			return info.index.get();
		} else if(ki.ui >= 0) { // Not found but creating unsubstantiated items
			var unsubstantiated_info = ki.uhv[ki.ui];
			return unsubstantiated_info.index.get(); // create a dependency
		} else { // Not found and not creating unsubstantiated items
			return -1;
		}
	};

	/**
	 * Search for a key or create it if it wasn't found
	 * 
	 * @method getOrPut
	 * @param {*} key - The key to search for.
	 * @param {function} create_fn - A function to create the value if `key` is not found
	 * @param {*} [create_fn_context] - The context in which to call `create_fn`
	 * @param {number} [index=this.size] - Where to place a value that is created
	 * @param {boolean} [literal=false] - Whether to create the value as a literal constraint
	 * (the value of a function is the function)
	 * @return {number} - The index of the entry with key=`key` or `-1`
	 *
	 * @see get
	 * @see put
	 * @see item
	 * @example
	 *     var map = xjs({x: 1, y: 2});
	 *     map.getOrPut('x', function() {
	 *         console.log("evaluating");
	 *         return 3;
	 *     }); // output: 'evaluating'
	 *     // 3
	 *     map.getOrPut('x', function() {
	 *         console.log("evaluating");
	 *         return 3;
	 *     }); // (no output)
	 *     // 3
	 */
	proto.getOrPut = function (key, create_fn, create_fn_context, index, literal) {
		var ki = _find_key.call(this, key, true, false, literal),
			key_index = ki.i, // index within hash array
			hash_values = ki.hv, // hash array
			hash = ki.h, // hash value
			context, value, info;

		if (key_index >= 0) { // found actual item!
			info = hash_values[key_index];
			return info.value.get();
		} else { // need to create it
			cjs.wait();
			context = create_fn_context || this;
			value = create_fn.call(context, key); // will set the value to this
			_do_set_item_ki.call(this, ki, key, value, index, literal); // do the work of putting
			cjs.signal();
			return value;
		}
	};

	/**
	 * Check if there is any entry with key = `key`
	 * 
	 * @method has
	 * @param {*} key - The key to search for.
	 * @return {boolean} - `true` if there is an entry with key=`key`, `false` otherwise.
	 *
	 * @see get
	 * @see item
	 * @example
	 *     var map = cjs({x: 1, y: 2});
	 *     map.has('x'); // true
	 */
	proto.has = function (key) {
		var ki = _find_key.call(this, key, true, this._create_unsubstantiated);
		var key_index = ki.i;
		if (key_index >= 0) { // Found successfully
			return true;
		} else if(this._create_unsubstantiated) { // Didn't find but there is an unsubstantiated item
			var unsubstantiated_info = ki.uhv[ki.ui];
			unsubstantiated_info.index.get(); // Add a dependency
			return false;
		} else { // No dependency to be added; just say we didn't find it
			return false;
		}
	};

	/**
	 * Move the entry at `old_index` to index `new_index`
	 *
	 * @method moveIndex
	 * @param {number} old_index - The index to move from
	 * @param {number} new_index - The index to move to
	 * @return {cjs.ArrayConstraint} - `this`
	 * @example
	 *     var map = cjs({x: 1, y: 2, z: 3});
	 *     map.keys(); // ['x','y', 'z']
	 *     map.moveIndex(1, 0)
	 *     map.keys(); // ['y','x', 'z']
	 */
	proto.moveIndex = function (old_index, new_index) {
		var i;
		cjs.wait();
		var info = this._ordered_values[old_index];
		// take out the old value
		this._ordered_values.splice(old_index, 1);
		// and re-add it
		this._ordered_values.splice(new_index, 0, info);

		// Properly iterate regardless of whether moving higher or lower
		var low = Math.min(old_index, new_index);
		var high = Math.max(old_index, new_index);
		// update the indicies of every thing between that might have been affected
		for (i = low; i <= high; i += 1) {
			_set_index(this._ordered_values[i], i);
		}

		// Invalidate the relevant properties (size shouldn't change)
		this.$keys.invalidate();
		this.$values.invalidate();
		this.$entries.invalidate();

		cjs.signal();
		return this;
	};

	/**
	 * Move the entry with key `key` to `index
	 *
	 * @method move
	 * @param {*} key - The key to search for 
	 * @param {number} to_index - The new index for the key
	 * @return {cjs.ArrayConstraint} - `this`
	 * @example
	 *     var map = cjs({x: 1, y: 2, z: 3});
	 *     map.keys(); // ['x','y', 'z']
	 *     map.move('z', 0)
	 *     map.keys(); // ['z','x', 'y']
	 */
	proto.move = function (key, to_index) {
		//Move a key to a new index
		var ki = _find_key.call(this, key, false, false);
		var key_index = ki.i;
		if (key_index >= 0) {
			var info = ki.hv[key_index];
			// leverage the previous move_index function
			this.moveIndex(info.index.get(), to_index);
		}
		return this;
	};

	/**
	 * Given a value, find the corresponding key
	 *
	 * @method keyForValue
	 * @param {*} value - The value whose key to search for 
	 * @param {function} [eq_check] - How to check if two values are equal (default: `===`
	 * @return {*|undefined} - The key where `this.get(key)===value`
	 * @example
	 *     var map = cjs({x: 1, y: 2, z: 3});
	 *     map.keyForValue(1); // 'x'
	 */
	proto.keyForValue = function (value, eq_check) {
		eq_check = eq_check || this.$vequality_check.get();
		var i;
		// It's advantageous here to use a value hash if it's there
		if (this._vhash) {
			var value_hash = this._valuehash(value);
			var vhash_val = this._vhash[value_hash];
			// Find that value hash's array
			if (vhash_val) {
				var len = vhash_val.length;
				for (i = 0; i < len; i += 1) {
					var info = vhash_val[i];
					if (eq_check(info.value.get(), value)) { // found it! here's the key
						return info.key.get();
					}
				}
			}
			// Didn't find it
			return undefined;
		} else {
			// Without a value hash, we have to iterate through every item
			var key;
			this.forEach(function (v, k) {
				if (eq_check(value, v)) { // found
					key = k;
					return my.BREAK; // Break out of the forEach
				}
			});
			return key;
		}
	};

	/**
	 * Clear this object and try to clean up any memory.
	 *
	 * @method destroy
	 * @param {boolean} [silent=false] - If set to `true`, avoids invalidating any dependent constraints.
	 */
	proto.destroy = function (silent) {
		cjs.wait();
		this.clear(silent);
		this.$equality_check.destroy(silent);
		this.$vequality_check.destroy(silent);
		this.$keys.destroy(silent);
		this.$values.destroy(silent);
		this.$entries.destroy(silent);
		this.$size.destroy(silent);
		cjs.signal();
	};

	/**
	 * Converts this array to a JavaScript object.
	 *
	 * @method toObject
	 * @param {function} [key_map_fn] - A function to convert keys
	 * @return {object} - This object as a JavaScript object
	 * @example
	 *     var map = cjs({x: 1, y: 2, z: 3});
	 *     map.toObject(); // {x:1,y:2,z:3}
	 */
	proto.toObject = function (key_map_fn) {
		var rv = {};
		key_map_fn = key_map_fn || identity; // just use the key if not supplied
		this.forEach(function (v, k) { rv[key_map_fn(k)] = v; });
		return rv;
	};
}(MapConstraint));
/** @lends */

/**
 * Determine whether an object is a map constraint
 * @method cjs.isMapConstraint
 * @param {*} obj - An object to check
 * @return {boolean} - `true` if `obj` is a `cjs.MapConstraint`, `false` otherwise
 */
is_map = function(obj) {
	return obj instanceof MapConstraint;
};

extend(cjs, {
	/**
	 * Create a map constraint
	 * @method cjs.map
	 * @constructs cjs.MapConstraint
	 * @param {Object} [options] - A set of options to control how the map constraint is evaluated
	 * @return {cjs.MapConstraint} - A new map constraint object
	 * @see cjs.MapConstraint
	 * @example Creating a map constraint
	 *
	 *     var map_obj = cjs.map({
	 *         value: { foo: 1 }
	 *     });
	 *     cobj.get('foo'); // 1
	 *     cobj.put('bar', 2);
	 *     cobj.get('bar') // 2
	 */
	map: function (arg0, arg1) { return new MapConstraint(arg0, arg1); },
	/** @expose cjs.MapConstraint */
	MapConstraint: MapConstraint,
	/** @expose cjs.isMapConstraint */
	isMapConstraint: is_map
});

// Liven
// -----

// Will automatically call the provided function when it becomes invalid
extend(cjs, {
	/**
	 * Memoize a function to avoid unnecessary re-evaluation. Its options are:
	 *
	 * - `context`: The context in which `func` should be evaluated
	 * - `run_on_create`: Whether to run `func` immediately after creating the live function. (default: `true`)
	 * - `pause_while_running`: Whether to explicitly prevent this live function from being called recursively (default: `false`)
	 * - `on_destroy`: A function to call when `destroy` is called (default: `false`)
	 *
	 * The return value of this method also has two functions:
	 * - `pause`: Pause evaluation of the live function
	 * - `resume`: Resume evaluation of the live function
	 * - `run`: Run `func` if it's invalid
	 *
	 * @method cjs.liven
	 * @param {function} func - The function to make live
	 * @param {object} [options] - A set of options to control how liven works
	 * @return {object} An object with properties `destroy`, `pause`, `resume`, and `run`
	 *
	 * @example
	 *     var x_val = cjs(0);
	 *     var api_update = cjs.liven(function() {
	 *         console.log('updating other x');
	 *         other_api.setX(x_val);
	 *     }); // 'updating other x'
	 *     x_val.set(2); // 'updating other x'
	 *		
	 */
	liven:	function (func, options) {
				options = extend({
					context: root, // what to equate `this` to
					run_on_create: true, // whether it should run immediately
					pause_while_running: false, // whether to allow the function to be called recursively (indirectly)
					priority: false,
					on_destroy: false // a function to call when this liven function is destroyed
				}, options);

				//Make constraint-aware values just by calling func in a constraint
				var node = new Constraint(func, {
					context: options.context,
					cache_value: false,
					auto_add_outgoing_dependencies: false,
					run_on_add_listener: false
				});

				// check if running
				var paused = false;
				var do_get;

				var invalidate = function() {
					node.invalidate();
				};

				// Destroy the node and make sure no memory is allocated
				var destroy = function (silent) {
					if(options.on_destroy) {
						options.on_destroy.call(options.context, silent);
					}
					node.destroy(silent);
				};

				// Stop changing and remove it from the event queue if necessary
				var pause = function () {
					if(paused === false) {
						paused = true;
						node.offChange(do_get);
						return true; // successfully paused
					}
					return false;
				};

				// Re-add to the event queue
				var resume = function () {
					if(paused === true) {
						paused = false;
						node.onChangeWithPriority(options.priority, do_get);
						if(options.run_on_create !== false) {
							if (constraint_solver.semaphore >= 0) {
								node.get(false);
							} else {
								each(node._changeListeners, constraint_solver.add_in_call_stack, constraint_solver);
							}
						}
						return true; // successfully resumed
					}
					return false;
				};

				// The actual getter, will call the constraint's getter
				do_get = function () {
					if (options.pause_while_running) {
						pause();
					}
					node.get();
					if (options.pause_while_running) {
						resume();
					}
				};

				// When the value changes, call do_get
				node.onChangeWithPriority(options.priority, do_get);

				var rv = {
					destroy: destroy,
					pause: pause,
					resume: resume,
					run: function(arg0) {
						do_get(arg0);
						return this;
					},
					invalidate: invalidate,
					_constraint: node // for debugging purposes
				};

				if(options.run_on_create !== false) {
					if (constraint_solver.semaphore >= 0) {
						node.get(false);
					} else {
						each(node._changeListeners, constraint_solver.add_in_call_stack, constraint_solver);
					}
				}

				return rv;
			}
});

// A function to hash the arguments passed in. By default, just a concatenation of the arguments' string value
var memoize_default_hash = function () {
	var i, len = arguments.length;
	var rv = "";
	for (i = 0; i < len; i += 1) {
		rv += arguments[i];
	}
	return rv;
},
// A function to check if two sets of arguments are equal; by default just check every value
memoize_default_equals = function (args1, args2) {
	var i,
		len = args1.length;
	if (len === args2.length) {
		for (i = 0; i < len; i += 1) {
			var arg1 = args1[i],
				arg2 = args2[i];
			if (arg1 !== arg2) {
				return false;
			}
		}
		return true;
	} else {
		return false;
	}
};

extend(cjs, {
	/**
	 * Memoize a function to avoid unnecessary re-evaluation. Its options are:
	 *
	 * - `hash`: Create a unique value for each set of arguments (call with an argument array)
	 * - `equals`: check if two sets of arguments are equal (call with two argument arrays)
	 * - `context`: The context in which `getter_fn` should be evaluated
	 * - `literal_values`: Whether values should be literal if they are functions
	 *
	 * The return value of this method also has two functions:
	 * - `each`: Iterate through every set of arguments and value that is memoized
	 * - `destroy`: Clear the memoized values to clean up memory
	 *
	 * @method cjs.memoize
	 * @param {function} getter_fn - The function to memoize
	 * @param {object} [options] - A set of options to control how memoization works
	 * @return {function} The memoized function
	 *
	 * @example
	 *
	 *     var arr = cjs([3,2,1,4,5,10]),
	 *     get_nth_largest = cjs.memoize(function(n) {
	 *         console.log('recomputing');
	 *         var sorted_arr = arr memoized fn.sort();
	 *         return sorted_arr[ny];
	 *     });
	 *
	 *     get_nth_largest(0); // logfged: recomputing
	 *     get_nth_largest(0); //ulli (nothing logged because answer memoized)
	 *     arr.splice(0, 1); // N
	 *     get_nth_largest(0); // logged: recomputing
	 */
	memoize: function (getter_fn, options) {
		options = extend({
			hash: memoize_default_hash,
			equals: memoize_default_equals,
			context: root,
			literal_values: true
		}, options);

		// Map from args to value
		options.args_map = new MapConstraint({
			hash: options.hash,
			equals: options.equals,
			literal_values: options.literal_values
		});

		// When getting a value either create a constraint or return the existing value
		var rv = function () {
			var args = slice.call(arguments),
				constraint = options.args_map.getOrPut(args, function() {
					return new Constraint(function () {
						return getter_fn.apply(options.context, args);
					});
				});
			return constraint.get();
		};

		// Clean up memory after self
		rv.destroy = function (silent) {
			options.args_map.forEach(function (constraint) {
				constraint.destroy(silent);
			});
			options.args_map.destroy(silent);
		};

		// Run through every argument and call fn on it
		rv.each = function (fn) {
			options.args_map.forEach(fn);
		};
		rv.options = options;
		return rv;
	}
});

var make_node = function(item) { // Check if the argument is a DOM node or create a new textual node with its contents
		if(isAnyElement(item)) {
			return item;
		} else {
			var node = doc.createTextNode(item);
			return node;
		}
	},
	insert_at = function(child_node, parent_node, index) {
		// Utility function to insert child_node as the index-th child of parent_node
		var children = parent_node.childNodes;
		if(children.length <= index) {
			parent_node.appendChild(child_node);
		} else {
			var before_child = children[index];
			parent_node.insertBefore(child_node, before_child);
		}
	},
	remove_index = function(parent_node, index) {
		// Utility to remove a child DOM node by index
		var children = parent_node.childNodes, child_node;
		if(children.length > index) {
			child_node = children[index];
			parent_node.removeChild(child_node);
			return child_node;
		}
	},
	move_child = function(parent_node, to_index, from_index) {
		// Utility to move a child DOM node by indices
		var children = parent_node.childNodes;
		if(children.length > from_index) {
			var child_node = children[from_index];
			if(parent_node) {
				if(from_index < to_index) { //If it's less than the index we're inserting at...
					to_index++; //Increase the index by 1, to make up for the fact that we're removing me at the beginning
				}
				insert_at(child_node, parent_node, to_index);
			}
			return child_node;
		}
	},
	// Check if jQuery is available
	is_jquery_obj = function(x) {
		return has(root, "jQuery") ? (x instanceof root.jQuery) : false;
	},
	nList = root.NodeList || false,
	// a node list is what is returned when you call getElementsByTagName, etc.
	isNList = nList ? function(x) { return x instanceof nList; } : function() { return false; },

	// Convert an object that can be passed into a binding into an array of dom elements
	get_dom_array = function(obj) {
		if(isArray(obj)) { // already an array
			return obj;
		} else if (is_constraint(obj)) { // regular constraint
			return get_dom_array(obj.get());
		} else if(is_array(obj)) { // array constraint
			return obj.toArray();
		} else if(is_map(obj)) { // map constraint
			return obj.values();
		} else if(is_jquery_obj(obj)) { // jQuery object
			return root.jQuery.makeArray(obj);
		} else if(isNList(obj)) { // node list
			return toArray(obj);
		} else { // hopefully just an element; return its value as an array
			return [obj];
		}
	};

/**
 * A binding calls some arbitrary functions passed into options. It is responsible for keeping some aspect of a
 * DOM node in line with a constraint value. For example, it might keep an element's class name in sync with a
 * class_name constraint
 *
 * @private
 * @class cjs.Binding
 * @param {object} options
 * @classdesc Bind a DOM node property to a constraint value
 */
var Binding = function(options) {
	this.options = options;
	this.targets = options.targets; // the DOM nodes
	var setter = options.setter, // a function that sets the attribute value
		getter = options.getter, // a function that gets the attribute value
		init_val = options.init_val, // the value of the attribute before the binding was set
		curr_value, // used in live fn
		last_value, // used in live fn
		old_targets = [], // used in live fn
		do_update = function() {
			this._timeout_id = false; // Make it clear that I don't have a timeout set
			var new_targets = filter(get_dom_array(this.targets), isAnyElement); // update the list of targets

			if(has(options, "onChange")) {
				options.onChange.call(this, curr_value, last_value);
			}

			// For every target, update the attribute
			each(new_targets, function(target) {
				setter.call(this, target, curr_value, last_value);
			}, this);

			// track the last value so that next time we call diff
			last_value = curr_value;
		};
	this._throttle_delay = false; // Optional throttling to improve performance
	this._timeout_id = false; // tracks the timeout that helps throttle

	if(isFunction(init_val)) { // If init_val is a getter, call it on the first element
		last_value = init_val(get_dom_array(this.targets[0]));
	} else { // Otherwise, just take it as is
		last_value = init_val;
	}

	this.$live_fn = cjs.liven(function() {
		curr_value = getter(); // get the value once and inside of live fn to make sure a dependency is added

		if(this._throttle_delay) { // We shouldn't update values right away
			if(!this._timeout_id) { // If there isn't any timeout set yet, then set a timeout to delay the call to do update
				this._timeout_id = sTO(bind(do_update, this), this._throttle_delay);
			}
		} else { // we can update the value right away if no throttle delay is set
			do_update.call(this);
		}
	}, {
		context: this
	});
};

(function(my) {
	/** @lends cjs.Binding.prototype */
	var proto = my.prototype;
	/**
	 * Pause binding (no updates to the attribute until resume is called)
	 *
	 * @method pause
	 * @return {Binding} `this`
	 * @see resume
	 * @see throttle
	 */
	proto.pause = function() { this.$live_fn.pause(); return this; };

	/**
	 * Resume binding (after pause)
	 *
	 * @method resume
	 * @return {Binding} `this`
	 * @see pause
	 * @see throttle
	 */
	proto.resume = function() { this.$live_fn.resume(); return this; };


	/**
	 * Require at least `min_delay` milliseconds between setting the attribute
	 *
	 * @method throttle
	 * @param {number} min_delay - The minimum number of milliseconds between updates
	 * @return {Binding} `this`
	 * @see pause
	 * @see resume
	 */
	proto.throttle = function(min_delay) {
		this._throttle_delay = min_delay > 0 ? min_delay : false; // Make sure it's positive
		if(this._timeout_id && !this._throttle_delay) { // If it was specified that there should be no delay and we are waiting for a re-eval
			cTO(this._timeout_id); // then prevent that re-eval
			this._timeout_id = false;
		}
		// regardless, run the live fn again
		this.$live_fn.run();
		return this;
	};

	/**
	 * Stop updating the binding and try to clean up any memory
	 *
	 * @method destroy
	 * @return {undefined}
	 * @see pause
	 * @see resume
	 * @see throttle
	 */
	proto.destroy = function() {
		this.$live_fn.destroy();
		if(this.options.onDestroy) {
			this.options.onDestroy();
		}
		if(this.options.coreDestroy) {
			this.options.coreDestroy();
		}
	};
}(Binding));
/** @lends */

// Creates a type of binding that accepts any number of arguments and then sets an attribute's value to depend on
// every element that was passed in
var create_list_binding = function(list_binding_getter, list_binding_setter, list_binding_init_value) {
		return function(elements) { // The first argument is a list of elements
			var args = slice.call(arguments, 1), // and the rest are values
				val = cjs(function() { // Create a constraint so that the binding knows of any changes
					return list_binding_getter(args);
				});

			var binding = new Binding({
				targets: elements,
				getter: bind(val.get, val), // use the constraint's value as the getter
				setter: list_binding_setter,
				init_val: list_binding_init_value,
				coreDestroy: function() {
					val.destroy(); // Clean up the constraint when we are done
				}
			});
			return binding;
		};
	},
	create_textual_binding = function(setter) { // the text value of a node is set to the concatenation of every argument
		return create_list_binding(function(args) {
			return map(args, cjs.get).join("");
		}, function(element, value) {
			setter(element, value);
		});
	},
	// a binding that accepts either a key and a value or an object with any number of keys and values
	create_obj_binding = function(obj_binding_setter) {
		return function(elements) {
			var vals,
				args = slice.call(arguments, 1);
			if(args.length === 0) { // need at least one argument
				return;
			} else if(args.length === 1) { // an object with keys and values was passed in
				vals = args[0];
			} else if(args.length > 1) { // the first argument was the key, the second was a value
				vals = {};
				vals[args[0]] = args[1];
			}

			var binding = new Binding({
				targets: elements,
				setter: function(element, value) {
					each(value, function(v, k) {
						obj_binding_setter(element, k, v);
					});
				},
				getter: function() {
					if(is_map(vals)) {
						return vals.toObject();
					} else {
						var rv = {};
						each(vals, function(v, k) {
							rv[k] = cjs.get(v);
						});
						return rv;
					}
				}
			});

			return binding;
		};
	};

	/**
	 * Constrain a DOM node's text content
	 *
	 * @method cjs.bindText
	 * @param {dom} element - The DOM element
	 * @param {*} ...values - The desired text value
	 * @return {Binding} - A binding object
	 * @example If `my_elem` is a dom element
	 *
	 *     var message = cjs('hello');
	 *     cjs.bindText(my_elem, message);
	 */
var text_binding = create_textual_binding(function(element, value) { // set the escaped text of a node
		setTextContent(element, value);
	}),

	/**
	 * Constrain a DOM node's HTML content
	 *
	 * @method cjs.bindHTML
	 * @param {dom} element - The DOM element
	 * @param {*} ...values - The desired html content
	 * @return {Binding} - A binding object
	 * @example If `my_elem` is a dom element
	 *
	 *     var message = cjs('<b>hello</b>');
	 *     cjs.bindHTML(my_elem, message);
	 */
	html_binding = create_textual_binding(function(element, value) { // set the non-escaped inner HTML of a node
		element.innerHTML = value;
	}),

	/**
	 * Constrain a DOM node's value
	 *
	 * @method cjs.bindValue
	 * @param {dom} element - The DOM element
	 * @param {*} ...values - The value the element should have
	 * @return {Binding} - A binding object
	 * @example If `my_elem` is a text input element
	 *
	 *     var value = cjs('hello');
	 *     cjs.bindValue(my_elem, message);
	 */
	val_binding = create_textual_binding(function(element, value) { // set the value of a node
		element.val = value;
	}),

	/**
	 * Constrain a DOM node's class names
	 *
	 * @method cjs.bindClass
	 * @param {dom} element - The DOM element
	 * @param {*} ...values - The list of classes the element should have. The binding automatically flattens them.
	 * @return {Binding} - A binding object
	 * @example If `my_elem` is a dom element
	 *
	 *     var classes = cjs('class1 class2');
	 *     cjs.bindClass(my_elem, classes);
	 */
	class_binding = create_list_binding(function(args) { // set the class of a node
		return flatten(map(args, cjs.get), true);
	}, function(element, value, old_value) {
		// Compute difference so that old class values remain
		var ad = get_array_diff(old_value, value),
			curr_class_name = " " + element.className + " "; // add spaces so that the replace regex doesn't need extra logic

		// take out all of the removed classes
		each(ad.removed, function(removed_info) { curr_class_name = curr_class_name.replace(" " + removed_info.from_item + " ", " "); });
		// and add all of the added classes
		curr_class_name += map(ad.added, function(x) { return x.item; }).join(" ");

		curr_class_name = trim(curr_class_name); // and trim to remove extra spaces

		element.className = curr_class_name; // finally, do the work of setting the class
	}, []), // say that we don't have any classes to start with

	/**
	 * Constrain a DOM node's children
	 *
	 * @method cjs.bindChildren
	 * @param {dom} element - The DOM element
	 * @param {*} ...elements - The elements to use as the constraint. The binding automatically flattens them.
	 * @return {Binding} - A binding object
	 * @example If `my_elem`, `child1`, and `child2` are dom elements
	 *
	 *     var nodes = cjs(child1, child2);
	 *     cjs.bindChildren(my_elem, nodes);
	 */
	children_binding = create_list_binding(function(args) {
		var arg_val_arr = map(args, cjs.get);
		return map(flatten(arg_val_arr, true), make_node);
	}, function(element, value, old_value) {
		var ad = get_array_diff(old_value, value);
		each(ad.removed, function(removed_info) {
			var child_node = remove_index(element, removed_info.from);
			if(this.options.onRemove) {
				this.options.onRemove.call(this, child_node, removed_info.from);
			}
		}, this);
		each(ad.added, function(added_info) {
			var child_node = added_info.item;
			insert_at(child_node, element, added_info.to);
			if(this.options.onAdd) {
				this.options.onAdd.call(this, child_node, added_info.to);
			}
		}, this);
		each(ad.moved, function(moved_info) {
			var child_node = move_child(element, moved_info.to_index, moved_info.from_index);
			if(this.options.onMove) {
				this.options.onMove.call(this, child_node, moved_info.to_index, moved_info.from_index);
			}
		}, this);

		if(this.options.onIndexChange) {
			each(ad.index_changed, function(ic_info) {
				this.options.onIndexChange.call(this, ic_info.item, ic_info.to, ic_info.from);
			}, this);
		}
	}, function(element) {
		return toArray(element.childNodes);
	}),

	/**
	 * Constrain a DOM node's CSS style
	 *
	 * @method cjs.bindCSS
	 * @param {dom} element - The DOM element
	 * @param {object} values - An object whose key-value pairs are the CSS property names and values respectively
	 * @return {Binding} - A binding object representing the link from constraints to CSS styles
	 *
	 * @example If `my_elem` is a dom element
	 *
	 *     var color = cjs('red'),
	 *     left = cjs(0);
	 *     cjs.bindCSS(my_elem, {
	 *         "background-color": color,
	 *         left: left.add('px')
	 *     });
	 */
	/**
	 * Constrain a DOM node's CSS style
	 *
	 * @method cjs.bindCSS^2
	 * @param {string} key - The name of the CSS attribute to constraint
	 * @param {cjs.Constraint|string} value - The value of this CSS attribute
	 * @return {Binding} - A binding object representing the link from constraints to elements
	 *
	 * @example If `my_elem` is a dom element
	 *
	 *     var color = cjs('red');
	 *     cjs.bindCSS(my_elem, ''background-color', color);
	 */
	css_binding = create_obj_binding(function(element, key, value) {
		element.style[camel_case(key)] = value;
	}),

	/**
	 * Constrain a DOM node's attribute values
	 *
	 * @method cjs.bindAttr
	 * @param {dom} element - The DOM element
	 * @param {object} values - An object whose key-value pairs are the attribute names and values respectively
	 * @return {Binding} - A binding object representing the link from constraints to elements
	 *
	 * @example If `my_elem` is an input element
	 *
	 *     var default_txt = cjs('enter name');
	 *     cjs.bindAttr(my_elem, 'placeholder', default_txt);
	 */
	/**
	 * Constrain a DOM node's attribute value
	 *
	 * @method cjs.bindAttr^2
	 * @param {string} key - The name of the attribute to constraint
	 * @param {cjs.Constraint|string} value - The value of this attribute
	 * @return {Binding} - A binding object representing the link from constraints to elements
	 *
	 * @example If `my_elem` is an input element
	 *
	 *     var default_txt = cjs('enter name'),
	 *         name = cjs('my_name');
	 *     cjs.bindAttr(my_elem, {
	 *         placeholder: default_txt,
	 *         name: name
	 *     });
	 */
	attr_binding = create_obj_binding(function(element, key, value) {
		if(fillAttrs[key] && !value) { // attributes like disabled that should be there or not
			element.removeAttribute(key);
		} else {
			element.setAttribute(key, value);
		}
	});

var inp_change_events = ["keyup", "input", "paste", "propertychange", "change"],
	/**
	 * Take an input element and create a constraint whose value is constrained to the value of that input element
	 *
	 * @method cjs.inputValue
	 * @param {dom} inp - The input element
	 * @return {cjs.Constraint} - A constraint whose value is the input's value
	 *
	 * @example If `name_input` is an input element
	 *
	 *     var name = cjs.inputValue(name_input),
	 */
	getInputValueConstraint = function(inps) {
		var arr_inp; // tracks if the input is a list of items
		if(isElement(inps)) {
			inps = [inps];
			arr_inp = false;
		} else {
			arr_inp = true;
		}
		// the constraint should just return the value of the input element
		var constraint = cjs(function() {
				if(arr_inp) {
					return map(inps, function(inp) { return inp.value; }); // if it's an array, return every value
				} else {
					return inps[0].value; // otherwise, just return the first value
				}
			}),
			len = inps.length,
			on_change = bind(constraint.invalidate, constraint), // when any input event happens, invalidate the constraint
			activate = function() { // add all the event listeners for every input and event type
				each(inp_change_events, function(event_type) {
					each(inps, function(inp) {
						aEL(inp, event_type, on_change);
					});
				});
			},
			deactivate = function() { // clear all the event listeners for every input and event type
				each(inp_change_events, function(event_type) {
					each(inps, function(inp) {
						rEL(inp, event_type, on_change);
					});
				});
			},
			oldDestroy = constraint.destroy;

		// when the constraint is destroyed, remove the event listeners
		constraint.destroy = function() {
			deactivate();
			oldDestroy.call(constraint);
		};

		activate();
		return constraint;
	};

extend(cjs, {
	/** @expose cjs.bindText */
	bindText: text_binding,
	/** @expose cjs.bindHTML */
	bindHTML: html_binding,
	/** @expose cjs.bindValue */
	bindValue: val_binding,
	/** @expose cjs.bindChildren */
	bindChildren: children_binding,
	/** @expose cjs.bindAttr */
	bindAttr: attr_binding,
	/** @expose cjs.bindCSS */
	bindCSS: css_binding,
	/** @expose cjs.bindClass */
	bindClass: class_binding,
	/** @expose cjs.inputValue */
	inputValue: getInputValueConstraint,
	/** @expose cjs.Binding */
	Binding: Binding
});

// Finite State Machines
// ---------------------

// State keeps track of basic state information (its containing FSM does most of the work)
var State = function(fsm, name) {
	this._fsm = fsm; // parent fsm
	this._name = name; // state name (fetch with getName)
	this._id = uniqueId(); // useful for storage
};

(function(my) {
	var proto = my.prototype;
	proto.getName = function() { return this._name; }; // getter for name
	proto.id = function() { return this._id; }; // getter for id
}(State));

// Simple transition representation (again, the containing FSM does most of the work)
var Transition = function(fsm, from_state, to_state, name) {
	this._fsm = fsm; // parent FSM
	this._from = from_state; // from state (fetch with getFrom)
	this._to = to_state; // to state (fetch with getTo)
	this._name = name; // name (fetch with getName)
	this._id = uniqueId(); // useful for storage
	this._event = false; // the CJSEvent (if created) for this transition
};

(function(my) {
	var proto = my.prototype;
	proto.getFrom = function() { return this._from; }; // from getter
	proto.getTo = function() { return this._to; }; // to getter
	proto.getName = function() { return this._name; }; // name getter
	proto.getFSM = function() { return this._fsm; }; // FSM getter
	proto.id = function() { return this._id; }; // getter for id
	proto.destroy = function() {
		var ev = this._event;
		if(ev) { ev._removeTransition(this); }
		delete this._event;
		delete this._fsm;
		delete this._from;
		delete this._to;
	};
	proto.setEvent = function(event) { this._event = event; };
	proto.run = function() {
		var fsm = this.getFSM();
		// do_transition should be called by the user's code
		if(fsm && fsm.is(this.getFrom())) {
			var args = toArray(arguments);
			args.unshift(this.getTo(), this);
			fsm._setState.apply(fsm, args);
		}
	};
}(Transition));

/*
 * The following selector constructors are used internally to keep track of user-specified
 * selectors (a -> b represents the transition from a to b).
 * 
 * Developers using cjs can specify that they want to add listeners for any number of such
 * selectors and they will be dynamically evaluated and called. For instance, if the user
 * adds a selector for any state to stateA (represented as * -> stateA) *before* stateA is
 * created, then if the developer later adds a state named stateA, their callback should be
 * called whenever the fsm transitions to that newly created stateA
 */

// The selector for a state with a supplied name (e.g. stateA)
var StateSelector = function(state_name) {
	this._state_name = state_name;
};
(function(my) {
	var proto = my.prototype;
	proto.matches = function(state) {
		// Supplied object should be a State object with the given name
		return this._state_name === state || (state instanceof State && this._state_name === state.getName());
	};
}(StateSelector));

// Matches any state (e.g. *)
var AnyStateSelector = function() { };
(function(my) {
	var proto = my.prototype;
	// will match any state (but not transition)
	// Checking if it isn't a transition (rather than if it is a State) because sometimes, this is
	// checked against state *names* rather than the state itself
	proto.matches = function(state) { return !(state instanceof Transition);};
}(AnyStateSelector));

// Matches certain transitions (see transition formatting spec)
var TransitionSelector = function(pre, from_state_selector, to_state_selector) {
	this.is_pre = pre; // should fire before the transition (as opposed to after)
	this.from_state_selector = from_state_selector; // the selector for the from state (should be a StateSelector or AnyStateSelector)
	this.to_state_selector = to_state_selector; // selector for the to state
};
(function(my) {
	var proto = my.prototype;
	// Make sure that the supplied object is a transition with the same timing
	proto.matches = function(transition, pre) {
		if(transition instanceof Transition && this.is_pre === pre) { 
			var from_state = transition.getFrom();
			var to_state = transition.getTo();
			// And then make sure both of the states match as well
			return this.from_state_selector.matches(from_state) &&
					this.to_state_selector.matches(to_state);
		} else { return false; }
	};
}(TransitionSelector));

// Multiple possibilities (read OR, not AND)
var MultiSelector = function() {
	this.selectors = toArray(arguments); // all of the selectors to test
};
(function(my) {
	var proto = my.prototype;
	proto.matches = function() {
		var match_args = arguments;
		// See if any selectors match
		return any(this.selectors, function(selector) {
			return selector.matches.apply(selector, match_args);
		});
	};
}(MultiSelector));

// return a selector object from a string representing a single state
var parse_single_state_spec = function(str) {
	if(str === "*") {
		return new AnyStateSelector();
	} else {
		return new StateSelector(str);
	}
};

// Parse one side of the transition
var parse_state_spec = function(str) {
	// Split by , and remove any excess spacing
	var state_spec_strs = map(str.split(","), function(ss) { return trim(ss); }); 

	// The user only specified one state
	if(state_spec_strs.length === 1) {
		return parse_single_state_spec(state_spec_strs[0]);
	} else { // any number of states
		var state_specs = map(state_spec_strs, parse_single_state_spec);
		return new MultiSelector(state_specs);
	}
};

// The user specified a transition
var parse_transition_spec = function(left_str, transition_str, right_str) {
	var left_to_right_transition, right_to_left_transition;
	var left_state_spec = parse_state_spec(left_str);
	var right_state_spec = parse_state_spec(right_str);

	// Bi-directional, after transition
	if(transition_str === "<->") {
		left_to_right_transition = new TransitionSelector(false, left_state_spec, right_state_spec);
		right_to_left_transition = new TransitionSelector(false, right_state_spec, left_state_spec);
		return new MultiSelector(left_to_right_transition, right_to_left_transition);
	} else if(transition_str === ">-<") { // bi-directional, before transition
		left_to_right_transition = new TransitionSelector(true, left_state_spec, right_state_spec);
		right_to_left_transition = new TransitionSelector(true, right_state_spec, left_state_spec);
		return new MultiSelector(left_to_right_transition, right_to_left_transition);
	} else if(transition_str === "->") { // left to right, after transition
		return new TransitionSelector(false, left_state_spec, right_state_spec);
	} else if(transition_str === ">-") { // left to right, before transition
		return new TransitionSelector(true, left_state_spec, right_state_spec);
	} else if(transition_str === "<-") { // right to left, after transition
		return new TransitionSelector(false, right_state_spec, left_state_spec);
	} else if(transition_str === "-<") { // right to left, before transition
		return new TransitionSelector(true, right_state_spec, left_state_spec);
	} else { return null; } // There shouldn't be any way to get here...
};

var transition_separator_regex = /^([\sa-zA-Z0-9,\-_*]+)((<->|>-<|->|>-|<-|-<)([\sa-zA-Z0-9,\-_*]+))?$/;
// Given a string specifying a state or set of states, return a selector object
var parse_spec = function(str) {
	var matches = str.match(transition_separator_regex);
	if(matches === null) {
		return null; // Poorly formatted specification
	} else {
		if(matches[2]) {
			// The user specified a transition: "A->b": ["A->b", "A", "->b", "->", "b"]
			var from_state_str = matches[1], transition_str = matches[3], to_state_str = matches[4];
			return parse_transition_spec(from_state_str, transition_str, to_state_str);
		} else {
			// The user specified a state: "A": ["A", "A", undefined, undefined, undefined]
			var states_str = matches[1];
			return parse_state_spec(states_str);
		}
	}
};


// StateListener
var state_listener_id = 0;
var StateListener = function(selector, callback, context) {
	this._context = context || root; // 'this' in the callback
	this._selector = selector; // used to record interest
	this._callback = callback; // the function to call when selector matches
	this._id = state_listener_id++; // unique id
};
(function(my) {
	var proto = my.prototype;
	// Used to determine if run should be called by the fsm
	proto.interested_in = function() { return this._selector.matches.apply(this._selector, arguments); };
	// Run the user-specified callback
	proto.run = function() { this._callback.apply(this._context, arguments); };
}(StateListener));

/**
 * ***Note:*** The preferred way to create a FSM is through the `cjs.fsm` function
 * This class represents a finite-state machine to track the state of an interface or component
 *
 * @private
 * @class cjs.FSM
 * @classdesc A finite-state machine
 * @param {string} ...state_names - Any number of state names for the FSM to have
 * @see cjs.fsm
 */
var FSM = function() {
	this._states = {}; // simple substate representations
	this._transitions = []; // simple transition representations
	this._curr_state = null; // the currently active state
	this._listeners = []; // listeners for every selector
	this._chain_state = null; // used internally for chaining
	this._did_transition = false; // keeps track of if any transition has run (so that when the user specifies
								// a start state, it knows whether or not to change the current state

	/**
	 * The name of this FSM's active state
	 * @property {Constraint} cjs.FSM.state
	 * @example
	 *
	 *     var my_fsm = cjs.fsm("state1", "state2");
	 *     my_fsm.state.get(); // 'state1'
	 */
	this.state = cjs(function() { // the name of the current state
		if(this._curr_state) { return this._curr_state._name; }
		else { return null; }
	}, {
		context: this
	});

	// Option to pass in state names as arguments
	this.addState.apply(this, flatten(arguments, true));
};
(function(my) {
	var proto = my.prototype;
	/** @lends cjs.FSM.prototype */

	// Find the state with a given name
	var getStateWithName = function(fsm, state_name) {
		return fsm._states[state_name];
	};

	/**
	 * Create states and set the current "chain state" to that state
	 *
	 * @method addState
	 * @param {string} ...state_names - Any number of state names to add. The last state becomes the chain state
	 * @return {FSM} - `this`
	 *
	 * @example
	 *
	 *     var fsm = cjs.fsm()
	 *                  .addState('state1')
	 *                  .addState('state2')
	 *                  .addTransition('state2', cjs.on('click'));
	 */
	proto.addState = function() {
		var state;
		each(arguments, function(state_name) {
			state = getStateWithName(this, state_name);
			if(!state) {
				state = this._states[state_name] = new State(this, state_name);
				// if there isn't an active state,
				// make this one the starting state by default
				if(this._curr_state === null) { this._curr_state = state; }
			}
		}, this);

		if(state) { this._chain_state = state; }

		return this;
	};

	/**
	 * Returns the name of the state this machine is currently in. Constraints that depend on the return
	 * value will be automatically updated.
	 *
	 * @method getState
	 * @return {string} - The name of the currently active state
	 * @example
	 *
	 *     var my_fsm = cjs.fsm("state1", "state2");
	 *     my_fsm.getState(); // 'state1'
	 */
	proto.getState = function() {
		return this.state.get();
	};
	
	/**
	 * Add a transition between two states
	 *
	 * @method addTransition
	 * @param {string} to_state - The name of the state the transition should go to
	 * @return {function} - A function that tells the transition to run
	 * @example
	 *
	 *     var x = cjs.fsm();
	 *     x.addState("b")
	 *      .addState("a");
	 *     var run_transition = x.addTransition("b");
	 *     //add a transition from a to b
	 *     window.addEventListener("click", run_transition);
	 *     // run that transition when the window is clicked
	 */
	/**
	 * (variant 2)
	 * @method addTransition^2
	 * @param {string} to_state - The name of the state the transition should go to
	 * @param {CJSEvent|function} add_transition_fn - A `CJSEvent` or a user-specified function for adding the event listener
	 * @return {FSM} - `this`
	 * @example
	 *
	 *     var x = cjs.fsm();
	 *     x.addState("b")
	 *      .addState("a")
	 *      .addTransition("b", cjs.on('click'));
	 *     // add a transition from a to b that runs when the window is clicked
	 * @example
	 *
	 *     var x = cjs.fsm();
	 *     x.addState("b")
	 *      .addState("a")
	 *      .addTransition("b", function(run_transition) {
	 *          window.addEventListener("click", run_transition);
	 *      });
	 *     // add a transition from a to b that runs when the window is clicked
	 */
	/**
	 * (variant 3)
	 * @method addTransition^3
	 * @param {string} from_state - The name of the state the transition should come from
	 * @param {string} to_state - The name of the state the transition should go to
	 * @return {function} - A function that tells the transition to run
	 * @example
	 *
	 *     var x = cjs.fsm("a", "b");
	 *     var run_transition = x.addTransition("a", "b"); //add a transition from a to b
	 *     window.addEventListener("click", run_transition); // run that transition when the window is clicked
	 */
	/**
	 * (variant 4)
	 * @method addTransition^4
	 * @param {string} from_state - The name of the state the transition should come from
	 * @param {string} to_state - The name of the state the transition should go to
	 * @param {CJSEvent|function} add_transition_fn - A `CJSEvent` or a user-specified function for adding the event listener
	 * @return {FSM} - `this`
	 *
	 * @example
	 *
	 *     var x = cjs.fsm("a", "b");
	 *     x.addTransition("a", "b", cjs.on("click"));
	 * @example
	 *
	 *     var x = cjs.fsm("a", "b");
	 *     var run_transition = x.addTransition("a", "b", function(run_transition) {
	 *         window.addEventListener("click", run_transition);
	 *     }); // add a transition from a to b that runs when the window is clicked
	 */
	proto.addTransition = function(a, b, c) {
		var from_state, to_state, transition, add_transition_fn, return_transition_func = false;

		if(arguments.length === 0) {
			throw new Error("addTransition expects at least one argument");
		} else if(arguments.length === 1) { // make a transition from the last entered state to the next state
			return_transition_func = true;
			from_state = this._chain_state;
			to_state = a;
		} else if(arguments.length === 2) {
			if(isFunction(b) || b instanceof CJSEvent) { // b is the function to add the transition
				from_state = this._chain_state;
				to_state = a;
				add_transition_fn = b;
			} else { // from and to states specified
				from_state = a;
				to_state = b;
				return_transition_func = true;
			}
		} else {
			from_state = a;
			to_state = b;
			add_transition_fn = c;
		}
		if(isString(from_state) && !has(this._states, from_state)) { this._states[from_state] = new State(this, from_state); }
		if(isString(to_state) && !has(this._states, to_state)) { this._states[to_state] = new State(this, to_state); }

		// do_transition is a function that can be called to activate the transition
		// Creates a new transition that will go from from_state to to_state
		transition = new Transition(this, from_state, to_state);
		this._transitions.push(transition);
		if(return_transition_func) {
			return bind(transition.run, transition);
		} else {
			if(add_transition_fn instanceof CJSEvent) {
				add_transition_fn._addTransition(transition);
				transition.setEvent(add_transition_fn);
			} else {
				// call the supplied function with the code to actually perform the transition
				add_transition_fn.call(this, bind(transition.run, transition), this);
			}
			return this;
		}
	};

	/**
	 * Changes the active state of this FSM.
	 * This function should, ideally, be called by a transition instead of directly.
	 *
	 * @private
	 * @method _setState
	 * @param {State|string} state - The state to transition to
	 * @param {Transition} transition - The transition that ran
	 */
	proto._setState = function(state, transition, event) {
		var from_state = this.getState(), // the name of my current state
			to_state = isString(state) ? getStateWithName(this, state) : state,
			listener_args = this._listeners.length > 0 ?
				([event, transition, to_state, from_state]).concat(rest(arguments, 3)) : false;
		if(!to_state) {
			throw new Error("Could not find state '" + state + "'");
		}
		this.did_transition = true;


		// Look for pre-transition callbacks
		each(this._listeners, function(listener) {
			if(listener.interested_in(transition, true)) {
				listener.run.apply(listener, listener_args); // and run 'em
			}
		});
		this._curr_state = to_state;
		this.state.invalidate();
		// Look for post-transition callbacks..
		// and also callbacks that are interested in state entrance
		each(this._listeners, function(listener) {
			if(listener.interested_in(transition, false) ||
					listener.interested_in(to_state)) {
				listener.run.apply(listener, listener_args); // and run 'em
			}
		});
	};

	/**
	 * Remove all of the states and transitions of this FSM. Useful for cleaning up memory
	 *
	 * @method destroy
	 */
	proto.destroy = function() {
		this.state.destroy();
		this._states = {};
		each(this._transitions, function(t) { t.destroy(); });
		this._transitions = [];
		this._curr_state = null;
	};

	/**
	 * Specify which state this FSM should begin at.
	 *
	 * @method startsAt
	 * @param {string} state_name - The name of the state to start at
	 * @return {FSM} - `this`
	 * @example
	 *
	 *     var my_fsm = cjs.fsm("state_a", "state_b");
	 *     my_fsm.startsAt("state_b");
	 */
	proto.startsAt = function(state_name) {
		var state = getStateWithName(this, state_name); // Get existing state
		if(!state) {
			// or create it if necessary
			state = this._states[state_name] = new State(this, state_name);
		}
		if(!this.did_transition) {
			// If no transitions have occurred, set the current state to the one they specified
			this._curr_state = state;
			this.state.invalidate();
		}
		this._chain_state = state;
		return this;
	};

	/**
	 * Check if the current state is `state_name`
	 *
	 * @method is
	 * @param {string} state_name - The name of the state to check against
	 * @return {boolean} - `true` if the name of the active state is `state_name`. `false` otherwise
	 * @example
	 *
	 *     var my_fsm = cjs.fsm("a", "b");
	 *     my_fsm.is("a"); // true, because a is the starting state
	 */
	proto.is = function(state_name) {
		// get the current state name & compare
		var state = this.getState();
		return state === null ? false : (state === (isString(state_name) ? state_name : state_name.getName()));
	};

	/**
	 * Call a given function when the finite-state machine enters a given state.
	 * `spec` can be of the form:
	 * - `'*'`: any state
	 * - `'state1'`: A state named `state1`
	 * - `'state1 -> state2'`: Immediately **after** state1 transitions to state2
	 * - `'state1 >- state2'`: Immediately **before** state1 transitions to state2
	 * - `'state1 <-> state2'`: Immediately **after** any transition between state1 and state2
	 * - `'state1 >-< state2'`: Immediately **before** any transition between state1 and state2
	 * - `'state1 <- state2'`: Immediately **after** state2 transitions 2 state1
	 * - `'state1 -< state2'`: Immediately **before** state2 transitions 2 state1
	 * - `'state1 -> *'`: Any transition from state1
	 * - `'* -> state2'`: Any transition to state2
	 *
	 * @method on
	 * @param {string} spec - A specification of which state to call the callback
	 * @param {function} callback - The function to be called
	 * @param {object} [context] - What `this` should evaluate to when `callback` is called
	 * @return {FSM} - `this`
	 *
	 * @see FSM.prototype.off
	 * @example
	 *
	 *     var x = cjs.fsm("a", "b");
	 *     x.on("a->b", function() {...});
	 */
	proto.on = proto.addEventListener = function(spec_str, callback, context) {
		var selector;
		if(isString(spec_str)) {
			selector = parse_spec(spec_str);
			if(selector === null) {
				throw new Error("Unrecognized format for state/transition spec.");
			}
		} else {
			selector = spec_str;
		}
		var listener = new StateListener(selector, callback, context);
		this._listeners.push(listener);
		return this;
	};

	/**
	 * Remove the listener specified by an on call; pass in just the callback
	 *
	 * @method off
	 * @param {function} callback - The function to remove as a callback
	 * @return {FSM} - `this`
	 *
	 * @see FSM.prototype.on
	 */
	proto.off = proto.removeEventListener = function(listener_callback) {
		this._listeners = filter(this._listeners, function(listener) {
			return listener.callback !== listener_callback;
		});
		return this;
	};
}(FSM));
/** @lends */

extend(cjs, {
	/** @expose cjs.FSM */
	FSM: FSM,
	/**
	 * Create an FSM
	 * @method cjs.fsm
	 * @constructs FSM
	 * @param {string} ...state_names - An initial set of state names to add to the FSM
	 * @return {FSM} - A new FSM
	 * @see FSM
	 * @example Creating a state machine with two states
	 *
	 *     var my_state = cjs.fsm("state1", "state2");
	 */
	fsm: function() { return new FSM(arguments); },
	/**
	 * Determine whether an object is an FSM
	 * @method cjs.isFSM
	 * @param {*} obj - An object to check
	 * @return {boolean} - `true` if `obj` is an `FSM`, `false` otherwise
	 */
	isFSM: function(obj) { return obj instanceof FSM; }
});

var CJSEvent = function(parent, filter, onAddTransition, onRemoveTransition) {
	this._listeners = []; // parent events that want to know when I fire
	this._transitions = []; // a list of transitions that I'm attached to
	this._on_add_transition = onAddTransition; // optional listener for when a transition is added
	this._on_remove_transition = onRemoveTransition; // optional listener for when a transition is removed
	this._live_fns = {}; // one per transitions
	this._parent = parent;
	if(this._parent) {
		this._parent._listeners.push({event:this, filter: filter}); // add an item to my parent's listener if i have a parent
	}
};

(function(my) {
	/** @lends cjs.CJSEvent.prototype */
	var proto = my.prototype;

	/**
	 * Create a transition that calls filter whenever it fires to ensure that it should fire
	 *
	 * @method guard
	 * @param {function} [filter] - Returns `true` if the event should fire and false otherwise
	 * @return {CJSEvent} A new event that only fires when `filter` returns a truthy value
	 * @example If the user clicks and `ready` is `true`
	 *
	 *     cjs.on("click").guard(function() {
	 *         return ready === true;
	 *     });
	 */
	proto.guard = function(filter, filter_eq) {
		//Assume filter is the name of a paroperty
		if(!isFunction(filter)) {
			var prop_name = filter;
			filter = function(event) {
				return event && event[prop_name] === filter_eq;
			};
		}
		return new CJSEvent(this, filter);
	};

	/**
	 * Add a transition to my list of transitions that this event is attached to
	 *
	 * @private
	 * @method _addTransition
	 * @param {Transition} transition - The transition this event is attached to
	 */
	proto._addTransition = function(transition) {
		this._transitions.push(transition);
		if(this._on_add_transition) {
			this._live_fns[transition.id()] = this._on_add_transition(transition);
		}
		if(this._parent && this._parent._on_add_transition) {
			this._parent._on_add_transition(transition);
		}
	};

	/**
	 * Remove a transition from my list of transitions
	 *
	 * @private
	 * @method _removeTransition
	 * @param {Transition} transition - The transition this event is attached to
	 */
	proto._removeTransition = function(transition) {
		if(remove(this._transitions, transition)) {
			if(this._on_remove_transition) {
				this._on_remove_transition(transition);

				// clear the live fn
				var tid = transition.id();
				this._live_fns[tid].destroy();
				delete this._live_fns[tid];
			}
		}
		if(this._parent && this._parent._on_remove_transition) {
			this._parent._on_remove_transition(transition);
		}
	};

	/**
	 * When I fire, go through every transition I'm attached to and fire it then let any interested listeners know as well
	 *
	 * @private
	 * @method _fire
	 * @param {*} ...events - Any number of events that will be passed to the transition
	 */
	proto._fire = function() {
		var events = arguments;
		each(this._transitions, function(transition) {
			transition.run.apply(transition, events);
		});
		each(this._listeners, function(listener_info) {
			var listener = listener_info.event,
				filter = listener_info.filter;

			if(!filter || filter.apply(root, events)) {
				listener._fire.apply(listener, events);
			}
		});
	};
}(CJSEvent));
/** @lends */

var isElementOrWindow = function(elem) { return elem === root || isPolyDOM(elem); },
	split_and_trim = function(x) { return map(x.split(" "), trim); },
	timeout_event_type = "timeout";

extend(cjs, {
	/** @expose cjs.CJSEvent */
	CJSEvent: CJSEvent,
	/**
	 * Create a new event for use in a finite state machine transition
	 *
	 * @constructs CJSEvent
	 * @method cjs.on
	 * @param {string} event_type - the type of event to listen for (e.g. mousedown, timeout)
	 * @param {element|number} ...targets=window - Any number of target objects to listen to
	 * @return {CJSEvent} - An event that can be attached to 
	 * @example When the window resizes
	 *
	 *     cjs.on("resize")
	 *
	 * @example When the user clicks `elem1` or `elem2`
	 *
	 *     cjs.on("click", elem1, elem2)
	 *
	 * @example After 3 seconds
	 *
	 *     cjs.on("timeout", 3000)
	 */
	on:	function(event_type) {
			var rest_args = arguments.length > 1 ? rest(arguments) : root,
				// no parent, no filter by default
				event = new CJSEvent(false, false, function(transition) {
					var targets = [],
						timeout_id = false,
						event_type_val = [],
						listener = bind(this._fire, this),
						fsm = transition.getFSM(),
						from = transition.getFrom(),
						state_selector = new StateSelector(from),
						from_state_selector = new TransitionSelector(true, state_selector, new AnyStateSelector()),
						on_listener = function() {
							each(event_type_val, function(event_type) {
								// If the event is 'timeout'
								if(event_type === timeout_event_type) {
									// clear the previous timeout
									if(timeout_id) {
										cTO(timeout_id);
										timeout_id = false;
									}

									// and set a new one
									var delay = cjs.get(rest_args[0]);
									if(!isNumber(delay) || delay < 0) {
										delay = 0;
									}

									timeout_id = sTO(listener, delay);
								} else {
									each(targets, function(target) {
										// otherwise, add the event listener to every one of my targets
										aEL(target, event_type, listener);
									});
								}
							});
						},
						off_listener = function() {
							each(event_type_val, function(event_type) {
								each(targets, function(target) {
									if(event_type === timeout_event_type) {
										// If the event is 'timeout'
										if(timeout_id) {
											cTO(timeout_id);
											timeout_id = false;
										}
									} else {
										rEL(target, event_type, listener);
									}
								});
							});
						},
						live_fn = cjs.liven(function() {
							off_listener();

							event_type_val = split_and_trim(cjs.get(event_type));
							// only use DOM elements (or the window) as my target
							targets = flatten(map(filter(get_dom_array(rest_args), isElementOrWindow), getDOMChildren , true));

							// when entering the state, add the event listeners, then remove them when leaving the state
							fsm	.on(state_selector, on_listener)
								.on(from_state_selector, off_listener);

							if(fsm.is(from)) {
								// if the FSM is already in the transition's starting state
								on_listener();
							}
						});
					return live_fn;
				});
			return event;
		}
});

// Based on [Mu's parser](https://github.com/raycmorgan/Mu) and
// John Resig's [HTML parser](http://erik.eae.net/simplehtmlparser/simplehtmlparser.js)
var makeMap = function(str){
	var obj = {};
	each(str.split(","), function(item) { obj[item] = true; });
	return obj;
};

// Regular Expressions for parsing tags and attributes
var startTag = /^<([\-A-Za-z0-9_]+)((?:\s+[a-zA-Z0-9_\-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|(?:[^>\s]+)))?)*)\s*(\/?)>/,
	endTag = /^<\/([\-A-Za-z0-9_]+)[^>]*>/,
	handlebar = /^\{\{([#=!>|{\/])?\s*((?:(?:"[^"]*")|(?:'[^']*')|[^\}])*)\s*(\/?)\}?\}\}/,
	attr = /([\-A-Za-z0-9_]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^\/>\s]+)))?/g,
	//hb_attr = /\{\{([^\}]*)\}\}/g,
	HB_TYPE = "hb",
	HTML_TYPE = "html";
	
// Empty Elements - HTML 4.01
var empty = makeMap("area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed"),
// Block Elements - HTML 4.01
	block = makeMap("address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul"),
// Inline Elements - HTML 4.01
	inline = makeMap("a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var"),
// Elements that you can, intentionally, leave open (and which close themselves)
	closeSelf = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr"),
// Attributes that have their values filled in disabled="disabled"
	fillAttrs = makeMap("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected"),
// Special Elements (can contain anything)
	special = makeMap("script,style");

var IF_TAG    = "if",
	ELIF_TAG  = "elif",
	ELSE_TAG  = "else",
	STATE_TAG = "state",
	EACH_TAG  = "each",
	WITH_TAG  = "with",
	FSM_TAG   = "fsm",
	UNLESS_TAG= "unless";

// Dictates what parents children must have; state must be a direct descendent of diagram
var parent_rules = {};
parent_rules[STATE_TAG] = { parent: [FSM_TAG] };
parent_rules[ELIF_TAG] = { parent: [IF_TAG] };
parent_rules[ELSE_TAG] = { parent: [IF_TAG, EACH_TAG] };

var autoclose_nodes = {};
autoclose_nodes[ELIF_TAG] =  { when_open_sibling: [ELIF_TAG, ELSE_TAG] };
autoclose_nodes[ELSE_TAG] =  {
	when_close_parent: [IF_TAG, EACH_TAG],
	when_open_sibling: []
};
autoclose_nodes[STATE_TAG] = { when_open_sibling: [STATE_TAG] };

// elsif and else must come after either if or elsif
var sibling_rules = {};
sibling_rules[ELIF_TAG] = {
	follows: [ELIF_TAG], //what it may follow
	or_parent: [IF_TAG] //or the parent can be 'if'
};
sibling_rules[ELSE_TAG] = {
	follows: [ELIF_TAG],
	or_parent: [IF_TAG, EACH_TAG]
};
sibling_rules[STATE_TAG] = {
	follows: [STATE_TAG],
	or_parent: [FSM_TAG]
};

var parseTemplate = function(input_str, handler) {
	var html_index, hb_index, last_closed_hb_tag, index, chars, match, stack = [], last = input_str;
	stack.last = function() {
		return this[this.length - 1];
	};

	var replace_fn = function(all, text) {
		text = text	.replace(/<!--(.*?)-->/g, "$1")
					.replace(/<!\[CDATA\[(.*?)\]\]>/g, "$1");

		if (handler.chars) {
			handler.chars(text);
		}

		return "";
	};

	while (input_str) {
		chars = true;

		// Make sure we're not in a script or style element
		if (!stack.last() || !special[stack.last()]) {
			// Comment
			if (input_str.indexOf("<!--") === 0) {
				index = input_str.indexOf("-->");

				if (index >= 0) {
					if (handler.HTMLcomment) {
						handler.HTMLcomment( input_str.substring( 4, index ) );
					}
					input_str = input_str.substring( index + 3 );
					chars = false;
				}

			// end tag
			} else if (input_str.indexOf("</") === 0) {
				match = input_str.match(endTag);

				if (match) {
					input_str = input_str.substring(match[0].length);
					match[0].replace(endTag, parseEndTag);
					chars = false;
				}

			// start tag
			} else if(input_str.indexOf("<") === 0) {
				match = input_str.match(startTag);

				if (match) {
					input_str = input_str.substring(match[0].length);
					match[0].replace(startTag, parseStartTag);
					chars = false;
				}
			} else if(input_str.indexOf("{{") === 0) {
				match = input_str.match(handlebar);
				if(match) {
					input_str = input_str.substring(match[0].length);
					match[0].replace(handlebar, parseHandlebar);
					chars = false;
				}
			}

			if(chars) {
				html_index = input_str.indexOf("<");
				hb_index = input_str.indexOf("{{");

				if(html_index < 0) { index = hb_index; }
				else if(hb_index < 0) { index = html_index; }
				else { index = Math.min(html_index, hb_index); }
				
				var text = index < 0 ? input_str : input_str.substring(0, index);
				input_str = index < 0 ? "" : input_str.substring(index);
				
				handler.chars(text);
			}
		} else {
			input_str = input_str.replace(new RegExp("(.*)<\/" + stack.last() + "[^>]*>"), replace_fn);

			parseEndTag("", stack.last());
		}

		if (input_str == last) {
			throw new Error("Parse Error: " + input_str);
		}
		last = input_str;
	}
	
	// Clean up any remaining tags
	parseEndTag();

	function parseStartTag( tag, tagName, rest, unary ) {
		tagName = tagName.toLowerCase();

		if ( block[ tagName ] ) {
			while ( stack.last() && inline[ stack.last() ] ) {
				parseEndTag( "", stack.last() );
			}
		}

		if ( closeSelf[ tagName ] && stack.last() == tagName ) {
			parseEndTag( "", tagName );
		}

		unary = empty[ tagName ] || !!unary;

		if ( !unary ) {
			stack.push({type: HTML_TYPE, tag: tagName});
		}
		
		if (handler.startHTML) {
			var attrs = [];

			rest.replace(attr, function(match, name) {
				var value = arguments[2] ? arguments[2] :
					arguments[3] ? arguments[3] :
					arguments[4] ? arguments[4] :
					fillAttrs[name] ? name : "";
				
				attrs.push({
					name: name,
					value: value,
					escaped: value.replace(/(^|[^\\])"/g, '$1\\\"') //"
				});
			});

			handler.startHTML(tagName, attrs, unary);
		}
	}

	function parseEndTag(tag, tagName) {
		popStackUntilTag(tagName, HTML_TYPE);
	}
	function getLatestHandlebarParent() {
		var i, stack_i;
		for(i = stack.length - 1; i>= 0; i--) {
			stack_i = stack[i];
			if(stack_i.type === HB_TYPE) {
				return stack_i;
			}
		}
		return undefined;
	}
	function parseHandlebar(tag, prefix, content) {
		var last_stack, tagName, parsed_content = jsep(content);

		if(parsed_content.type === COMPOUND) {
			if(parsed_content.body.length > 0 && parsed_content.body[0].type === IDENTIFIER) {
				tagName = parsed_content.body[0].name;
			}
		} else {
			if(parsed_content.type === IDENTIFIER) {
				tagName = parsed_content.name;
			}
		}

		switch (prefix) {
			case '{': // literal
				handler.startHB(tagName, parsed_content, true, true);
				break;
			case '>': // partial
				handler.partialHB(tagName, parsed_content);
				break;
			case '#': // start block
				last_stack = getLatestHandlebarParent();

				if(last_stack && has(autoclose_nodes, last_stack.tag)) {
					var autoclose_node = autoclose_nodes[last_stack.tag];
					if(indexOf(autoclose_node.when_open_sibling, tagName) >= 0) {
						popStackUntilTag(last_stack.tag, HB_TYPE);
						last_stack = getLatestHandlebarParent();
					}
				}

				if(has(parent_rules, tagName)) {
					var parent_rule = parent_rules[tagName];
					if(!last_stack || indexOf(parent_rule.parent, last_stack.tag)<0) {
						throw new Error("'" + tagName + "' must be inside of a '"+parent_rule.parent+"' block");
					}
				}

				if(has(sibling_rules, tagName)) {
					var sibling_rule = sibling_rules[tagName];
					if(indexOf(sibling_rule.follows, last_closed_hb_tag) < 0) {
						if(!sibling_rule.or_parent || indexOf(sibling_rule.or_parent, last_stack.tag) < 0) {
							var error_message = "'" + tagName + "' must follow a '" + sibling_rule.follows[0] + "'";
							if(sibling_rule.or_parent) {
								error_message += " or be inside of a '" + sibling_rule.or_parent[0] + "' tag";
							}
							throw new Error(error_message);
						}
					}
				}

				stack.push({type: HB_TYPE, tag: tagName});
				handler.startHB(tagName, parsed_content, false);
				break;

			case '/': // end block
				popStackUntilTag(tagName, HB_TYPE);
				break;
			case '!': // end block
				break;
			default: // unary
				handler.startHB(tagName, parsed_content, true, false);
				break;
		}
	}
	function popStackUntilTag(tagName, type) {
		var i, pos, stack_i;
		for (pos = stack.length - 1; pos >= 0; pos -= 1) {
			if(stack[pos].type === type && stack[pos].tag === tagName) {
				break;
			}
		}
		
		if (pos >= 0) {
			// Close all the open elements, up the stack
			for (i = stack.length - 1; i >= pos; i-- ) {
				stack_i = stack[i];
				if(stack_i.type === HB_TYPE) {
					if (handler.endHB) {
						handler.endHB(stack_i.tag);
					}
				} else {
					if (handler.endHTML) {
						handler.endHTML(stack_i.tag);
					}
				}
			}
			
			// Remove the open elements from the stack
			stack.length = pos;
		}

		if(type === HB_TYPE) {
			last_closed_hb_tag = tagName;
		}
	}
},
create_template = function(template_str) {
	var root = {
		children: [],
		type: ROOT_TYPE
	}, stack = [root],
	last_pop = false, has_container = false, fsm_stack = [], condition_stack = [];

	parseTemplate(template_str, {
		startHTML: function(tag, attributes, unary) {
			last_pop = {
				type: HTML_TYPE,
				tag: tag,
				attributes: attributes,
				unary: unary,
				children: []
			};

			last(stack).children.push(last_pop);

			if(!unary) {
				stack.push(last_pop);
			}
		},
		endHTML: function(tag) {
			last_pop = stack.pop();
		},
		HTMLcomment: function(str) {
			last_pop = {
				type: COMMENT_TYPE,
				str: str
			};
			last(stack).children.push(last_pop);
		},
		chars: function(str) {
			last_pop = {
				type: CHARS_TYPE,
				str: str
			};
			last(stack).children.push(last_pop);
		},
		startHB: function(tag, parsed_content, unary, literal) {
			if(unary) {
				last_pop = {
					type: UNARY_HB_TYPE,
					obj: first_body(parsed_content),
					literal: literal,
					//options: body_event_options(parsed_content),
					tag: tag
				};

				last(stack).children.push(last_pop);
			} else {
				var push_onto_children = true;

				last_pop = {
					type: HB_TYPE,
					tag: tag,
					children: []
				};
				switch(tag) {
					case EACH_TAG:
						last_pop.parsed_content = rest_body(parsed_content);
						last_pop.else_child = false;
						break;
					case UNLESS_TAG:
					case IF_TAG:
						last_pop.reverse = tag === UNLESS_TAG;
						last_pop.sub_conditions = [];
						last_pop.condition = rest_body(parsed_content);
						condition_stack.push(last_pop);
						break;
					case ELIF_TAG:
					case ELSE_TAG:
						var last_stack = last(stack);
						if(last_stack.type === HB_TYPE && last_stack.tag === EACH_TAG) {
							last_stack.else_child = last_pop;
						} else {
							last(condition_stack).sub_conditions.push(last_pop);
						}
						last_pop.condition = tag === ELSE_TAG ? ELSE_COND : rest_body(parsed_content);
						push_onto_children = false;
						break;
					case EACH_TAG:
					case FSM_TAG:
						last_pop.fsm_target = rest_body(parsed_content);
						last_pop.sub_states = {};
						fsm_stack.push(last_pop);
						break;
					case STATE_TAG:
						var state_name = parsed_content.body[1].name;
						last(fsm_stack).sub_states[state_name] = last_pop;
						push_onto_children = false;
						break;
					case WITH_TAG:
						last_pop.content = rest_body(parsed_content);
						break;
				}
				if(push_onto_children) {
					last(stack).children.push(last_pop);
				}
				stack.push(last_pop);
			}
		},
		endHB: function(tag) {
			switch(tag) {
				case IF_TAG:
				case UNLESS_TAG:
					condition_stack.pop();
					break;
				case FSM_TAG:
					fsm_stack.pop();
			}
			stack.pop();
		},
		partialHB: function(tagName, parsed_content) {
			last_pop = {
				type: PARTIAL_HB_TYPE,
				tag: tagName,
				content: rest_body(parsed_content)
			};

			last(stack).children.push(last_pop);
		}
	});
	return root;
};

var child_is_dynamic_html		= function(child)	{ return child.type === UNARY_HB_TYPE && child.literal; },
	child_is_text				= function(child)	{ return child.isText; },
	every_child_is_text			= function(arr)		{ return every(arr, child_is_text); },
	any_child_is_dynamic_html	= function(arr)		{ return any(arr, child_is_dynamic_html); },
	PARTIAL_HB_TYPE = "partial_hb",
	UNARY_HB_TYPE = "unary_hb",
	CHARS_TYPE = "chars",
	ROOT_TYPE = "root",
	COMMENT_TYPE = "comment",

	TEMPLATE_INSTANCE_PROP = "data-cjs-template-instance",

	outerHTML = function (node){
		// if IE, Chrome take the internal method otherwise build one
		return node.outerHTML || (
			function(n){
				var div = document.createElement('div'), h;
				div.appendChild( n.cloneNode(true) );
				h = div.innerHTML;
				div = null;
				return h;
			})(node);
	},
	escapeHTML = function (unsafe) {
		return unsafe	.replace(/&/g, "&amp;").replace(/</g, "&lt;")
						.replace(/>/g, "&gt;") .replace(/"/g, "&quot;")
						.replace(/'/g, "&#039;");
	},
	compute_object_property = function(object, prop_node, context, lineage) {
		return object ? object[prop_node.computed ? get_node_value(prop_node, context, lineage) : prop_node.name] :
						undefined;
	},
	ELSE_COND = {},
	first_body = function(node) {
		return node.type === COMPOUND ? node.body[0] : node;
	},
	rest_body = function(node) {
		return {type: COMPOUND,
				body: node.type === COMPOUND ? rest(node.body) : [] };
	},
	get_instance_nodes = function(c) { return c.node || c.getNodes(); },
	get_node_value = function(node, context, lineage) {
		var op, object, call_context, args, val, name, i;
		if(!node) { return; }
		switch(node.type) {
			case THIS_EXP: return cjs.get(last(lineage).this_exp);
			case LITERAL: return node.value;
			case UNARY_EXP:
				op = unary_operators[node.operator];
				return op ? op(get_node_value(node.argument, context, lineage)) :
							undefined;
			case BINARY_EXP:
			case LOGICAL_EXP:
				op = binary_operators[node.operator];
				return op ? op(get_node_value(node.left, context, lineage), get_node_value(node.right, context, lineage)) :
							undefined;
			case IDENTIFIER:
				if(node.name.charAt(0) === "@") {
					name = node.name.slice(1);
					for(i = lineage.length-1; i>=0; i--) {
						object = lineage[i].at;
						if(object && has(object, name)) {
							val = object[name];
							break;
						}
					}
				} else {
					val = context[node.name];
				}

				return is_constraint(val) ? val.get() : val;
			case MEMBER_EXP:
				object = get_node_value(node.object, context, lineage);
				return compute_object_property(object, node.property, context, lineage);
			case COMPOUND:
				return get_node_value(node.body[0], context, lineage);
			case CURR_LEVEL_EXP:
				object = last(lineage).this_exp;
				return compute_object_property(object, node.argument, context, lineage);
			case PARENT_EXP:
				object = (lineage && lineage.length > 1) ? lineage[lineage.length - 2].this_exp : undefined;
				return compute_object_property(object, node.argument, context, lineage);
			case CONDITIONAL_EXP:
				return get_node_value(node.test, context, lineage) ? get_node_value(node.consequent, context, lineage) :
																get_node_value(node.alternate, context, lineage);
			case CALL_EXP:
				if(node.callee.type === MEMBER_EXP) {
					call_context = get_node_value(node.callee.object, context, lineage);
					object = compute_object_property(call_context, node.callee.property, context, lineage);
				} else {
					call_context = root;
					object = get_node_value(node.callee, context, lineage);
				}

				if(object && isFunction(object)) {
					args = map(node['arguments'], function(arg) {
						return get_node_value(arg, context, lineage);
					});
					return object.apply(call_context, args);
				}
		}
	},
	get_escaped_html = function(c) {
		if(c.nodeType === 3) {
			return escapeHTML(getTextContent(c));
		} else {
			return escapeHTML(outerHTML(c));
		}
	},
	get_concatenated_inner_html_constraint = function(children, context, lineage) {
		var args = arguments;
		return cjs(function() {
			return map(children, function(child) {
				if(child.type === UNARY_HB_TYPE) {
					if(child.literal) {
						return get_node_value(child.val, context, lineage);
					} else {
						return escapeHTML(get_node_value(child.val, context, lineage)+"");
					}
				} else {
					var child_val = get_instance_nodes(child);

					if(isArray(child_val)) {
						return map(child_val, get_escaped_html).join("");
					} else {
						return get_escaped_html(child_val);
					}
				}
			}).join("");
		});
	},
	get_concatenated_children_constraint = function(children, args) {
		return cjs(function() {
					var rv = [];
					each(children, function(child) {
						var c_plural = get_instance_nodes(child);
						if(isArray(c_plural)) {
							rv.push.apply(rv, c_plural);
						} else {
							rv.push(c_plural);
						}
					});
					return rv;
				});
	},
	hb_regex = /^\{\{([^\}]+)\}\}/,
	get_constraint = function(str, context, lineage) {
		var has_constraint = false,
			has_str = false,
			strs = [],
			index, match_val, len = 0, substr,
			last_val_is_str = false;

		while(str.length > 0) {
			index =  str.indexOf("{");

			if(index === 0) {
				match_val = str.match(hb_regex);
				if(match_val) {
					strs[len++] = cjs(bindArgs(get_node_value, jsep(match_val[1]), context, lineage));
					str = str.substr(match_val[0].length);

					last_val_is_str = false;
					has_constraint = true;
					continue;
				} else { // !match_val
					index++; // capture this '{' in index
				}
			}

			if(index < 0) {
				index = str.length;
			}

			substr = str.substr(0, index);
			str = str.substr(index);

			if(last_val_is_str) {
				strs[len-1] = strs[len-1] + substr;
			} else {
				strs[len++] = substr;
			}
			has_str = last_val_is_str = true;
		}

		if(has_constraint) {
			return (!has_str && strs.length===1) ? strs[0] :
					cjs(function() {
						return map(strs, function(str) {
							if(is_constraint(str)) {
								return str.get();
							} else if(is_array(str)) {
								return str.join(" ");
							} else {
								return "" + str;
							}
						}).join("");
					});
		} else {
			return strs.join("");
		}
	},
	array_this_eq = function(a, b) {
		return a.length === b.length && every(a, function(ai, i) { return ai.this_esp === b[i].this_esp; });
	},
	IS_OBJ = {},
	map_aware_array_eq = function(a, b) {
		return a === b || (a && a.is_obj === IS_OBJ && a.key === b.key && a.value === b.value);
	},
	name_regex = /^(data-)?cjs-out$/,
	on_regex = /^(data-)?cjs-on-(\w+)$/,
	call_each = function(arr, prop_name) {
		var args = rest(arguments, 2);
		each(arr, function(x) {
			if(has(x, prop_name)) {
				x[prop_name].apply(x, args);
			}
		});
	},
	pause_each    = function(arr) { call_each.apply(this, ([arr, "pause"]).concat(rest(arguments))); },
	resume_each   = function(arr) { call_each.apply(this, ([arr, "resume"]).concat(rest(arguments))); },
	destroy_each  = function(arr) { call_each.apply(this, ([arr, "destroy"]).concat(rest(arguments))); },
	onadd_each    = function(arr) { call_each.apply(this, ([arr, "onAdd"]).concat(rest(arguments))); },
	onremove_each = function(arr) { call_each.apply(this, ([arr, "onRemove"]).concat(rest(arguments))); },

	create_template_instance = function(template, context, lineage, parent_dom_node) {
		var type = template.type,
			instance_children,
			element,
			active_children;

		if(type === CHARS_TYPE) {
			return {type: type, node: doc.createTextNode(template.str) };
		} else if(type === ROOT_TYPE || type === HTML_TYPE) {
			var args = arguments,
				on_regex_match,
				bindings = [], binding;
			instance_children = map(template.children, function(child) {
				return create_template_instance(child, context, lineage);
			});

			if(type === ROOT_TYPE) {
				if(parent_dom_node) {
					element = parent_dom_node;
				} else if(instance_children.length === 1 && template.children[0].type === HTML_TYPE) {
					return instance_children[0];
				} else {
					element = doc.createElement("span");
				}
			} else {
				element = doc.createElement(template.tag);
			}

			each(template.attributes, function(attr) {
				var name = attr.name, value = attr.value;
				if(name.match(name_regex)) {
					bindings.push((context[value] = getInputValueConstraint(element)));
				} else if((on_regex_match = name.match(on_regex))) {
					var event_name = on_regex_match[2];
					aEL(element, event_name, bind(context[value], cjs.get(last(lineage).this_exp)));
				} else {
					var constraint = get_constraint(value, context, lineage);
					if(is_constraint(constraint)) {
						if(attr.name === "class") {
							var class_constraint = cjs(function() {
								var cval = constraint.get();
								return cval.split(" ");
							});
							bindings.push(constraint, class_constraint, class_binding(element, class_constraint));
						} else {
							bindings.push(constraint, attr_binding(element, name, constraint));
						}
					} else {
						element.setAttribute(attr.name, constraint);
					}
				}
			});

			if(any_child_is_dynamic_html(template.children)) { // this is where it starts to suck...every child's innerHTML has to be taken and concatenated
				var concatenated_html = get_concatenated_inner_html_constraint(instance_children, context, lineage);
				binding = html_binding(element, concatenated_html);
				bindings.push(concatenated_html, binding);
			} else {
				var children_constraint = get_concatenated_children_constraint(instance_children, args);
				binding	= children_binding(element, children_constraint);
				bindings.push(children_constraint, binding);
			}

			return {
				node: element,
				type: type,
				onAdd:   function() {
					resume_each(bindings);
					onadd_each(instance_children);
				},
				onRemove:  function() {
					pause_each(bindings);
					onremove_each(instance_children);
				},
				pause: function() {
					pause_each(instance_children.concat(bindings));
				},
				resume: function() {
					resume_each(instance_children.concat(bindings));
				},
				destroy: function() {
					destroy_each(instance_children.concat(bindings));
				}
			};
		} else if(type === UNARY_HB_TYPE) {
			var textNode, parsed_elem = template.obj,
				val_constraint = cjs(function() {
					return get_node_value(parsed_elem, context, lineage);
				}),
				node, txt_binding;
			if(!template.literal) {
				var curr_value = cjs.get(val_constraint);
				if(isPolyDOM(curr_value)) {
					node = getFirstDOMChild(curr_value);
				} else {
					node = doc.createTextNode(""+curr_value);
					txt_binding = text_binding(node, val_constraint);
				}
			}

			return {
				type: type,
				literal: template.literal,
				val: parsed_elem,
				node: node,
				destroy: function() {
					if(txt_binding) {
						txt_binding.destroy(true);
					}
					val_constraint.destroy(true);
				},
				pause: function() { if(txt_binding) txt_binding.pause(); },
				resume: function() { if(txt_binding) txt_binding.resume(); },
				onRemove: function() { this.pause(); },
				onAdd: function() { this.resume(); }
			};
		} else if (type === HB_TYPE) {
			var tag = template.tag;
			if(tag === EACH_TAG) {
				var old_arr_val = [], arr_val, lastLineages = [];
				active_children = [];
				return {
					type: type,
					onRemove: function() { each(active_children, onremove_each); },
					onAdd: function() { each(active_children, onadd_each); },
					pause: function() { each(active_children, pause_each); },
					resume: function() { each(active_children, resume_each); },
					destroy: function() {
						each(active_children, destroy_each);
						active_children = [];
					},
					getNodes: function() {
						arr_val = get_node_value(template.parsed_content, context, lineage);

						if(is_array(arr_val)) { // array constraint
							arr_val = arr_val.toArray();
						}

						if(!isArray(arr_val)) { 
							if(is_map(arr_val)) { // map constraint
								arr_val = arr_val.entries();
								each(arr_val, function(x) {
									x.is_obj = IS_OBJ;
								});
							} else {
								if(is_constraint(arr_val)) {
									arr_val = arr_val.get();
								}
								// IS_OBJ provides a way to ensure the user didn't happen to pass in a similarly formatted array
								arr_val = map(arr_val, function(v, k) { return { key: k, value: v, is_obj: IS_OBJ }; });
							}
						} else if(arr_val.length === 0 && template.else_child) {
							arr_val = [ELSE_COND];
						}

						var diff = get_array_diff(old_arr_val, arr_val, map_aware_array_eq),
							rv = [],
							added_nodes = [], removed_nodes = [];
						old_arr_val = arr_val;
						each(diff.index_changed, function(ic_info) {
							var lastLineageItem = lastLineages[ic_info.from];
							if(lastLineageItem && lastLineageItem.at && lastLineageItem.at.index) {
								lastLineageItem.at.index.set(ic_info.to);
							}
						});
						each(diff.removed, function(removed_info) {
							var index = removed_info.from,
								lastLineageItem = lastLineages[index];

							removed_nodes.push.apply(removed_nodes, active_children[index]);

							removeIndex(active_children, index);
							if(lastLineageItem && lastLineageItem.at) {
								each(lastLineageItem.at, function(v) { v.destroy(true); });
							}
						});
						each(diff.added, function(added_info) {
							var v = added_info.item,
								index = added_info.to,
								is_else = v === ELSE_COND,
								lastLineageItem = is_else ? false : ((v && v.is_obj === IS_OBJ) ? {this_exp: v.value , at: {key: cjs.constraint(v.key)}} :
																									{this_exp: v, at: {index: cjs.constraint(index)}}),
								concated_lineage = is_else ? lineage : lineage.concat(lastLineageItem),
								children = is_else ? template.else_child.children : template.children,
								child_nodes = map(children, function(child) {
									return create_template_instance(child, context, concated_lineage);
								});

							active_children.splice(index, 0, child_nodes);
							lastLineages.splice(index, 0, lastLineageItem);

							added_nodes.push.apply(added_nodes, child_nodes);
						}, this);
						each(diff.moved, function(moved_info) {
							var from_index = moved_info.from_index,
								to_index = moved_info.to_index,
								dom_elem = mdom[from_index],
								child_nodes = active_children[from_index],
								lastLineageItem = lastLineages[from_index];

							removeIndex(active_children, from_index);
							active_children.splice(to_index, 0, child_nodes);

							removeIndex(lastLineages, from_index);
							lastLineages.splice(to_index, 0, lastLineageItem);
						});

						onremove_each(removed_nodes);
						destroy_each(removed_nodes);
						onadd_each(added_nodes);

						var child_vals = map(active_children, function(child_nodes) {
							var instance_nodes = flatten(map(child_nodes, function(child_node) {
								return get_instance_nodes(child_node);
							}), true);
							return instance_nodes;
						});
						return flatten(child_vals, true);
					}
				};
			} else if(tag === IF_TAG || tag === UNLESS_TAG) {
				instance_children = [];
				active_children = [];
				var old_index = -1;
				return {
					type: type,
					onRemove: function() { onremove_each(active_children); },
					onAdd: function() { onadd_each(active_children); },
					pause: function() { pause_each(active_children); },
					resume: function() { resume_each(active_children); },
					destroy: function() {
						if(old_index >= 0) {
							active_children=[];
							old_index=-1;
						}
						each(instance_children, destroy_each);
					},
					getNodes: function() {
						var len = template.sub_conditions.length,
							cond = !!cjs.get(get_node_value(template.condition, context, lineage)),
							i, children = false, memo_index, rv;

						if(template.reverse) {
							cond = !cond;
						}

						if(cond) {
							i = 0; children = template.children;
						} else if(len > 0) {
							for(i = 0; i<len; i++) {
								cond = template.sub_conditions[i];

								if(cond.condition === ELSE_COND || get_node_value(cond.condition, context, lineage)) {
									children = cond.children;
									i++;
									break;
								}
							}
						}

						if(old_index !== i) { onremove_each(active_children); }

						if(!children) {
							rv = active_children = [];
						} else {
							if(instance_children[i]) {
								active_children = instance_children[i];
							} else {
								children = i===0 ? template.children : template.sub_conditions[i-1].children;
								active_children = instance_children[i] = map(children, function(child) {
									return create_template_instance(child, context, lineage);
								});
							}
							
							rv = flatten(map(active_children, get_instance_nodes), true);
						}

						if(old_index !== i) { onadd_each(active_children); }

						old_index = i;

						return rv;
					}
				};
			} else if(tag === FSM_TAG) {
				var memoized_children = {},
					old_state = false;
				active_children = [];
				return {
					pause: function() { pause_each(active_children); },
					resume: function() { resume_each(active_children); },
					destroy: function() {
						if(old_state) {
							destroy_each(active_children);
							active_children = [];
							old_state = false;
						}
					},
					onRemove: function() { this.pause(); },
					onAdd: function() { this.resume(); },
					type: type,
					getNodes: function() {
						var fsm = get_node_value(template.fsm_target, context, lineage),
							state = fsm.getState(),
							do_child_create = function(child) {
								return create_template_instance(child, context, lineage);
							}, state_name,
							rv = [];

						if(old_state !== state) {
							onremove_each(active_children);
						}

						for(state_name in template.sub_states) {
							if(template.sub_states.hasOwnProperty(state_name)) {
								if(state === state_name) {
									if(!has(memoized_children, state_name)) {
										memoized_children[state_name] = map(template.sub_states[state_name].children, do_child_create);
									}
									active_children = memoized_children[state_name];
									rv = flatten(map(active_children, get_instance_nodes), true);
									break;
								}
							}
						}

						if(old_state !== state) {
							onadd_each(active_children);
						}
						old_state = state;

						return rv;
					}
				};
			} else if(tag === WITH_TAG) {
				var new_context = get_node_value(template.content, context, lineage),
					new_lineage = lineage.concat({this_exp: new_context});

				instance_children = flatten(map(template.children, function(child) {
					return create_template_instance(child, new_context, new_lineage);
				}));
				return {
					pause: function() { pause_each(instance_children); },
					resume: function() { resume_each(instance_children); },
					onRemove: function() { onremove_each(instance_children); },
					onAdd: function() { onadd_each(instance_children); },
					destroy: function() { destroy_each(instance_children); },
					node: flatten(map(instance_children, get_instance_nodes), true)
				};
			}
		} else if (type === PARTIAL_HB_TYPE) {
			var partial, dom_node, instance,
				parsed_content = template.content,
				get_context = function() {
					return parsed_content.type === COMPOUND ?
										map(parsed_content.body, function(x) {
											return get_node_value(x, context, lineage);
										}) : [get_node_value(template.content, context, lineage)];
				},
				is_custom = false;

			if(has(partials, template.tag)) {
				partial = partials[template.tag];
				dom_node = partial.apply(root, get_context());
				instance = get_template_instance(dom_node);
			} else if(has(custom_partials, template.tag)) {
				partial = custom_partials[template.tag];
				instance = partial.apply(root, get_context());
				dom_node = instance.node;
				is_custom = true;
			} else {
				throw new Error("Could not find partial with name '"+template.tag+"'");
			}

			return {
				node: dom_node,
				pause: function() { if(instance) instance.pause(dom_node); },
				destroy: function() {
					if(is_custom) {
						instance.destroy(dom_node);
					} else {
						cjs.destroyTemplate(dom_node);
					}
				},
				onAdd: function() {
					if(instance) {
						instance.onAdd.apply(instance, ([dom_node]).concat(get_context()));
					}
				},
				onRemove: function() { if(instance) instance.onRemove(dom_node); },
				resume: function() { if(instance) instance.resume(dom_node); }
			};
		} else if (type === COMMENT_TYPE) {
			return {
				node: doc.createComment(template.str)
			};
		}
		return {node: [] };
	},
	partials = {},
	custom_partials = {},
	isPolyDOM = function(x) {
		return is_jquery_obj(x) || isNList(x) || isAnyElement(x);
	},
	getFirstDOMChild = function(x) {
		if(is_jquery_obj(x) || isNList(x))	{ return x[0]; }
		else if(isAnyElement(x))			{ return x; }
		else								{ return false; }
	},
	getDOMChildren = function(x) {
		if(is_jquery_obj(x) || isNList(x))	{ return toArray(x); }
		else								{ return x; }
	},
	template_instance_nodes = [],
	template_instances = [],
	instance_id = 1,
	memoize_template = function(context, parent_dom_node) {
		var template = this,
			instance = create_template_instance(template, context, [{this_exp: context}], getFirstDOMChild(parent_dom_node)),
			node = instance.node,
			id = (instance.id = instance_id++);

		template_instances[id] = instance;
		template_instance_nodes[id] = node;
		node.setAttribute(TEMPLATE_INSTANCE_PROP, id);

		return node;
	},
	get_template_instance_index = function(dom_node) {
		var instance_id = dom_node.getAttribute(TEMPLATE_INSTANCE_PROP);
		if(!instance_id) {
			instance_id = indexOf(template_instance_nodes, dom_node);
		}
		return instance_id;
	},
	get_template_instance = function(dom_node) {
		var nodeIndex = get_template_instance_index(dom_node);
		return nodeIndex >= 0 ? template_instances[nodeIndex] : false;
	};

extend(cjs, {
	/**
	 * Create a new template. If `context` is specified, then this function returns a DOM node with the specified template.
	 * Otherwise, it returns a function that can be called with `context` and `[parent]` to create a new template.
	 *
	 * ConstraintJS templates use a (Handlebars)[http://handlebarsjs.com/]. A template can be created with
	 * `cjs.createTemplate`. The format is described below.
	 * 
	 * ## Basics
	 * ConstraintJS templates take standard HTML and add some features
	 *
	 * ### Constraints
	 * Unary handlebars can contain expressions.
	 *
	 *      <h1>{{title}}</h1>
	 *      <p>{{subtext.toUpperCase()+"!"}}</p>
	 *
	 * called with `{ title: cjs('hello'), subtext: 'world'}`:
	 *
	 *     <h1>hello</h1>
	 *     <p>WORLD!</p>
	 *
	 * ### Literals
	 * If the tags in a node should be treated as HTML, use triple braces: `{{{ literal_val }}}`.
	 * These literals (triple braces) should be created immediately under a DOM node.
	 *
	 *      <h1>{{title}}</h1>
	 *      <p>{{{subtext}}}</p>
	 *
	 * called with `{ title: cjs('hello'), subtext: '<strong>steel</strong city'}`:
	 *
	 *     <h1>hello</h1>
	 *     <p><strong>steel</strong> city</p>
	 *
	 *
	 * ## Comments
	 *
	 *     {{! comments will be ignored in the output}}
	 *
	 * ## Constraint output
	 *
	 * To call `my_func` on event `(event-name)`, give any targets the attribute:
	 *
	 *     data-cjs-on-(event-name)=my_func
	 * 
	 * For example:
	 *
	 *     <div data-cjs-on-click=update_obj />
	 * 
	 * Will call `update_obj` (a property of the template's context when this div is clicked.
	 *
	 * To add the value of an input element to the template's context, use the property `data-cjs-out`:
	 *
	 *     <input data-cjs-out=user_name />
	 *     <h1>Hello, {{user_name}}</h1>
	 *
	 * ## Block Helpers
	 *
	 * ### Loops
	 *
	 * To create an object for every item in an array or object, you can use the `{{#each}}` block helper.
	 * `{{this}}` refers to the current item and `@key` and `@index` refer to the keys for arrays and objects
	 * respectively.
	 *
	 *     {{#each obj_name}}
	 *         {{@key}}: {{this}}
	 *     {{/each}}
	 *
	 *     {{#each arr_name}}
	 *         {{@index}}: {{this}}
	 *     {{/each}}
	 *
	 * If the length of the array is zero (or the object has no keys) then an `{{#else}}` block can be used: 
	 *     
	 *     {{#each arr_name}}
	 *         {{@index}}: {{this}
	 *         {{#else}}
	 *             <strong>No items!</strong>
	 *     {{/each}}
	 *
	 * ### Conditions
	 * The `{{#if}}` block helper can vary the content of a template depending on some condition.
	 * This block helper can have any number of sub-conditions with the related `{{#elif}}` and `{{#else}}` tags.
	 *
	 *     {{#if cond1}}
	 *         Cond content
	 *     {{#elif other_cond}}
	 *         other_cond content
	 *     {{#else}}
	 *         else content
	 *     {{/if}}
	 *
	 * The opposite of an `{{#if}}` block is `{{#unless}}`:
	 *     {{#unless logged_in}}
	 *         Not logged in!
	 *     {{/unless}
	 *
	 * ### State
	 *
	 * The `{{#fsm}}` block helper can vary the content of a template depending on an FSM state
	 *
	 *     {{#fsm my_fsm}}
	 *         {{#state1}}
	 *             State1 content
	 *         {{#state2}}
	 *             State2 content
	 *         {{#state3}}
	 *             State3 content
	 *     {{/fsm}}
	 *
	 * ### With helper
	 *
	 * The `{{#with}}` block helper changes the context in which constraints are evaluated.
	 *
	 *     {{#with obj}}
	 *         Value: {{x}}
	 *     {{/with}}
	 *
	 * when called with `{ obj: {x: 1} }` results in `Value: 1`
	 *
	 * ## Partials
	 *
	 * Partials allow templates to be nested.
	 *
	 *     var my_temp = cjs.createTemplate(...);
	 *     cjs.registerPartial('my_template', my_temp);
	 * Then, in any other template,
	 *
	 *     {{>my_template context}}
	 * 
	 * Nests a copy of `my_template` in `context`
	 *
	 * @method cjs.createTemplate
	 * @param {string|dom} template - the template as either a string or a `script` tag whose contents are the template
	 * @param {object} [context] - Any number of target objects to listen to
	 * @param {dom} [parent] - The parent DOM node for the template
	 * @return {function|dom} - An event that can be attached to 
	 *
	 * @see cjs.destroyTemplate
	 * @see cjs.pauseTemplate
	 * @see cjs.resumeTemplate
	 *
	 * @example
	 *
	 *     <script id='my_template' type='cjs/template'>
	 *         {{x}}
	 *     </script>
	 *     var template_elem = document.getElementById('my_template');
	 *     var template = cjs.createTemplate(template_elem);
	 *     var element1 = template({x: 1});
	 *     var element2 = template({x: 2});
	 *
	 * @example
	 *
	 *     var element = cjs.createTemplate("{{x}}", {x: 1});
	 */
	createTemplate:		function(template_str) {
							if(!isString(template_str)) {
								if(is_jquery_obj(template_str) || isNList(template_str)) {
									template_str = template_str.length > 0 ? trim(getTextContent(template_str[0])) : "";
								} else if(isElement(template_str)) {
									template_str = trim(getTextContent(template_str));
								} else {
									template_str = "" + template_str;
								}
							}

							var template = create_template(template_str);

							if(arguments.length >= 2) { // Create and use the template immediately
								return memoize_template.apply(template, rest(arguments));
							} else { // create the template as a function that can be called with a context
								return bind(memoize_template, template);
							}
						},

	/**
	 * Register a *custom* partial that can be used in other templates
	 *
	 * Options are (only `createNode` is mandatory):
	 *  * `createNode(...)`: A function that returns a new dom node any time this partial is invoked (called with the arguments passed into the partial)
	 *  * `onAdd(dom_node)`: A function that is called when `dom_node` is added to the DOM tree
	 *  * `onRemove(dom_node)`: A function that is called when `dom_node` is removed from the DOM tree
	 *  * `pause(dom_node)`: A function that is called when the template has been paused (usually with `pauseTemplate`)
	 *  * `resume(dom_node)`: A function that is called when the template has been resumed (usually with `resumeTemplate`)
	 *  * `destroyNode(dom_node)`: A function that is called when the template has been destroyed (usually with `destroyTemplate`)
	 *
	 * @method cjs.registerCustomPartial
	 * @param {string} name - The name that this partial can be referred to as
	 * @param {Object} options - The set of options (described in the description)
	 * @return {cjs} - `cjs`
	 * @see cjs.registerPartial
	 * @see cjs.unregisterPartial
	 * @example Registering a custom partial named `my_custom_partial`
	 *
	 *     cjs.registerCustomPartial('my_custom_partial', {
	 *			createNode: function(context) {
	 *				return document.createElement('span');
	 *			},
	 *			destroyNode: function(dom_node) {
	 *				// something like: completely_destroy(dom_node);
	 *			}
	 *			onAdd: function(dom_node) {
	 *				// something like: do_init(dom_node);
	 *			},
	 *			onRemove: function(dom_node) {
	 *				// something like: cleanup(dom_node);
	 *			},
	 *			pause: function(dom_node) {
	 *				// something like: pause_bindings(dom_node);
	 *			},
	 *			resume: function(dom_node) {
	 *				// something like: resume_bindings(dom_node);
	 *			},
	 *     });
	 * Then, in any other template,
	 *
	 *     {{>my_template context}}
	 * 
	 * Nests a copy of `my_template` in `context`
	 */
	registerCustomPartial: function(name, options) {
		custom_partials[name] = function() {
			var node = getFirstDOMChild(options.createNode.apply(this, arguments));
			return {
				node: node,
				onAdd: function() { if(options.onAdd) { options.onAdd.apply(this, arguments); } },
				onRemove: function() { if(options.onRemove) { options.onRemove.apply(this, arguments); } },
				destroy: function() { if(options.destroyNode) { options.destroyNode.apply(this, arguments); } },
				pause: function() { if(options.pause) { options.pause.apply(this, arguments); } },
				resume: function() { if(options.resume) { options.resume.apply(this, arguments); } }
			};
		};
		return this;
	},

	/**
	 * Register a partial that can be used in other templates
	 *
	 * @method cjs.registerPartial
	 * @param {string} name - The name that this partial can be referred to as
	 * @param {Template} value - The template
	 * @return {cjs} - `cjs`
	 * @see cjs.unregisterPartial
	 * @see cjs.registerCustomPartial
	 * @example Registering a partial named `my_temp`
	 *
	 *     var my_temp = cjs.createTemplate(...);
	 *     cjs.registerPartial('my_template', my_temp);
	 * Then, in any other template,
	 *
	 *     {{>my_template context}}
	 * 
	 * Nests a copy of `my_template` in `context`
	 */
	registerPartial:	function(name, value) {
		partials[name] = value;
		return this;
	},

	/**
	 * Unregister a partial for other templates
	 *
	 * @method cjs.unregisterPartial
	 * @param {string} name - The name of the partial
	 * @return {cjs} - `cjs`
	 * @see cjs.registerPartial
	 * @see cjs.registerCustomPartial
	 */
	unregisterPartial:	function(name) {
		delete partials[name];
		delete custom_partials[name];
		return this;
	},

	/**
	 * Destroy a template instance
	 *
	 * @method cjs.destroyTemplate
	 * @param {dom} node - The dom node created by `createTemplate`
	 * @return {boolean} - Whether the template was successfully removed
	 * @see cjs.createTemplate
	 * @see cjs.pauseTemplate
	 * @see cjs.resumeTemplate
	 */
	destroyTemplate:	function(dom_node) {
							var index = get_template_instance_index(getFirstDOMChild(dom_node)),
								instance = index >= 0 ? template_instances[index] : false;

							if(instance) {
								delete template_instances[index];
								instance.destroy();
							}
							return this;
						},

	/**
	 * Pause dynamic updates to a template
	 *
	 * @method cjs.pauseTemplate
	 * @param {dom} node - The dom node created by `createTemplate`
	 * @return {boolean} - Whether the template was successfully paused
	 * @see cjs.resumeTemplate
	 * @see cjs.createTemplate
	 * @see cjs.destroyTemplate
	 */
	pauseTemplate:		function(dom_node) {
							var instance = get_template_instance(dom_node);
							if(instance) { instance.pause(); }
							return this;
						},

	/**
	 * Resume dynamic updates to a template
	 *
	 * @method cjs.resumeTemplate
	 * @param {dom} node - The dom node created by `createTemplate`
	 * @return {boolean} - Whether the template was successfully resumed
	 * @see cjs.pauseTemplate
	 * @see cjs.createTemplate
	 * @see cjs.destroyTemplate
	 */
	resumeTemplate:		function(dom_node) {
							var instance = get_template_instance(dom_node);
							if(instance) { instance.resume(); }
							return this;
						},

	/**
	 * Parses a string and returns a constraint whose value represents the result of `eval`ing
	 * that string
	 *
	 * @method cjs.createParsedConstraint
	 * @param {string} str - The string to parse
	 * @param {object} context - The context in which to look for variables
	 * @return {cjs.Cosntraint} - Whether the template was successfully resumed
	 * @example Creating a parsed constraint `x`
	 *
	 *     var a = cjs(1);
	 *     var x = cjs.createParsedConstraint("a+b", {a: a, b: cjs(2)})
	 *     x.get(); // 3
	 *     a.set(2);
	 *     x.get(); // 4
	 */
	createParsedConstraint: function(str, context) {
		var node = jsep(str);
		if(node.type === LITERAL) {
			return node.value;
		}

		return cjs(function() {
			return get_node_value(node, context, [context]);
		});
	}
});

// Node Types
// ----------

// This is the full set of types that any JSEP node can be.
// Store them here to save space when minified
var COMPOUND = 'Compound',
	IDENTIFIER = 'Identifier',
	MEMBER_EXP = 'MemberExpression',
	LITERAL = 'Literal',
	THIS_EXP = 'ThisExpression',
	CALL_EXP = 'CallExpression',
	UNARY_EXP = 'UnaryExpression',
	BINARY_EXP = 'BinaryExpression',
	LOGICAL_EXP = 'LogicalExpression',
	CONDITIONAL_EXP = 'ConditionalExpression',
	ARRAY_EXP = 'Array',
	PARENT_EXP = 'ParentExpression',
	CURR_LEVEL_EXP = 'CurrLevelExpression',

	PERIOD_CODE = 46, // '.'
	COMMA_CODE  = 44, // ','
	SQUOTE_CODE = 39, // single quote
	DQUOTE_CODE = 34, // double quotes
	OPAREN_CODE = 40, // (
	CPAREN_CODE = 41, // )
	OBRACK_CODE = 91, // [
	CBRACK_CODE = 93, // ]
	QUMARK_CODE = 63, // ?
	SEMCOL_CODE = 59, // ;
	COLON_CODE  = 58, // :

	throwError = function(message, index) {
		var error = new Error(message + ' at character ' + index);
		error.index = index;
		error.dedscription = message;
		throw error;
	},

	jsep = (function() {

	// Operations
	// ----------
	
	// Set `t` to `true` to save space (when minified, not gzipped)
	var t = true,
	// Use a quickly-accessible map to store all of the unary operators
	// Values are set to `true` (it really doesn't matter)
		unary_ops = {'-': t, '!': t, '~': t, '+': t},
	// Also use a map for the binary operations but set their values to their
	// binary precedence for quick reference:
	// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)
		binary_ops = {
			'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,
			'==': 6, '!=': 6, '===': 6, '!==': 6,
			'<': 7,  '>': 7,  '<=': 7,  '>=': 7, 
			'<<':8,  '>>': 8, '>>>': 8,
			'+': 9, '-': 9,
			'*': 10, '/': 10, '%': 10
		},
	// Get return the longest key length of any object
		getMaxKeyLen = function(obj) {
			var max_len = 0, len;
			for(var key in obj) {
				if((len = key.length) > max_len && obj.hasOwnProperty(key)) {
					max_len = len;
				}
			}
			return max_len;
		},
		max_unop_len = getMaxKeyLen(unary_ops),
		max_binop_len = getMaxKeyLen(binary_ops),
	// Literals
	// ----------
	// Store the values to return for the various literals we may encounter
		literals = {
			'true': true,
			'false': false,
			'null': null
		},
	// Except for `this`, which is special. This could be changed to something like `'self'` as well
		this_str = 'this',
	// Returns the precedence of a binary operator or `0` if it isn't a binary operator
		binaryPrecedence = function(op_val) {
			return binary_ops[op_val] || 0;
		},
	// Utility function (gets called from multiple places)
	// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions
		createBinaryExpression = function (operator, left, right) {
			var type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;
			return {
				type: type,
				operator: operator,
				left: left,
				right: right
			};
		},
		// `ch` is a character code in the next three functions
		isDecimalDigit = function(ch) {
			return (ch >= 48 && ch <= 57); // 0...9
		},
		isIdentifierStart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch === 64) || // @
					(ch >= 97 && ch <= 122); // a...z
		},
		isIdentifierPart = function(ch) {
			return (ch === 36) || (ch === 95) || // `$` and `_`
					(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122) || // a...z
					(ch >= 48 && ch <= 57); // 0...9
		},

		// Parsing
		// -------
		// `expr` is a string with the passed in expression
		jsep = function(expr) {
			// `index` stores the character number we are currently at while `length` is a constant
			// All of the gobbles below will modify `index` as we move along
			var index = 0,
				charAtFunc = expr.charAt,
				charCodeAtFunc = expr.charCodeAt,
				exprI = function(i) { return charAtFunc.call(expr, i); },
				exprICode = function(i) { return charCodeAtFunc.call(expr, i); },
				length = expr.length,

				// Push `index` up to the next non-space character
				gobbleSpaces = function() {
					var ch = exprICode(index);
					// space or tab
					while(ch === 32 || ch === 9) {
						ch = exprICode(++index);
					}
				},
				
				// The main parsing function. Much of this code is dedicated to ternary expressions
				gobbleExpression = function() {
					var test = gobbleBinaryExpression(),
						consequent, alternate;
					
					gobbleSpaces();
					// Ternary expression: test ? consequent : alternate
					if(exprICode(index) === QUMARK_CODE) {
						index++;
						consequent = gobbleExpression();
						if(!consequent) {
							throwError('Expected expression', index);
						}
						gobbleSpaces();
						if(exprICode(index) === COLON_CODE) {
							index++;
							alternate = gobbleExpression();
							if(!alternate) {
								throwError('Expected expression', index);
							}
							return {
								type: CONDITIONAL_EXP,
								test: test,
								consequent: consequent,
								alternate: alternate
							};
						} else {
							throwError('Expected :', index);
						}
					} else {
						return test;
					}
				},

				// Search for the operation portion of the string (e.g. `+`, `===`)
				// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
				// and move down from 3 to 2 to 1 character until a matching binary operation is found
				// then, return that binary operation
				gobbleBinaryOp = function() {
					gobbleSpaces();
					var biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;
					while(tc_len > 0) {
						if(binary_ops.hasOwnProperty(to_check)) {
							index += tc_len;
							return to_check;
						}
						to_check = to_check.substr(0, --tc_len);
					}
					return false;
				},

				// This function is responsible for gobbling an individual expression,
				// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
				gobbleBinaryExpression = function() {
					var ch_i, node, biop, prec, stack, biop_info, left, right, i;

					// First, try to get the leftmost thing
					// Then, check to see if there's a binary operator operating on that leftmost thing
					left = gobbleToken();
					biop = gobbleBinaryOp();

					// If there wasn't a binary operator, just return the leftmost node
					if(!biop) {
						return left;
					}

					// Otherwise, we need to start a stack to properly place the binary operations in their
					// precedence structure
					biop_info = { value: biop, prec: binaryPrecedence(biop)};

					right = gobbleToken();
					if(!right) {
						throwError("Expected expression after " + biop, index);
					}
					stack = [left, biop_info, right];

					// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)
					while((biop = gobbleBinaryOp())) {
						prec = binaryPrecedence(biop);

						if(prec === 0) {
							break;
						}
						biop_info = { value: biop, prec: prec };

						// Reduce: make a binary expression from the three topmost entries.
						while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
							right = stack.pop();
							biop = stack.pop().value;
							left = stack.pop();
							node = createBinaryExpression(biop, left, right);
							stack.push(node);
						}

						node = gobbleToken();
						if(!node) {
							throwError("Expected expression after " + biop, index);
						}
						stack.push(biop_info, node);
					}

					i = stack.length - 1;
					node = stack[i];
					while(i > 1) {
						node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node); 
						i -= 2;
					}
					return node;
				},

				// An individual part of a binary expression:
				// e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
				gobbleToken = function() {
					var ch, curr_node, unop, to_check, tc_len;
					
					gobbleSpaces();
					ch = exprICode(index);

					if(ch === PERIOD_CODE && expr.charCodeAt(index+1) === 47) {
							index += 2;
							return {
									type: CURR_LEVEL_EXP,
									argument: gobbleToken()
							};
					} else if(ch === PERIOD_CODE && expr.charCodeAt(index+1) === PERIOD_CODE && expr.charCodeAt(index+2) === 47) {
							index += 3;
							return {
									type: PARENT_EXP,
									argument: gobbleToken()
							};
					}

					if(isDecimalDigit(ch) || ch === PERIOD_CODE) {
						// Char code 46 is a dot `.` which can start off a numeric literal
						return gobbleNumericLiteral();
					} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {
						// Single or double quotes
						return gobbleStringLiteral();
					} else if(isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis
						// `foo`, `bar.baz`
						return gobbleVariable();
					} else {
						to_check = expr.substr(index, max_unop_len);
						tc_len = to_check.length;
						while(tc_len > 0) {
							if(unary_ops.hasOwnProperty(to_check)) {
								index += tc_len;
								return {
									type: UNARY_EXP,
									operator: to_check,
									argument: gobbleToken(),
									prefix: true
								};
							}
							to_check = to_check.substr(0, --tc_len);
						}
						
						return false;
					}
				},
				// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
				// keep track of everything in the numeric literal and then calling `parseFloat` on that string
				gobbleNumericLiteral = function() {
					var number = '', ch;
					while(isDecimalDigit(exprICode(index))) {
						number += exprI(index++);
					}

					if(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker
						number += exprI(index++);

						while(isDecimalDigit(exprICode(index))) {
							number += exprI(index++);
						}
					}
					
					ch = exprI(index);
					if(ch === 'e' || ch === 'E') { // exponent marker
						number += exprI(index++);
						ch = exprI(index);
						if(ch === '+' || ch === '-') { // exponent sign
							number += exprI(index++);
						}
						while(isDecimalDigit(exprICode(index))) { //exponent itself
							number += exprI(index++);
						}
						if(!isDecimalDigit(exprICode(index-1)) ) {
							throwError('Expected exponent (' + number + exprI(index) + ')', index);
						}
					}
					

					// Check to make sure this isn't a variable name that start with a number (123abc)
					if(isIdentifierStart(exprICode(index))) {
						throwError( 'Variable names cannot start with a number (' +
									number + exprI(index) + ')', index);
					}

					return {
						type: LITERAL,
						value: parseFloat(number),
						raw: number
					};
				},

				// Parses a string literal, staring with single or double quotes with basic support for escape codes
				// e.g. `"hello world"`, `'this is\nJSEP'`
				gobbleStringLiteral = function() {
					var str = '', quote = exprI(index++), closed = false, ch;

					while(index < length) {
						ch = exprI(index++);
						if(ch === quote) {
							closed = true;
							break;
						} else if(ch === '\\') {
							// Check for all of the common escape codes
							ch = exprI(index++);
							switch(ch) {
								case 'n': str += '\n'; break;
								case 'r': str += '\r'; break;
								case 't': str += '\t'; break;
								case 'b': str += '\b'; break;
								case 'f': str += '\f'; break;
								case 'v': str += '\x0B'; break;
							}
						} else {
							str += ch;
						}
					}

					if(!closed) {
						throwError('Unclosed quote after "'+str+'"', index);
					}

					return {
						type: LITERAL,
						value: str,
						raw: quote + str + quote
					};
				},
				
				// Gobbles only identifiers
				// e.g.: `foo`, `_value`, `$x1`
				// Also, this function checks if that identifier is a literal:
				// (e.g. `true`, `false`, `null`) or `this`
				gobbleIdentifier = function() {
					var ch = exprICode(index), start = index, identifier;

					if(isIdentifierStart(ch)) {
						index++;
					} else {
						throwError('Unexpected ' + exprI(index), index);
					}

					while(index < length) {
						ch = exprICode(index);
						if(isIdentifierPart(ch)) {
							index++;
						} else {
							break;
						}
					}
					identifier = expr.slice(start, index);

					if(literals.hasOwnProperty(identifier)) {
						return {
							type: LITERAL,
							value: literals[identifier],
							raw: identifier
						};
					} else if(identifier === this_str) {
						return { type: THIS_EXP };
					} else {
						return {
							type: IDENTIFIER,
							name: identifier
						};
					}
				},

				// Gobbles a list of arguments within the context of a function call
				// or array literal. This function also assumes that the opening character
				// `(` or `[` has already been gobbled, and gobbles expressions and commas
				// until the terminator character `)` or `]` is encountered.
				// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
				gobbleArguments = function(termination) {
					var ch_i, args = [], node;
					while(index < length) {
						gobbleSpaces();
						ch_i = exprICode(index);
						if(ch_i === termination) { // done parsing
							index++;
							break;
						} else if (ch_i === COMMA_CODE) { // between expressions
							index++;
						} else {
							node = gobbleExpression();
							if(!node || node.type === COMPOUND) {
								throwError('Expected comma', index);
							}
							args.push(node);
						}
					}
					return args;
				},

				// Gobble a non-literal variable name. This variable name may include properties
				// e.g. `foo`, `bar.baz`, `foo['bar'].baz`
				// It also gobbles function calls:
				// e.g. `Math.acos(obj.angle)`
				gobbleVariable = function() {
					var ch_i, node;
					ch_i = exprICode(index);
						
					if(ch_i === OPAREN_CODE) {
						node = gobbleGroup();
					} else {
						node = gobbleIdentifier();
					}
					gobbleSpaces();
					ch_i = exprICode(index);
					while(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {
						index++;
						if(ch_i === PERIOD_CODE) {
							gobbleSpaces();
							node = {
								type: MEMBER_EXP,
								computed: false,
								object: node,
								property: gobbleIdentifier()
							};
						} else if(ch_i === OBRACK_CODE) {
							node = {
								type: MEMBER_EXP,
								computed: true,
								object: node,
								property: gobbleExpression()
							};
							gobbleSpaces();
							ch_i = exprICode(index);
							if(ch_i !== CBRACK_CODE) {
								throwError('Unclosed [', index);
							}
							index++;
						} else if(ch_i === OPAREN_CODE) {
							// A function call is being made; gobble all the arguments
							node = {
								type: CALL_EXP,
								'arguments': gobbleArguments(CPAREN_CODE),
								callee: node
							};
						}
						gobbleSpaces();
						ch_i = exprICode(index);
					}
					return node;
				},

				// Responsible for parsing a group of things within parentheses `()`
				// This function assumes that it needs to gobble the opening parenthesis
				// and then tries to gobble everything within that parenthesis, assuming
				// that the next thing it should see is the close parenthesis. If not,
				// then the expression probably doesn't have a `)`
				gobbleGroup = function() {
					index++;
					var node = gobbleExpression();
					gobbleSpaces();
					if(exprICode(index) === CPAREN_CODE) {
						index++;
						return node;
					} else {
						throwError('Unclosed (', index);
					}
				},

				// Responsible for parsing Array literals `[1, 2, 3]`
				// This function assumes that it needs to gobble the opening bracket
				// and then tries to gobble the expressions as arguments.
				gobbleArray = function() {
					index++;
					return {
						type: ARRAY_EXP,
						body: gobbleArguments(CBRACK_CODE)
					};
				},

				nodes = [], ch_i, node;
				
			while(index < length) {
				ch_i = exprICode(index);

				// Expressions can be separated by semicolons, commas, or just inferred without any
				// separators
				if(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
					index++; // ignore separators
				} else if (ch_i === OBRACK_CODE && (node = gobbleArray())) {
					nodes.push(node);
				} else {
					// Try to gobble each expression individually
					if((node = gobbleExpression())) {
						nodes.push(node);
					// If we weren't able to find a binary expression and are out of room, then
					// the expression passed in probably has too much
					} else if(index < length) {
						throwError('Unexpected "' + exprI(index) + '"', index);
					}
				}
			}

			// If there's only one expression just try returning the expression
			if(nodes.length === 1) {
				return nodes[0];
			} else {
				return {
					type: COMPOUND,
					body: nodes
				};
			}
		};
	return jsep;
}());

return cjs;
}(this));

// Export for node
if (typeof module !== 'undefined' && module.exports) {
	/** @exports cjs */
	module.exports = cjs;
}

/*jslint nomen: true, vars: true, eqeq: true */
/*jshint eqnull: true */
/*global window */

var able = (function (root) {
	"use strict";

	//
	// ============== UTILITY FUNCTIONS ============== 
	//
	var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
	var slice = ArrayProto.slice,
		toString = ObjProto.toString,
		nativeForEach = ArrayProto.forEach,
		nativeMap = ArrayProto.map;

	// Is a given value an array?
	// Delegates to ECMA5's native Array.isArray
	var isArray = Array.isArray || function (obj) {
		return toString.call(obj) === '[object Array]';
	};


	// Is a given value a function?
	var isFunction = function (obj) {
		return toString.call(obj) === '[object Function]';
	};

	// Is a given variable a string?
	var isString = function (obj) {
		return toString.call(obj) === '[object String]';
	};

	// Is a given variable an arguments object?
	var isArguments = function (obj) {
		return toString.call(obj) === '[object Arguments]';
	};

	// Establish the object that gets returned to break out of a loop iteration.
	var breaker = {};

	var extend = function (obj) {
		var args = slice.call(arguments, 1),
			i,
			len = args.length,
			prop;
		for (i = 0; i < len; i += 1) {
			var source = args[i];
			for (prop in source) {
				if (source.hasOwnProperty(prop)) {
					obj[prop] = source[prop];
				}
			}
		}
		return obj;
	};

	var last = function (arr) {
		return arr[arr.length - 1];
	};

	var each = function (obj, iterator, context) {
		var i, l, key;
		if (!obj) { return; }
		if (nativeForEach && obj.forEach === nativeForEach) {
			obj.forEach(iterator, context);
		} else if (obj.length === +obj.length) {
			l = obj.length;
			for (i = 0; i < l; i += 1) {
				if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === breaker) { return; }
			}
		} else {
			for (key in obj) {
				if (obj.hasOwnProperty(key)) {
					if (iterator.call(context, obj[key], key, obj) === breaker) { return; }
				}
			}
		}
	};

	var map = function (obj, iterator, context) {
		var results = [];
		if (!obj) { return results; }
		if (nativeMap && obj.map === nativeMap) { return obj.map(iterator, context); }
		each(obj, function (value, index, list) {
			results[results.length] = iterator.call(context, value, index, list);
		});
		if (obj.length === +obj.length) { results.length = obj.length; }
		return results;
	};

	var nativeFilter = Array.prototype.filter;
	var filter = function (obj, iterator, context) {
		var results = [];
		if (!obj) { return results; }
		if (nativeFilter && obj.filter === nativeFilter) { return obj.filter(iterator, context); }
		var i, len = obj.length, value;
		for (i = 0; i < len; i += 1) {
			value = obj[i];
			if (iterator.call(context, value, i, obj)) { results.push(value); }
		}
		return results;
	};

	// Returns everything but the first entry of the array. Aliased as `tail`.
	// Especially useful on the arguments object. Passing an **index** will return
	// the rest of the values in the array from that index onward. The **guard**
	// check allows it to work with `_.map`.
	var rest = function (array, index, guard) {
		return slice.call(array, (index == null) || guard ? 1 : index);
	};

	// Keep the identity function around for default iterators.
	var identity = function (value) {
		return value;
	};

	// Retrieve the values of an object's properties.
	var values = function (obj) {
		return map(obj, identity);
	};

	// Safely convert anything iterable into a real, live array.
	var toArray = function (obj) {
		if (!obj) { return []; }
		if (isArray(obj)) { return slice.call(obj); }
		if (isArguments(obj)) { return slice.call(obj); }
		if (obj.toArray && isFunction(obj.toArray)) { return obj.toArray(); }
		return values(obj);
	};


	var hOP = Object.prototype.hasOwnProperty;
	var has = function (obj, key) {
		return hOP.call(obj, key);
	};



	var old_able = root.able;
	var able = function () { };
	able.version = "<%= version %>";

	able.noConflict = function () { root.able = able; return able; };


	(function () {
		var listener_prop_name = "__listeners",
			emit_fn_name = "_emit";

		able.make_this_listenable = function (instance) {
			if(!instance[listener_prop_name]) {
				instance[listener_prop_name] = {};
			}
			/*
			instance.forward = function () {
				var args = toArray(arguments);
				var type = args[args.length - 1];
				instance._emit.apply(instance, ([type]).concat(args.slice(0, args.length - 1)));
			};
			*/
		};

		var do_on = function(event_type, callback, context) {
			var listeners = this[listener_prop_name][event_type];
			var args = rest(arguments, 3);

			var linfo = {callback: callback, context: context, args: args};
			if (listeners) {
				listeners.push(linfo);
			} else {
				listeners = this[listener_prop_name][event_type] = [linfo];
			}
		};
		var do_off = function(event_type, callback, context) {
			var listeners = this[listener_prop_name][event_type];
			var i;
			if (listeners) {
				for (i = 0; i < listeners.length; i += 1) {
					var listener = listeners[i];
					if (listener.callback === callback && (!context || context === listener.context)) {
						listeners.splice(i, 1);
						i -= 1;
					}
				}
				if (listeners.length === 0) {
					delete this[listener_prop_name][event_type];
				}
			}
		};

		able.make_proto_listenable = function (proto) {
			proto.on = function (event_type, callback, context) {
				if(isString(event_type)) {
					do_on.apply(this, arguments);
				} else {
					context = callback;
					each(event_type, function(cb, et) {
						do_on.call(this, et, cb, context);
					}, this);
				}
				return this;
			};
			proto.once = function (event_type, callback, context) {
				var listeners = this[listener_prop_name][event_type];
				if (!isArray(listeners)) {
					listeners = this[listener_prop_name][event_type] = [];
				}
				var args = rest(arguments, 3);
				listeners.push({callback: callback, context: context, once: true, args: args});
				return this;
			};
			proto.off = function (event_type, callback) {
				if(isString(event_type)) {
					do_off.apply(this, arguments);
				} else {
					each(event_type, function(cb, et) {
						do_off.call(this, et, cb);
					}, this);
				}
				return this;
			};
			proto.forward_event = function() {
				var args = toArray(arguments);
				var type = args[args.length - 1];
				this._emit.apply(this, ([type]).concat(args.slice(0, args.length - 1)));
			};
			proto[emit_fn_name] = function (event_type) {
				var i;
				var args = rest(arguments);
				args.push(event_type);
				var listeners = this[listener_prop_name][event_type];
				if (listeners) {
					var cloned_listeners = listeners.slice();
					var len = cloned_listeners.length;
					var num_removed = 0;
					for (i = 0; i < len; i += 1) {
						var listener = cloned_listeners[i];
						var context = listener.context || this;
						listener.callback.apply(context, listener.args.concat(args));
						if (listener.once === true) {
							listeners.splice(i - num_removed, 1);
							num_removed += 1;
						}
					}
					if (listeners.length === 0 && this[listener_prop_name]) { // we may have been destroyed
						delete this[listener_prop_name][event_type];
					}
				}
			};
		};

		able.destroy_this_listenable = function (instance) {
			delete instance[listener_prop_name];
			//delete instance.forward;
		};
	}());

	(function () {
		var options_prop_name = "__options",
			emit_fn_name = "_emit";
		
		able.make_this_optionable = function (instance) {
			instance[options_prop_name] = extend.apply(this, [{}].concat(Array.prototype.slice.call(arguments, 1)));
		};
		
		able.make_proto_optionable = function (proto) {
			proto._get_option = function (key) {
				var value = this[options_prop_name][key];
				if (isFunction(value)) {
					return value.call(this);
				} else {
					return value;
				}
			};
			proto._set_option = function (key, value) {
				this[options_prop_name][key] = value;
			};
		
			proto._on_option_set = function (key, value) { };
			proto._on_options_set = function (values) { };
		
			proto.option = function (key, value) {
				var args;
				if (arguments.length === 0) {
					return this;
				} else if (isString(key)) {
					if (arguments.length === 1) {
						return this._get_option(key);
					} else {
						args = rest(arguments, 2);
						this._set_option.apply(this, [key, value].concat(args));
						this._on_option_set.apply(this, [key, value].concat(args));
		
						var keys_val = {};
						keys_val[key] = value;
						this._on_options_set.apply(this, [keys_val].concat(args));
		
						return this;
					}
				} else {
					args = rest(arguments, 1);
					each(key, function (v, k) {
						this._set_option.apply(this, [k, v].concat(args));
						this._on_option_set.apply(this, [k, v].concat(args));
					}, this);
					this._on_options_set.apply(this, [key].concat(args));
					return this;
				}
			};
		};
		able.destroy_this_optionable = function (instance) {
			delete instance[options_prop_name];
		};
	}());

	return able;
}(this));

(function(root){

  // Let's borrow a couple of things from Underscore that we'll need

  // _.each
  var breaker = {},
      AP = Array.prototype,
      OP = Object.prototype,

      hasOwn = OP.hasOwnProperty,
      toString = OP.toString,
      forEach = AP.forEach,
      indexOf = AP.indexOf,
      slice = AP.slice;

  var _each = function( obj, iterator, context ) {
    var key, i, l;

    if ( !obj ) {
      return;
    }
    if ( forEach && obj.forEach === forEach ) {
      obj.forEach( iterator, context );
    } else if ( obj.length === +obj.length ) {
      for ( i = 0, l = obj.length; i < l; i++ ) {
        if ( i in obj && iterator.call( context, obj[i], i, obj ) === breaker ) {
          return;
        }
      }
    } else {
      for ( key in obj ) {
        if ( hasOwn.call( obj, key ) ) {
          if ( iterator.call( context, obj[key], key, obj) === breaker ) {
            return;
          }
        }
      }
    }
  };

  // _.isFunction
  var _isFunction = function( obj ) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  // _.extend
  var _extend = function( obj ) {

    _each( slice.call( arguments, 1), function( source ) {
      var prop;

      for ( prop in source ) {
        if ( source[prop] !== void 0 ) {
          obj[ prop ] = source[ prop ];
        }
      }
    });
    return obj;
  };

  // $.inArray
  var _inArray = function( elem, arr, i ) {
    var len;

    if ( arr ) {
      if ( indexOf ) {
        return indexOf.call( arr, elem, i );
      }

      len = arr.length;
      i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

      for ( ; i < len; i++ ) {
        // Skip accessing in sparse arrays
        if ( i in arr && arr[ i ] === elem ) {
          return i;
        }
      }
    }

    return -1;
  };

  // And some jQuery specific helpers

  var class2type = {};

  // Populate the class2type map
  _each("Boolean Number String Function Array Date RegExp Object".split(" "), function(name, i) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase();
  });

  var _type = function( obj ) {
    return obj == null ?
      String( obj ) :
      class2type[ toString.call(obj) ] || "object";
  };

  // Now start the jQuery-cum-Underscore implementation. Some very
  // minor changes to the jQuery source to get this working.

  // Internal Deferred namespace
  var _d = {};
  // String to Object options format cache
  var optionsCache = {};

  // Convert String-formatted options into Object-formatted ones and store in cache
  function createOptions( options ) {
    var object = optionsCache[ options ] = {};
    _each( options.split( /\s+/ ), function( flag ) {
      object[ flag ] = true;
    });
    return object;
  }

  _d.Callbacks = function( options ) {

    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ?
      ( optionsCache[ options ] || createOptions( options ) ) :
      _extend( {}, options );

    var // Last fire value (for non-forgettable lists)
      memory,
      // Flag to know if list was already fired
      fired,
      // Flag to know if list is currently firing
      firing,
      // First callback to fire (used internally by add and fireWith)
      firingStart,
      // End of the loop when firing
      firingLength,
      // Index of currently firing callback (modified by remove if needed)
      firingIndex,
      // Actual callback list
      list = [],
      // Stack of fire calls for repeatable lists
      stack = !options.once && [],
      // Fire callbacks
      fire = function( data ) {
        memory = options.memory && data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for ( ; list && firingIndex < firingLength; firingIndex++ ) {
          if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
            memory = false; // To prevent further calls using add
            break;
          }
        }
        firing = false;
        if ( list ) {
          if ( stack ) {
            if ( stack.length ) {
              fire( stack.shift() );
            }
          } else if ( memory ) {
            list = [];
          } else {
            self.disable();
          }
        }
      },
      // Actual Callbacks object
      self = {
        // Add a callback or a collection of callbacks to the list
        add: function() {
          if ( list ) {
            // First, we save the current length
            var start = list.length;
            (function add( args ) {
              _each( args, function( arg ) {
                var type = _type( arg );
                if ( type === "function" ) {
                  if ( !options.unique || !self.has( arg ) ) {
                    list.push( arg );
                  }
                } else if ( arg && arg.length && type !== "string" ) {
                  // Inspect recursively
                  add( arg );
                }
              });
            })( arguments );
            // Do we need to add the callbacks to the
            // current firing batch?
            if ( firing ) {
              firingLength = list.length;
            // With memory, if we're not firing then
            // we should call right away
            } else if ( memory ) {
              firingStart = start;
              fire( memory );
            }
          }
          return this;
        },
        // Remove a callback from the list
        remove: function() {
          if ( list ) {
            _each( arguments, function( arg ) {
              var index;
              while( ( index = _inArray( arg, list, index ) ) > -1 ) {
                list.splice( index, 1 );
                // Handle firing indexes
                if ( firing ) {
                  if ( index <= firingLength ) {
                    firingLength--;
                  }
                  if ( index <= firingIndex ) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        // Control if a given callback is in the list
        has: function( fn ) {
          return _inArray( fn, list ) > -1;
        },
        // Remove all callbacks from the list
        empty: function() {
          list = [];
          return this;
        },
        // Have the list do nothing anymore
        disable: function() {
          list = stack = memory = undefined;
          return this;
        },
        // Is it disabled?
        disabled: function() {
          return !list;
        },
        // Lock the list in its current state
        lock: function() {
          stack = undefined;
          if ( !memory ) {
            self.disable();
          }
          return this;
        },
        // Is it locked?
        locked: function() {
          return !stack;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function( context, args ) {
          args = args || [];
          args = [ context, args.slice ? args.slice() : args ];
          if ( list && ( !fired || stack ) ) {
            if ( firing ) {
              stack.push( args );
            } else {
              fire( args );
            }
          }
          return this;
        },
        // Call all the callbacks with the given arguments
        fire: function() {
          self.fireWith( this, arguments );
          return this;
        },
        // To know if the callbacks have already been called at least once
        fired: function() {
          return !!fired;
        }
      };

    return self;
  };

  _d.Deferred = function( func ) {

    var tuples = [
        // action, add listener, listener list, final state
        [ "resolve", "done", _d.Callbacks("once memory"), "resolved" ],
        [ "reject", "fail", _d.Callbacks("once memory"), "rejected" ],
        [ "notify", "progress", _d.Callbacks("memory") ]
      ],
      state = "pending",
      promise = {
        state: function() {
          return state;
        },
        always: function() {
          deferred.done( arguments ).fail( arguments );
          return this;
        },
        then: function( /* fnDone, fnFail, fnProgress */ ) {
          var fns = arguments;

          return _d.Deferred(function( newDefer ) {

            _each( tuples, function( tuple, i ) {
              var action = tuple[ 0 ],
                fn = fns[ i ];

              // deferred[ done | fail | progress ] for forwarding actions to newDefer
              deferred[ tuple[1] ]( _isFunction( fn ) ?

                function() {
                  var returned;
                  try { returned = fn.apply( this, arguments ); } catch(e){
                    newDefer.reject(e);
                    return;
                  }

                  if ( returned && _isFunction( returned.promise ) ) {
                    returned.promise()
                      .done( newDefer.resolve )
                      .fail( newDefer.reject )
                      .progress( newDefer.notify );
                  } else {
                    newDefer[ action !== "notify" ? 'resolveWith' : action + 'With']( this === deferred ? newDefer : this, [ returned ] );
                  }
                } :

                newDefer[ action ]
              );
            });

            fns = null;

          }).promise();

        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function( obj ) {
          return obj != null ? _extend( obj, promise ) : promise;
        }
      },
      deferred = {};

    // Keep pipe for back-compat
    promise.pipe = promise.then;

    // Add list-specific methods
    _each( tuples, function( tuple, i ) {
      var list = tuple[ 2 ],
        stateString = tuple[ 3 ];

      // promise[ done | fail | progress ] = list.add
      promise[ tuple[1] ] = list.add;

      // Handle state
      if ( stateString ) {
        list.add(function() {
          // state = [ resolved | rejected ]
          state = stateString;

        // [ reject_list | resolve_list ].disable; progress_list.lock
        }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
      }

      // deferred[ resolve | reject | notify ] = list.fire
      deferred[ tuple[0] ] = list.fire;
      deferred[ tuple[0] + "With" ] = list.fireWith;
    });

    // Make the deferred a promise
    promise.promise( deferred );

    // Call given func if any
    if ( func ) {
      func.call( deferred, deferred );
    }

    // All done!
    return deferred;
  };

  // Deferred helper
  _d.when = function( subordinate /* , ..., subordinateN */ ) { 

    var i = 0,
      resolveValues = ( _type(subordinate) === 'array' && arguments.length === 1 ) ? subordinate : slice.call( arguments ),
      length = resolveValues.length;

      if ( _type(subordinate) === 'array' && subordinate.length === 1 ) {
        subordinate = subordinate[ 0 ];
      }

      // the count of uncompleted subordinates
      var remaining = length !== 1 || ( subordinate && _isFunction( subordinate.promise ) ) ? length : 0,

      // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
      deferred = remaining === 1 ? subordinate : _d.Deferred(),

      // Update function for both resolve and progress values
      updateFunc = function( i, contexts, values ) {
        return function( value ) {
          contexts[ i ] = this;
          values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
          if( values === progressValues ) {
            deferred.notifyWith( contexts, values );
          } else if ( !( --remaining ) ) {
            deferred.resolveWith( contexts, values );
          }
        };
      },

      progressValues, progressContexts, resolveContexts;

    // add listeners to Deferred subordinates; treat others as resolved
    if ( length > 1 ) {
      progressValues = new Array( length );
      progressContexts = new Array( length );
      resolveContexts = new Array( length );
      for ( ; i < length; i++ ) {
        if ( resolveValues[ i ] && _isFunction( resolveValues[ i ].promise ) ) {
          resolveValues[ i ].promise()
            .done( updateFunc( i, resolveContexts, resolveValues ) )
            .fail( deferred.reject )
            .progress( updateFunc( i, progressContexts, progressValues ) );
        } else {
          --remaining;
        }
      }
    }

    // if we're not waiting on anything, resolve the master
    if ( !remaining ) {
      deferred.resolveWith( resolveContexts, resolveValues );
    }

    return deferred.promise();
  };

  // Try exporting as a Common.js Module
  if ( typeof module !== "undefined" && module.exports ) {
    module.exports = _d;

  // Or mixin to Underscore.js
  } else if ( typeof root._ !== "undefined" ) {
    root._.mixin(_d);

  // Or assign it to window._
  } else {
    root._ = _d;
  }

})(this);

/*global window,getArrayDiff */

(function () {
	"use strict";
	var _ = window._;
	var rdashAlpha = /-([a-z]|[0-9])/ig, rmsPrefix = /^-ms-/;
	var fcamelCase = function(all, letter) {
		return String(letter).toUpperCase();
	};
	var clone = _.clone;

	_.mixin({
		remove_index: function(arr, from, to) {
			//http://ejohn.org/blog/javascript-array-remove/
			var rest = arr.slice((to || from) + 1 || arr.length);
			arr.length = from < 0 ? arr.length + from : from;
			return arr.push.apply(arr, rest);
		},
		remove: function(arr, obj) {
			var objIndex = index_of(arr, obj);

			if(objIndex>=0) {
				remove_index(arr, objIndex);
			}
		},
		remove_all: function(arr, obj) {
			var objIndex;
			do {
				objIndex = index_of(arr, obj);

				if(objIndex>=0) {
					remove_index(arr, objIndex);
				}
			} while(objIndex >= 0);
		},
		index_of: function(arr, item, equality_check) {
			if(equality_check === undefined) { equality_check = function(a,b) { return a === b; }; }
			return index_where(arr, function(x) { return equality_check(item, x); });
		},
		index_where: function(arr, test) {
			var i, len = arr.length;
			for(i = 0; i<len; i++) {
				if(test(arr[i], i)) { return i; }
			}
			return -1;
		},
		clear: function(arr) {
			arr.length = 0;
		},
		insert_at: function(arr, item, index) {
			var rest;
			if(index===undefined) { return arr.push(item); }

			rest = arr.slice(index);
			arr.length = index;
			arr.push(item);
			return arr.push.apply(arr, rest);
		},
		set_index: function(arr, old_index, new_index) {
			if(old_index>=0 && old_index < arr.length && new_index>=0 && new_index < arr.length) {
				var obj = arr[old_index];
				remove_index(arr, old_index);
				/*
				if(new_index > old_index) {
					new_index--; //Account for the fact that the indicies shift
				}
				*/
				insert_at(arr, obj, new_index);
				return obj;
			}
			return false;
		},
		diff: cjs.arrayDiff,
		//function(oldArray, newArray, equality_check) {
			//return getArrayDiff(oldArray, newArray, equality_check);
		//},

		proto_extend: function (subClass, superClass) {
				var F = function() {};
				F.prototype = superClass.prototype;
				subClass.prototype = new F();
				subClass.prototype.constructor = subClass;
				
				subClass.superclass = superClass.prototype;
				if(superClass.prototype.constructor === Object.prototype.constructor) {
					superClass.prototype.constructor = superClass;
				}
			},
		// Convert dashed to camelCase; used by the css and data modules
		// Microsoft forgot to hump their vendor prefix (#9572)
		camel_case: function(string) {
				return string.replace( rmsPrefix, "ms-" ).replace(rdashAlpha, fcamelCase);
			},
		deepExtend: function(obj) {
				var parentRE = new RegExp("#{\\s*?_\\s*?}"),
				slice = Array.prototype.slice,
				hOP = Object.prototype.hasOwnProperty;
				var is_null_fn = _.bind(_.isNull, _);

				_.each(slice.call(arguments, 1), function(source) {
						for (var prop in source) {
							if (hOP.call(source, prop)) {
								if (_.isUndefined(obj[prop])) {
									obj[prop] = source[prop];
								} else if (_.isString(source[prop]) && parentRE.test(source[prop])) {
									if (_.isString(obj[prop])) {
									obj[prop] = source[prop].replace(parentRE, obj[prop]);
									}
								} else if (_.isArray(obj[prop]) || _.isArray(source[prop])){
									if (!_.isArray(obj[prop]) || !_.isArray(source[prop])){
										throw 'Error: Trying to combine an array with a non-array (' + prop + ')';
									} else {
										obj[prop] = _.reject(_.deepExtend(obj[prop], source[prop]), is_null_fn);
									}
								} else if (_.isObject(obj[prop]) || _.isObject(source[prop])){
									if (!_.isObject(obj[prop]) || !_.isObject(source[prop])){
										throw 'Error: Trying to combine an object with a non-object (' + prop + ')';
									} else {
										obj[prop] = _.deepExtend(obj[prop], source[prop]);
									}
								} else {
									obj[prop] = source[prop];
								}
							}
						}
				});
				return obj;
			}
	});
	_.isTextElement = function(obj) {
		return !!(obj && obj.nodeType === 3);
	};
	_.isCommentElement = function(obj) {
		return !!(obj && obj.nodeType === 8);
	};
	var index_of = _.index_of;
	var remove_index = _.remove_index;
	var index_where = _.index_where;
	var any = _.any;
	var insert_at = _.insert_at;
}());

/*jslint nomen: true */
/*global cjs,esprima,_,able,uid */

var interstate = (function (root) {
    "use strict";
	var ist = {
		cjs: cjs.noConflict(),
		_: _.noConflict(),
		esprima: esprima,
		version: "<%= version %>",
		build_time: "<%= build_time %>",
		__log_errors: true,
		__debug: false,
		__empty_files: false,
		__garbage_collect: true,
		root_name: "sketch"
	};

	ist.cjs.__debug = ist.__debug;
	ist.__debug_statecharts = ist.__debug;

	able.make_this_listenable(ist);
	able.make_proto_listenable(ist);

	var uid_objs = {};
	ist.register_uid = function (id, obj) {
		uid_objs[id] = obj;
		ist._emit("uid_registered", id, obj);
	};
	ist.unregister_uid = function (id) {
		delete uid_objs[id];
		ist._emit("uid_unregistered", id);
	};
	ist.find_uid = function (uid) { return uid_objs[uid]; };


	var valid_prop_name_regex = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
	ist.is_valid_prop_name = function(name) {
		return name.match(valid_prop_name_regex);
	};

	ist.async_js = function(url, cback) {
		var doc = root.document,
		type = 'script',
		node = doc.createElement(type),
		head = doc.getElementsByTagName('head')[0];

		node.type = 'text/javascript';
		node.src = url;
		if (cback) { node.addEventListener('load', function (e) { cback(e); }, false); }
		head.appendChild(node);
	};

	return ist;
}(this));

/*jslint nomen: true, vars: true, eqeq: true */
/*jshint eqnull: true */
/*global interstate,esprima,able,uid,console,window */

(function (ist) {
	"use strict";
	var cjs = ist.cjs, _ = ist._;
	 
	//http://stackoverflow.com/questions/294297/javascript-implementation-of-gzip
	// LZW-compress a string
	function lzw_encode(s) {
		var dict = {},
			data = s.split(""),
			out = [],
			currChar,
			phrase = data[0],
			code = 256,
			i;
		for (i = 1; i < data.length; i += 1) {
			currChar = data[i];
			if (dict[phrase + currChar] != null) {
				phrase += currChar;
			} else {
				out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));
				dict[phrase + currChar] = code;
				code += 1;
				phrase = currChar;
			}
		}
		out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));
		for (i = 0; i < out.length; i += 1) {
			out[i] = String.fromCharCode(out[i]);
		}
		return out.join("");
	}

	// Decompress an LZW-encoded string
	function lzw_decode(s) {
		var dict = {},
			data = (s).split(""),
			currChar = data[0],
			oldPhrase = currChar,
			out = [currChar],
			code = 256,
			phrase,
			i;
		for (i = 1; i < data.length; i += 1) {
			var currCode = data[i].charCodeAt(0);
			if (currCode < 256) {
				phrase = data[i];
			} else {
				phrase = dict[currCode] || (oldPhrase + currChar);
			}
			out.push(phrase);
			currChar = phrase.charAt(0);
			dict[code] = oldPhrase + currChar;
			code += 1;
			oldPhrase = phrase;
		}
		return out.join("");
	}

	var POINTER_TYPE = "$$pointer";

	// === SERIALIZE ===

	var serialization_funcs = [ ];

	ist.register_serializable_type = function (name, instance_check, serialize, deserialize) {
		serialization_funcs.push({
			name: name,
			instance_check: instance_check,
			serialize: serialize,
			deserialize: deserialize
		});
	};

	ist.register_serializable_type("cjs_array",
		function (x) {
			return cjs.isArrayConstraint(x);
		},
		function () {
			var args = _.toArray(arguments),
				serialized_value = _.map(this.toArray(), function (x) {
					return ist.serialize.apply(ist, ([x]).concat(args));
				});

			return {
				value: serialized_value
			};
		},
		function (obj) {
			var rest_args = _.rest(arguments);
			return cjs.array({
				value: _.map(obj.value, function (x) {
					return ist.deserialize.apply(ist, ([x]).concat(rest_args));
				})
			});
		});

	ist.register_serializable_type("cjs_map",
		function (x) {
			return cjs.isMapConstraint(x);
		},
		function () {
			var args = _.toArray(arguments),
				serialized_keys = _.map(this.keys(), function (x) {
					return ist.serialize.apply(ist, ([x]).concat(args));
				}),
				serialized_values = _.map(this.values(), function (x) {
					return ist.serialize.apply(ist, ([x]).concat(args));
				});

			return {
				keys: serialized_keys,
				values: serialized_values
			};
		},
		function (obj) {
			var rest_args = _.rest(arguments);
			return cjs.map({
				keys: _.map(obj.keys, function (x) {
					return ist.deserialize.apply(ist, ([x]).concat(rest_args));
				}),
				values: _.map(obj.values, function (x) {
					return ist.deserialize.apply(ist, ([x]).concat(rest_args));
				})
			});
		});


	var serializing = false,
		serialized_objs,
		serialized_obj_values,
		find_serialized_obj_id = function (obj) {
			return _.indexOf(serialized_objs, obj);
		};

	function do_serialize(obj) {
		var rest_args = _.rest(arguments),
			i;
		for (i = 0; i < serialization_funcs.length; i += 1) {
			var serialization_info = serialization_funcs[i],
				type = serialization_info.type;
			if (serialization_info.instance_check(obj)) {
				return _.extend({ type: serialization_info.name }, serialization_info.serialize.apply(obj, rest_args));
			}
		}
		
		//Nothing found...do serialization by hand
		var rv = {};

		_.each(obj, function (value, key) {
			rv[key] = ist.serialize.apply(ist, ([value]).concat(rest_args));
		});

		return rv;
	}
	var get_or_create_serialized_obj_id = function (obj) {
		var obj_id = find_serialized_obj_id(obj);
		if (obj_id < 0) {
			obj_id = serialized_objs.length;
			serialized_objs.push(obj);
			serialized_obj_values[obj_id] = do_serialize.apply(this, arguments);
		}
		return obj_id;
	};

	var create_or_get_serialized_obj = function () {
		return {
			type: POINTER_TYPE,
			id: get_or_create_serialized_obj_id.apply(this, arguments)
		};
	};

	ist.serialize = function (obj) {
		var serialize_args = _.rest(arguments),
			is_init_serial_call = false;
		if (!serializing) {
			serializing = true;
			is_init_serial_call = true;
			serialized_objs = [];
			serialized_obj_values = [];
		}

		if (obj == null || (typeof obj !== "object" && typeof obj !== "function")) {
			return obj;
		} else if (_.isArray(obj)) {
			return _.map(obj, function (o) {
				return ist.serialize.apply(ist, ([o]).concat(serialize_args));
			});
		} else if (is_init_serial_call) {
			var serialized_obj = create_or_get_serialized_obj.apply(this, arguments),
				rv = {
					serialized_objs: serialized_obj_values,
					root: serialized_obj
				};
			serializing = false;
			serialized_objs = undefined;
			serialized_obj_values = undefined;
			return rv;
		} else {
			return create_or_get_serialized_obj.apply(this, arguments);
		}
	};



	ist.stringify = function () {
		var serialized_obj = ist.serialize.apply(ist, arguments);
		var stringified_obj = JSON.stringify(serialized_obj);
		return stringified_obj;
	};
	ist.stringify_and_compress = function () {
		var string = ist.stringify.apply(ist, arguments);
		return lzw_encode(string);
	};

	// === DESERIALIZE ===

	var deserialized_objs,
		deserialized_obj_vals,
		deserializing = false;
		
	var do_deserialize = function (serialized_obj) {
		var rest_args = _.rest(arguments),
			serialized_obj_type = (serialized_obj && _.has(serialized_obj, "type")) ? serialized_obj.type : false,
			i;

		for (i = 0; i < serialization_funcs.length; i += 1) {
			var serialization_info = serialization_funcs[i];
			if (serialized_obj_type === serialization_info.name) {
				return serialization_info.deserialize.apply(serialization_info, ([serialized_obj]).concat(rest_args));
			}
		}

		var rv = {};
		_.each(serialized_obj, function (value, key) {
			rv[key] = ist.deserialize.apply(ist, ([value]).concat(rest_args));
		});

		return rv;
	};

	var get_deserialized_obj = function (serialized_obj) {
		var rest_args = _.rest(arguments);
		if (serialized_obj.type === POINTER_TYPE) {
			var id = serialized_obj.id,
				val = deserialized_obj_vals[id];

			if (val === undefined) {
				val = deserialized_obj_vals[id] = do_deserialize.apply(this, ([deserialized_objs[id]]).concat(rest_args));
				if (_.has(val, "initialize")) { // has own property
					val.initialize();
					delete val.initialize;
				}
			}
			return val;
		} else {
			return do_deserialize.apply(this, ([serialized_obj]).concat(rest_args));
		}
	};

	ist.deserialize = function (serialized_obj) {
		var rest_args = _.rest(arguments),
			rv;

		if (deserializing === false) {
			deserializing = true;

			if(ist.__debug) {
				deserialized_objs = serialized_obj.serialized_objs;
				deserialized_obj_vals = [];
				rv = ist.deserialize.apply(ist, ([serialized_obj.root]).concat(rest_args));
				deserialized_objs = deserialized_obj_vals = undefined;
				deserializing = false;
			} else {
				try {
					deserialized_objs = serialized_obj.serialized_objs;
					deserialized_obj_vals = [];
					rv = ist.deserialize.apply(ist, ([serialized_obj.root]).concat(rest_args));
				} finally {
					deserialized_objs = deserialized_obj_vals = undefined;
					deserializing = false;
				}
			}

			return rv;
		}
		
		if (serialized_obj == null || typeof serialized_obj !== "object") {
			return serialized_obj;
		} else if (_.isArray(serialized_obj)) {
			return _.map(serialized_obj, function (x) {
				return ist.deserialize.apply(ist, ([x]).concat(rest_args));
			});
		} else {
			return get_deserialized_obj.apply(this, ([serialized_obj]).concat(rest_args));
		}
	};


	ist.destringify = function (str) {
		var rest_args = _.rest(arguments);
		return ist.deserialize.apply(ist, ([JSON.parse(str)]).concat(rest_args));
	};
	ist.decompress_and_destringify = function (compressed_str) {
		var rest_args = _.rest(arguments);
		var str = lzw_decode(compressed_str);
		return ist.destringify.apply(ist, ([str]).concat(rest_args));
	};


	var type_maps = {};
	ist.loaded_program_name = cjs();

	ist.getSavedProgramMap = function(type) {
		if(!_.isString(type)) {
			type = "";
		}

		var val = {};
		_.each(ist.ls(type), function(prog_name) {
			var name = storage_prefix + prog_name + type_prefix + type,
				prog_str = window.localStorage.getItem(name);
			val[prog_name] = prog_str;
		});

		var map = cjs(val);
		var maps = type_maps[type];
		if(_.isArray(maps)) {
			type_maps[type].push(map);
		} else {
			type_maps[type] = [map];
		}

		var old_destroy = map.destroy;
		map.destroy = function() {
			if(type_maps[type].length === 1) {
				delete type_maps[type];
			} else {
				var index = type_maps[type].indexOf(map);
				type_maps[type].splice(index, 1);
			}
			old_destroy.apply(map, arguments);
		};
		map.savedType = function() {
			return type;
		};

		return map;
	};

	var storage_prefix = "_",
		type_prefix = "$";

	ist.save = function (root, name, type) {
		if (!_.isString(name)) {
			name = ist.loaded_program_name.get();
			if(!name) {
				var names = ist.ls(),
					original_name = "sketch_"+names.length,
					i = 0;
				name = original_name;

				while(names.indexOf(name)>=0) {
					name = original_name + "_" + i;
					i++;
				}
			}
		}
		if (!_.isString(type)) {
			type = "";
		}
		var storage_name = storage_prefix + name + type_prefix + type;
		var val = ist.stringify(root);
		window.localStorage.setItem(storage_name, val);
		_.each(type_maps[type], function(map) {
			map.item(name, val);
		});

		if(!type) { // program
			ist.setDefaultProgramName(name);
		}
		//console.log("save ", name);

		return name;
	};
	ist.saveAndSetCurrent = function(root, name, type) {
		name = ist.save(root, name, type);
		ist.loaded_program_name.set(name);	
		return name;
	};
	ist.loadString = function(name, type) {
		var storage_name = storage_prefix + name + type_prefix + type;
		return window.localStorage.getItem(storage_name);
	};
	ist.load = function (name, type) {
		if (!_.isString(name)) {
			name = ist.getDefaultProgramName();
			if (!name) {
				return false;
			}
		}
		if (!_.isString(type)) {
			type = "";
		}

		var str = ist.loadString(name, type),
			root;
		if(!str) {
			return false;
		}

		if(ist.__debug) {
			root = ist.destringify(str);

			if(!type) { // program
				ist.loaded_program_name.set(name);	
				ist.setDefaultProgramName(name);
			}

			return root;
		} else {
			try {
				root = ist.destringify(str);

				if(!type) { // program
					ist.loaded_program_name.set(name);	
					ist.setDefaultProgramName(name);
				}

				return root;
			} catch(e) {
				console.error("Error loading " + name + ":");
				console.error(e);
				return false;
			}
		}
	};
	ist.ls = function (type) {
		var len = window.localStorage.length;
		var rv = [];
		var i;
		if (!_.isString(type)) {
			type = "";
		}
		var name_regex = new RegExp("^" + storage_prefix + "(.*)" + "\\" + type_prefix + type + "$");
		var match;
		for (i = 0; i < len; i += 1) {
			var key = window.localStorage.key(i);
			if ((match = key.match(name_regex))) {
				rv.push(match[1]);
			}
		}
		return rv;
	};
	ist.rm = function (name, type) {
		if (!_.isString(name)) {
			name = "default";
		}
		if (!_.isString(type)) {
			type = "";
		}
		var storage_name = storage_prefix + name + type_prefix + type;
		_.each(type_maps[type], function(map) {
			map.remove(name);
		});
		window.localStorage.removeItem(storage_name);
		return ist.ls();
	};
	ist.rename = function(from_name, to_name, type) {
		var old_storage_name = storage_prefix + from_name + type_prefix + type,
			new_storage_name = storage_prefix + to_name   + type_prefix + type,
			change_current = ist.loaded_program_name.get() === from_name;

		if(localStorage.getItem(new_storage_name)) {
			return false;
		} else {
			localStorage.setItem(new_storage_name, localStorage.getItem(old_storage_name));
			localStorage.removeItem(old_storage_name);
			if(change_current) {
				ist.loaded_program_name.set(to_name);
				ist.setDefaultProgramName(to_name);
			}
			_.each(type_maps[type], function(type_map) {
				type_map.item(to_name, type_map.item(from_name));
				type_map.remove(from_name);
			});
		}
	};
	ist.nuke = function () {
		var program_names = ist.ls();
		_.each(program_names, ist.rm);
		_.each(type_maps, function(tm) {
			_.each(tm, function(map) {
				map.clear();
			});
		});
		return ist.ls();
	};

	var default_program_name = "IST_DEFAULT_PROGRAM";
	ist.getDefaultProgramName = function() {
		var rv = localStorage.getItem(default_program_name);
		return rv === null ? false : rv;
	};

	ist.setDefaultProgramName = function(name) {
		window.localStorage.setItem(default_program_name, name);
	};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */


(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var ERROR_TYPE = {
		WARNING: 1,
		ERROR: 2
	};

	ist.Error = (function(My) {
		var proto = My.prototype;

		proto.type = function() { return this.options.type; };
		proto.message = function() { return this.options.message; };

        ist.register_serializable_type("error",
            function (x) {
                return x instanceof My;
            },
            function () {
                return {type: this.type(), message: this.message()};
            },
            function (obj) {
                var rv = new My({type: obj.type, message: obj.message});
                return rv;
            });

		return My;
	}(function(options) {
		this.options = _.extend({
			type: ERROR_TYPE.ERROR,
			message: ""
		}, options);
	}));

	ist.get_prop_name_error = function(name) {
		if(name.length === 0) {
			return "Must be at least one character";
		} else if(name[0].match(/[0-9]/)) {
			return "First letter should not be a number";
		} else if(!name[0].match(/[a-zA-Z_$]/)) {
			return "First character should be a letter";
		} else if(name.match(/\s/)) {
			return "Should not contain spaces";
		} else {
			var invalid_chars = [];
			var char;
			var char_regex = /[0-9a-zA-Z_$]/;
			for(var i = 1; i<name.length; i++) {
				char = name[i];
				if(!char.match(char_regex )) {
					invalid_chars.push(char);
				}
			}


			var invalid_char_str = _.map(invalid_chars, function(char, i) {
				if(i === invalid_chars.length-1) {
					return "and '"+char+"'";
				} else {
					return "'"+char+"'";
				}
			}).join(", ");

			return "Invalid characters: " + invalid_char_str + ".";
		}
	};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.install_proto_builtins = function (proto, builtins) {
		_.each(builtins, function (builtin, name) {
			var getter_name = builtin.getter_name || "get_" + name;
			builtin._get_getter_name = function () { return getter_name; };
			if (_.isFunction(builtin.getter)) {
				proto[getter_name] = function () {
					return builtin.getter.apply(this, ([this._builtins[name]]).concat(_.toArray(arguments)));
				};
			} else if (builtin.gettable !== false) {
				proto[getter_name] = function () {
					return this._builtins[name];
				};
			}

			var setter_name = builtin.setter_name || "set_" + name;
			builtin._get_setter_name = function () {return setter_name; };
			if (_.isFunction(builtin.setter)) {
				proto[setter_name] = function () {
					return builtin.setter.apply(this, ([this._builtins[name]]).concat(_.toArray(arguments)));
				};
			} else if (builtin.settable !== false) {
				proto[setter_name] = function (set_to) {
					this._builtins[name] = set_to;
				};
			}

			var env_name = builtin.env_name || name;
			builtin._get_env_name = function () { return env_name; };
		});
	};

	ist.install_instance_builtins = function (obj, options, constructor) {
		var builtins = constructor.builtins;

		obj._builtins = obj._builtins || {};
		_.each(builtins, function (builtin, name) {
			var setter_name = builtin.setter_name || "set_" + name;
			if (_.isFunction(builtin.start_with)) {
				obj._builtins[name] = builtin.start_with.call(obj);
			}
			if (builtin.settable === false) {
				if (!_.isFunction(builtin.start_with)) {
					if (options && _.has(options, name)) {
						obj._builtins[name] = options[name];
					} else if (_.isFunction(builtin["default"])) {
						obj._builtins[name] = builtin["default"].call(obj);
					}
				}
			} else {
				if (options && _.has(options, name)) {
					obj[setter_name](options[name]);
				} else if (_.isFunction(builtin["default"])) {
					obj[setter_name](builtin["default"].call(obj));
				}
			}
		});
	};

	ist.unset_instance_builtins = function(obj, constructor) {
		var builtins = constructor.builtins;

		_.each(builtins, function (builtin, name) {
			if (_.isFunction(builtin.destroy)) {
				builtin.destroy.call(obj, obj._builtins[name]);
			}
			delete obj._builtins[name];
		});
	};

	var default_hash = function () {
		var rv = "",
			i;
		for (i = 0; i < arguments.length; i += 1) {
			rv += arguments[i].toString();
		}
		return rv;
	};
	var default_equals = function (args1, args2) {
		var i;
		if (args1.length === args2.length) {
			for (i = 0; i < args1.length; i += 1) {
				var arg1 = args1[i],
					arg2 = args2[i];
				if (arg1 !== arg2) {
					return false;
				}
			}
			return true;
		} else {
			return false;
		}
	};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._,
		PROP_NAME_WIDTH = 30,
		PROP_ID_WIDTH = 15,
		PROP_VALUE_WIDTH = 40,
		STATE_NAME_WIDTH = 40,
		STATE_ID_WIDTH = 15,
		TRANSITION_NAME_WIDTH = 60,
		TRANSITION_VALUE_WIDTH = 40,
		STATE_VALUE_WIDTH = 100;

	function pad(str, len) {
		if (str.length > len) {
			return str.substring(0, len - 3) + "...";
		} else if (str.length < len) {
			var rv = str;
			while (rv.length < len) {
				rv += " ";
			}
			return rv;
		} else {
			return str;
		}
	}
	function print_statechart() {
		var last_arg = _.last(arguments),
			statecharts,
			logging_mechanism = console,
			stringified_statecharts,
			include_start;

		
		if (last_arg && !(last_arg instanceof ist.Statechart)) {
			include_start = last_arg;
			statecharts = _.first(arguments, arguments.length - 1);
		} else {
			include_start = false;
			statecharts = _.toArray(arguments);
		}
		stringified_statecharts = _.map(statecharts, function (sc) {
			var id_printed = uid.strip_prefix(sc.id());
			var basis = sc.basis();
			if (basis) {
				id_printed +=  ":" + uid.strip_prefix(sc.basis().id());
			}
			return id_printed;
		}).join(" ");
		logging_mechanism.group("  Statechart " + stringified_statecharts);
		_.each(statecharts, function (statechart) {
			if(!statechart.is_initialized()) {
				logging_mechanism.log("(not initialized)");
				return;
			}
			var flattened_statechart = _.without(statechart.flatten_substates(include_start), statechart);

			var flattened_state_and_transitions = _.flatten(_.map(flattened_statechart, function (statechart) {
				return ([statechart]).concat(statechart.get_outgoing_transitions());
			}), true);

			_.each(flattened_state_and_transitions, function (state) {
				var state_name;

				if (state instanceof ist.State) {
					state_name = pad(state.get_name(), STATE_NAME_WIDTH - 2);
				} else if (state instanceof ist.StatechartTransition) { //transition
					var from = state.from(),
						to = state.to();
					state_name = pad(from.get_name() + "->" + to.get_name(), TRANSITION_NAME_WIDTH - 2);
					state_name = state_name + pad(state.stringify(), TRANSITION_VALUE_WIDTH);
				}

				if (state.is_active()) {
					state_name = "* " + state_name;
				} else {
					state_name = "  " + state_name;
				}

				state_name = pad(uid.strip_prefix(state.id()) + (state.basis() ? ":" + uid.strip_prefix(state.basis().id()) : ""), STATE_ID_WIDTH) + state_name;
				logging_mechanism.log(state_name);
			});
		});
		logging_mechanism.groupEnd();
	}

	function print(current_pointer, logging_mechanism) {
		logging_mechanism = logging_mechanism || console;
		var value_to_value_str = function (val, cobj) {
			var points_at, special_contexts, str, special_contexts_str;
			if (_.isUndefined(val)) {
				return "(undefined)";
			} else if (_.isNull(val)) {
				return "(null)";
			} else if (_.isNumber(val) || _.isBoolean(val)) {
				return val.toString();
			} else if (_.isString(val)) {
				return '"' + val + '"';
			} else if (_.isFunction(val)) {
				return '(func)';
			} else if (_.isElement(val)) {
				return "(dom)";
			} else if (val instanceof ist.StatefulObj) {
				return "(stateful:" + ((cobj && cobj instanceof ist.ContextualObject) ? (uid.strip_prefix(cobj.id())+":") : "") + uid.strip_prefix(val.id()) + ")";
			} else if (val instanceof ist.Dict) {
				return "(dict:" + ((cobj && cobj instanceof ist.ContextualObject) ? (uid.strip_prefix(cobj.id())+":") : "") + uid.strip_prefix(val.id()) + ")";
			} else if (val instanceof ist.Cell) {
				return "(cell:" + uid.strip_prefix(val.id()) + ")";
			} else if (val instanceof ist.StatefulProp) {
				return "(prop:" + uid.strip_prefix(val.id()) + ")";
			} else if (val instanceof ist.ParsedFunction) {
				return "(parsed fn)";
			} else if (val instanceof ist.WrapperClient) {
				return "(" + val.type() + " client wrapper " + val.cobj_id + ")";
			} else if (val instanceof ist.Query) {
				return value_to_value_str(val.value());
			} else if (val instanceof ist.Pointer) {
				points_at = val.points_at();
				special_contexts = val.special_contexts();
				str = value_to_value_str(points_at);
				special_contexts_str = _.map(special_contexts, function (sc) { return sc.id().toString(); }).join(",");

				if (special_contexts.length > 0) {
					str = str + " " + special_contexts_str;
				}

				return str;
			} else if (val instanceof ist.ContextualObject) {
				var ptr = val.get_pointer();
				points_at = ptr.points_at();
				special_contexts = ptr.special_contexts();
				str = value_to_value_str(points_at, val);
				special_contexts_str = _.map(special_contexts, function (sc) { return sc.id().toString(); }).join(",");

				if (special_contexts.length > 0) {
					str = str + " " + special_contexts_str;
				}

				return str;
			} else if (val instanceof ist.CopyContext) {
				return val.id();
			} else if (_.isArray(val)) {
				return ("[" + _.map(val, function (v) { return value_to_value_str(v); }).join(", ") + "]");
			} else if (cjs.isArrayConstraint(val)) {
				var array_got = val.toArray();
				return "$" + value_to_value_str(array_got);
			} else {
				return ("{ " + _.map(val, function (v, k) {
					return k + ": " + v;
				}).join(", ") + " }");
			}
		};

		var value_to_source_str = function (val) {
			if (_.isUndefined(val)) {
				return "(undefined)";
			} else if (_.isNull(val)) {
				return "(null)";
			} else if (_.isString(val)) {
				return '"' + val + '"';
			} else if (_.isNumber(val) || _.isBoolean(val)) {
				return val.toString();
			} else if (_.isFunction(val)) {
				return 'function () {...}';
			} else if (val instanceof ist.Dict) {
				return "";
			} else if (val instanceof ist.Cell) {
				return "=(" + uid.strip_prefix(val.id()) + ")= " + val.get_str();
			} else {
				return val.toString();
			}
		};

		var tablify = function (contextual_object) {
			if (contextual_object instanceof ist.ContextualDict) {
				if (contextual_object instanceof ist.ContextualStatefulObj) {
					var statecharts = contextual_object.get_statecharts();
					print_statechart.apply(this, (statecharts).concat(logging_mechanism));
				}
				var children = contextual_object.children();
				_.each(children, function (child_info) {
					var c_arr;
					var value = child_info.value;

					var is_manifestations;
					if (value instanceof ist.ContextualDict) {
						is_manifestations = value.is_template();
					} else {
						is_manifestations = false;
					}

					if (is_manifestations) {
						c_arr = value.instances();
						console.group("(" + c_arr.length + " manifestations)");
					} else {
						c_arr = [value];
					}

					var prop_name = child_info.name;
					var is_inherited = child_info.inherited;
					_.each(c_arr, function (child) {
						var prop_pointer = child instanceof ist.ContextualObject ? child.get_pointer() : false;
						var prop_points_at = prop_pointer ? prop_pointer.points_at() : child;
						var is_expanded = prop_points_at && current_pointer.has(prop_points_at);
						var is_pointed_at = prop_pointer && current_pointer.eq(prop_pointer);
						var prop_text = prop_name;

						if (is_inherited) {
							prop_text = prop_text + " (i)";
						}

						if (is_pointed_at) {
							prop_text = "> " + prop_text;
						} else {
							prop_text = "  " + prop_text;
						}

						if (prop_points_at instanceof ist.StatefulProp) {
							prop_text = pad(prop_text, PROP_NAME_WIDTH);
							prop_text = prop_text + pad("(" + (child instanceof ist.ContextualObject ? (uid.strip_prefix(child.id())+":"):"") + uid.strip_prefix(prop_points_at.id()) + ")", PROP_ID_WIDTH);
						} else {
							prop_text = pad(prop_text, PROP_NAME_WIDTH + PROP_ID_WIDTH);
						}

						var pp_val = child instanceof ist.ContextualObject ? child.val() : child;
						prop_text = pad(prop_text + value_to_value_str(pp_val), PROP_NAME_WIDTH + PROP_ID_WIDTH + PROP_VALUE_WIDTH);

						if ((prop_points_at instanceof ist.Dict) || (prop_points_at instanceof ist.StatefulProp)) {
							logging_mechanism[is_expanded ? "group" : "groupCollapsed"](prop_text);
							tablify(child);
							logging_mechanism.groupEnd();
						} else {
							logging_mechanism.log(prop_text + value_to_source_str(prop_points_at));
						}

						if (prop_name === "protos") {
							var actual_val = contextual_object.get_all_protos();
							var actual_text = pad("  inherits from", PROP_NAME_WIDTH + PROP_ID_WIDTH) + "[" +
								_.map(actual_val, function (av) {
									return value_to_value_str(av);
								}).join(", ") + "]";
							logging_mechanism.log(actual_text);
						}
					});
					if (is_manifestations) {
						console.groupEnd();
					}
				});
			} else if (contextual_object instanceof ist.ContextualStatefulProp) {
				var value_specs = contextual_object.get_values();
				_.each(value_specs, function (value_spec) {
					var value = value_spec.value;
					var source_str = value_to_source_str(value);

					var state = value_spec.state;
					var state_name;
					if (state) {
						if (state instanceof ist.State) {
							state_name = pad(state.get_name(), STATE_NAME_WIDTH - 2);
						} else if (state instanceof ist.StatechartTransition) { //transition
							var from = state.from(),
								to = state.to();
							state_name = pad(from.get_name() + "->" + to.get_name(), STATE_NAME_WIDTH - 2);
						}

						if (value_spec.active) {
							state_name = "*" + state_name;
						} else {
							state_name = " " + state_name;
						}

						if (value_spec.using) {
							state_name = "*" + state_name;
						} else {
							state_name = " " + state_name;
						}

						state_name = pad(uid.strip_prefix(state.id()), STATE_ID_WIDTH) + state_name;
					} else {
						state_name = pad("", STATE_ID_WIDTH + STATE_NAME_WIDTH);
					}
					var value_for_state = value_spec.value;
					var row = state_name + value_to_source_str(value_for_state);
					logging_mechanism.log(row);
				});
			}
		};

		var root = current_pointer.points_at(0);
		var root_str;
		if (current_pointer.points_at() === root) {
			root_str = ">" + ist.root_name;
		} else {
			root_str = ist.root_name;
		}
		var contextual_root = ist.find_or_put_contextual_obj(root);

		logging_mechanism.log(pad(root_str, PROP_NAME_WIDTH)  + value_to_value_str(root, contextual_root));

		tablify(contextual_root);

		return "ok...";
	}

	ist.print = print;
	ist.print_statechart = print_statechart;
}(interstate));

/*jslint evil:true,nomen: true, vars: true, bitwise:true */
/*global interstate,esprima,able,uid,console,window */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._,
		esprima = window.esprima,
		destroy_if_constraint = function(x, silent) {
			if(cjs.isConstraint(x)) {
				x.destroy(silent);
			}
		},
		set_destroy = function(x, func) {
			if(cjs.isConstraint(x)) {
				var old_destroy = x.destroy;
				x.destroy = function() {
					func.apply(x, arguments);
					old_destroy.apply(x, arguments);
				};
			}
		};

	ist.construct = function(constructor, args) {
		if(constructor === Date) { // Functions check to see if date object
			var rv = eval("new constructor(" + args.join(",") + ")");
			return rv;
		}
		function F() {
			return constructor.apply(this, args);
		}
		F.prototype = constructor.prototype;
		return new F();
	};

	ist.MultiExpression = function(expressions) {
		this.expressions = expressions;
	};

	(function(My) {
		var proto = My.prototype;
		proto.get_expressions = function() {
			return this.expressions;
		};
		proto.first = function() {
			return _.first(this.expressions);
		};
		proto.rest = function() {
			return _.rest(this.expressions);
		};
		proto.last = function() {
			return _.last(this.expressions);
		};
	}(ist.MultiExpression));

	ist.on_event = function (event_type, arg1, arg2) {
		if (event_type === "timeout") {
			//console.log(arg1);
			var timeout_event = new ist.TimeoutEvent(arg1);
			return timeout_event;
		} else if(event_type === "time") {
			var time_event = new ist.TimeEvent(arg1);
			return time_event;
		} else if(event_type === "frame") {
			var frame_event = new ist.FrameEvent();
			return frame_event;
		} else if(event_type === "cross") {
			var target = arg1,
				min_velocity = arg2,
				cross_event = new ist.CrossEvent(target, min_velocity);

			return cross_event;
		} else if(event_type === "collision") {
			var	targs_a = arg1,
				targs_b = arg2,
				collision_event = new ist.CollisionEvent(targs_a, targs_b);

			return collision_event;
		} else {
			var targets = _.rest(arguments);
			var events = [];

			if (targets) {
				var statechart_spec = event_type;
				var statechart_event = new ist.TransitionEvent(targets, statechart_spec);
				events.push(statechart_event);

				if (arguments.length <= 1) { // Ex: on('mouseup') <-> on('mouseup', window)
					targets = window;
				}
				var ist_event_type = event_type;
				var ist_event = new ist.IstObjEvent(ist_event_type, targets);
				events.push(ist_event);
			}
			if (arguments.length <= 1) { // Ex: on('mouseup') <-> on('mouseup', window)
				targets = window;
			}
			var dom_event = new ist.DOMEvent(event_type, targets);
			events.push(dom_event);

			return new ist.CombinationEvent(events);
		}
	};

	ist.register_serializable_type("ist_on_event_func",
		function (x) {
			return x === ist.on_event;
		},
		function () {
			return {};
		},
		function (obj) {
			return ist.on_event;
		});

	ist.binary_operators = {
		"===":	function (a, b) { return ist.check_contextual_object_equality_eqeqeq(a, b); },
		"!==":	function (a, b) { return !ist.check_contextual_object_equality_eqeqeq(a, b); },
		"==":	function (a, b) { return ist.check_contextual_object_equality_eqeqeq(a, b); },
		"!=":	function (a, b) { return !ist.check_contextual_object_equality_eqeqeq(a, b); },
		">":	function (a, b) { return a > b; },
		">=":	function (a, b) { return a >= b; },
		"<":	function (a, b) { return a < b; },
		"<=":	function (a, b) { return a <= b; },
		"+":	function (a, b) { return a + b; },
		"-":	function (a, b) { return a - b; },
		"*":	function (a, b) { return a * b; },
		"/":	function (a, b) { return a / b; },
		"%":	function (a, b) { return a % b; },
		"&&":	function (a, b) { return a && b; },
		"||":	function (a, b) { return a || b; },
		"&":	function (a, b) { return a & b; },
		"|":	function (a, b) { return a | b; },
		"^":	function (a, b) { return a ^ b; },
		"<<":	function (a, b) { return a << b; },
		">>":	function (a, b) { return a >> b; },
		">>>":  function (a, b) { return a >>> b; },
		"in":	function (a, b) { return a in b; },
		"instanceof":	function (a, b) { return a instanceof b; }
	};
	ist.unary_operators = {
		"-":	function (a) { return -a; },
		"!":	function (a) { return !a; },
		"~":	function (a) { return ~a; },
		"typeof":	function (a) { return typeof a; }
	};

	var destroy_constraint_fn = cjs.Constraint.prototype.destroy;

	var get_op_val = function (options, calling_context, op) {
		var pcontext = options.context,
			args = _.rest(arguments, 3);
		if (options.get_constraint) {
			var constraint = cjs(function () {
				var op_got = cjs.get(op, options.auto_add_dependency),
					args_got = _.map(args, function(arg) {
													return cjs.get(arg, options.auto_add_dependency);
												}),
					calling_context_got = cjs.get(calling_context, options.auto_add_dependency),
					rv;

				if(op_got === ist.find_fn) {
					// Give it the context of root
					rv = op_got.apply(pcontext, args_got);
					return rv;
				} else if (_.isFunction(op_got)) {
					rv = op_got.apply(calling_context_got, args_got);
					return rv;
				} else if (op_got instanceof ist.ParsedFunction) {
					return op_got._apply(calling_context_got, pcontext, args_got, options);
				} else {
					throw new Error("Calling a non-function");
					//return undefined;
				}
			});
			constraint.destroy = function() {
				destroy_constraint_fn.apply(this, arguments);
			};
			return constraint;
		} else {
			if (_.isFunction(op)) {
				return op.apply(calling_context, args);
			} else if (op instanceof ist.ParsedFunction) {
				return op._apply(calling_context, pcontext, args);
			} else {
				throw new Error("Calling a non-function");
				//return undefined;
			}
		}
	};

	var AND_OP = 0, OR_OP = 1;
	var get_logical_val = function (op, left, right, options) {
		if (options.get_constraint) {
			var op_id;
			if (op === "&&") {
				op_id = AND_OP;
			} else if (op === "||") {
				op_id = OR_OP;
			} else {
				console.error("Unknown op " + op);
			}
			var constraint = cjs(function () {
				switch (op_id) {
				case AND_OP:
					return cjs.get(left, options.auto_add_dependency) && cjs.get(right, options.auto_add_dependency);
				case OR_OP:
					return cjs.get(left, options.auto_add_dependency) || cjs.get(right, options.auto_add_dependency);
				}
			});
			constraint.destroy = function() {
				destroy_constraint_fn.apply(this, arguments);
			};
			return constraint;
		} else {
			if (op === "&&") {
				return left && right;
			} else if (op === "||") {
				return left || right;
			} else {
				console.error("Unknown op " + op);
			}
		}
	};

	var get_conditional_val = function (test, consequent, alternate, options) { // test ? consequent : alternate
		if (options.get_constraint) {
			var constraint = cjs(function () {
				var test_got = cjs.get(test, options.auto_add_dependency);
				if (test_got) {
					return cjs.get(consequent, options.auto_add_dependency);
				} else {
					return cjs.get(alternate, options.auto_add_dependency);
				}
			});
			constraint.destroy = function() {
				destroy_constraint_fn.apply(this, arguments);
			};
			return constraint;
		} else {
			if (test) {
				return consequent;
			} else {
				return alternate;
			}
		}
	};

	var IDENTIFIER = {
		COBJ_ROOT: ist.root_name,
		JS_ROOT: "window",
		CONTAINER: "container",
		PROTO_THIS: "$this",
		ROOT_THIS: "$$this"
	};

	var get_identifier_val = function (key, options) {
		var context = options.context,
			ignore_inherited_in_contexts = options.ignore_inherited_in_contexts || [],
			cobj;

		if (key === IDENTIFIER.COBJ_ROOT) {
			return ist.find_or_put_contextual_obj(context.root(), context.slice(0, 1));
		} else if (key === IDENTIFIER.JS_ROOT) {
			return window;
		} else if(key === IDENTIFIER.PROTO_THIS || key === IDENTIFIER.ROOT_THIS) {
			cobj = options.inherited_from_cobj;

			if(cobj) {
				if (key === IDENTIFIER.PROTO_THIS) {
					context = cobj.get_pointer();
				} else if (key === IDENTIFIER.ROOT_THIS) {
					do {
						context = cobj;
						cobj = cobj.is_inherited();
					} while(cobj);
					
					context = context.get_pointer();
				}
				return get_this_val(_.extend({}, options, {
					context: context
				}));
			} else {
				return get_this_val(options);
			}
		}

		var getter = function () {
			var i, curr_context, context_item, rv;
			if (key === IDENTIFIER.CONTAINER) {
				var found_this = false;
				curr_context = context;
				context_item = curr_context.points_at();

				while (!curr_context.is_empty()) {
					if (context_item instanceof ist.Dict) {
						if (found_this) {
							rv = ist.find_or_put_contextual_obj(context_item, curr_context);
							return rv;
						} else {
							found_this = true;
						}
					}
					curr_context = curr_context.pop();
					context_item = curr_context.points_at();
				}
			}

			curr_context = context;
			context_item = curr_context.points_at();
				
			while (!curr_context.is_empty()) {
				if (context_item instanceof ist.Dict) {
					var contextual_obj = ist.find_or_put_contextual_obj(context_item, curr_context);
					if (contextual_obj.has(key, _.indexOf(ignore_inherited_in_contexts, context_item)>=0)) {
						rv = contextual_obj.prop_val(key);
						return rv;
					}
				} else if (context_item instanceof ist.ProvisionalContext) {
					if(context_item.has(key)) {
						return context_item.get(key);
					}
				}

				if(curr_context.has_special_contexts()) {
					var special_contexts = curr_context.special_contexts();
					var len = special_contexts.length;
					for (i = 0; i < len; i += 1) {
						var sc = special_contexts[i];
						var context_obj = sc.get_context_obj();
						if (context_obj.hasOwnProperty(key)) {
							return cjs.get(context_obj[key].value);
						}
					}
				}
					
				curr_context = curr_context.pop();
				context_item = curr_context.points_at();
			}
			if (window.hasOwnProperty(key)) {
				return window[key];
			} else {
				throw new Error("Could not find variable '" + key + "'");
				//return undefined;
			}
		};

		if (options.get_constraint) {
			var constraint = cjs(getter);
			constraint.destroy = function() {
				context = false;
				destroy_constraint_fn.apply(this, arguments);
			};
			return constraint;
		} else {
			return getter();
		}
	};

	var get_this_val = function (options) {
		var context = options.context;
		var getter = function () {
			var curr_context = context;
			var context_item = curr_context.points_at();

			while (!curr_context.is_empty()) {
				if (context_item instanceof ist.Dict) {
					var contextual_obj = ist.find_or_put_contextual_obj(context_item, curr_context);
					return contextual_obj;
				}
				curr_context = curr_context.pop();
				context_item = curr_context.points_at();
			}

			throw new Error("Could not find this");
			//return undefined;
		};
		if (options.get_constraint) {
			var constraint = cjs(getter);
			constraint.destroy = function() {
				destroy_constraint_fn.apply(this, arguments);
			};
			return constraint;
		} else {
			return getter();
		}
	};

	var get_member_val = function (obj, prop, options) {
		var getter = function (object, property) {
			var rv, instances;
			if (!object) {
				//throw new Error("No parent object for property '" + prop + "'");
				return undefined;
			}


			if (object instanceof ist.ContextualObject) {
				if (property === "container") {
					var found_this = false;
					var curr_context = object.get_pointer();
					var context_item = curr_context.points_at();

					while (!curr_context.is_empty()) {
						if (context_item instanceof ist.Dict) {
							if (found_this) {
								rv = ist.find_or_put_contextual_obj(context_item, curr_context);
								return rv;
							} else {
								found_this = true;
							}
						}
						curr_context = curr_context.pop();
						context_item = curr_context.points_at();
					}
				} else if (object.is_template && object.is_template()) {
					if( _.isNumber(property)) {
						instances = object.instances();
						if(instances.hasOwnProperty(property)) {
							return instances[property];
						} else {
							throw new Error("No such property '" + property + "'");
						}
					} else if(property === "length") {
						instances = object.instances();
						return instances.length;
					}
				}
				rv = object.prop_val(property);

				if(rv === undefined && !object.has(property)) {
					throw new Error("No such property '" + property + "'");
				}
				return rv;
			} else if(cjs.isArrayConstraint(object)) {
				if(_.isNumber(property)) {
					return object.item(property);
				} else {
					if(property === "length") {
						return object.length();
					}
				}
			} else if(cjs.isMapConstraint(object)) {
				return object.get(property);
			} else {
				return object[property];
			}
		};

		if (options.get_constraint) {
			var constraint = cjs(function () {
				var object = cjs.get(obj, options.auto_add_dependency),
					property = cjs.get(prop, options.auto_add_dependency);
				return getter(object, property);
			});
			constraint.destroy = function() {
				destroy_constraint_fn.apply(this, arguments);
			};
			return constraint;
		} else {
			return getter(obj, prop);
		}
	};

	var get_array_val = function (elements, options) {
		if (options.get_constraint) {
			var constraint = cjs(function () {
				return _.map(elements, function (element) {
					return cjs.get(element, options.auto_add_dependency);
				});
			});
			constraint.destroy = function() {
				destroy_constraint_fn.apply(this, arguments);
			};
			return constraint;
		} else {
			return elements;
		}
	};

	var get_new_$ = function (options, calling_context, op) {
		var pcontext = options.context;
		var args = _.rest(arguments, 3);
		if (options.get_constraint) {
			var constraint = cjs(function () {
				var op_got = cjs.get(op, options.auto_add_dependency);
				var args_got = _.map(args, function(arg) {
													return cjs.get(arg, options.auto_add_dependency);
												});
				//window.dbg = false;
				var calling_context_got = cjs.get(calling_context, options.auto_add_dependency);

				if (_.isFunction(op_got)) {
					var rv = ist.construct.call(calling_context_got, op_got, args_got);
					return rv;
				} else if (op_got instanceof ist.ParsedFunction) {
					return op_got._apply(calling_context_got, pcontext, args_got, options);
				} else {
					throw new Error("Calling a non-function");
					//return undefined;
				}
			});
			constraint.destroy = function() {
				destroy_constraint_fn.apply(this, arguments);
			};
			return constraint;
		} else {
			if (_.isFunction(op)) {
				var rv = ist.construct.call(calling_context, op, args);
				return rv;
			} else if (op instanceof ist.ParsedFunction) {
				return op._apply(calling_context, pcontext, args);
			} else {
				throw new Error("Calling a non-function");
				//return undefined;
			}
		}
	};

	var get_val = ist.get_parsed_val = function (node, options) {
		var op_func, left_arg, right_arg, arg, callee, op_context, args, rv, object, property;
		if (!node) {
			return undefined;
		}
		var type = node.type;
		if (type === "ExpressionStatement") {
			rv = get_val(node.expression, options);
		} else if (type === "Literal") {
			rv = node.value;
		} else if (type === "BinaryExpression") {
			op_func = ist.binary_operators[node.operator];
			left_arg = get_val(node.left, options);
			right_arg = get_val(node.right, options);
			rv = get_op_val(options, window, op_func, left_arg, right_arg);
			set_destroy(rv, function(silent) {
				destroy_if_constraint(left_arg, silent);
				destroy_if_constraint(right_arg, silent);
			});
		} else if (type === "UnaryExpression") {
			op_func = ist.unary_operators[node.operator];
			arg = get_val(node.argument, options);
			rv = get_op_val(options, window, op_func, arg);
			set_destroy(rv, function(silent) {
				destroy_if_constraint(arg, silent);
			});
		} else if (type === "CallExpression") {
			var node_callee = node.callee;
			if (node_callee.type === "MemberExpression") {
				object = op_context = get_val(node_callee.object, options);
				property = node_callee.computed ? get_val(node_callee.property, options) : node_callee.property.name;

				callee = get_member_val(object, property, options);
				set_destroy(callee, function(silent) {
					destroy_if_constraint(object, silent);
					destroy_if_constraint(property, silent);
				});
			} else {
				callee = get_val(node_callee, options);
				op_context = window;
			}

			args = _.map(node["arguments"], function (arg) {
				return get_val(arg, options);
			});
			rv = get_op_val.apply(this, ([options, op_context, callee]).concat(args));

			set_destroy(rv, function(silent) {
				destroy_if_constraint(callee, silent);
				_.each(args, function(arg) {
					destroy_if_constraint(arg, silent);
				});
			});
		} else if (type === "Identifier") {
			rv = get_identifier_val(node.name, options);
		} else if (type === "ThisExpression") {
			rv = get_this_val(options);
		} else if (type === "MemberExpression") {
			object = get_val(node.object, options);
			property = node.computed ? get_val(node.property, options) : node.property.name;

			rv = get_member_val(object, property, options);
			set_destroy(rv, function(silent) {
				destroy_if_constraint(object, silent);
				destroy_if_constraint(property, silent);
			});
		} else if (type === "ArrayExpression") {
			var elements = _.map(node.elements, function (element) {
				return get_val(element, options);
			});
			rv = get_array_val(elements, options);
			set_destroy(rv, function(silent) {
				_.each(elements, function(elem) {
					destroy_if_constraint(elem, silent);
				});
			});
		} else if (type === "ConditionalExpression") {
			var test = get_val(node.test, options),
				consequent = get_val(node.consequent, options),
				alternate = get_val(node.alternate, options);
			rv = get_conditional_val(test, consequent, alternate, options);

			set_destroy(rv, function(silent) {
				destroy_if_constraint(test, silent);
				destroy_if_constraint(consequent, silent);
				destroy_if_constraint(alternate, silent);
			});
		} else if (type === "LogicalExpression") {
			left_arg = get_val(node.left, options);
			right_arg = get_val(node.right, options);
			rv = get_logical_val(node.operator, left_arg, right_arg, options);
			set_destroy(rv, function(silent) {
				destroy_if_constraint(left_arg, silent);
				destroy_if_constraint(right_arg, silent);
			});
		} else if (type === "FunctionExpression") {
			rv = ist.get_fn_$(node, options);
		} else if (type === "NewExpression") {
			callee = get_val(node.callee, options);
			op_context = window;
			if (node.callee.type === "MemberExpression") {
				op_context = get_val(node.callee.object, options);
			}
			args = _.map(node["arguments"], function (arg) {
				return get_val(arg, options);
			});
			rv = get_new_$.apply(this, ([options, op_context, callee]).concat(args));

			set_destroy(rv, function(silent) {
				destroy_if_constraint(callee, silent);
				destroy_if_constraint(op_context, silent);

				_.each(args, function(arg) {
					destroy_if_constraint(arg, silent);
				});
			});
		} else if (type === "ObjectExpression") {
			rv = {};
			_.each(node.properties, function (prop_node) {
				var key = prop_node.key.name,
					value = get_val(prop_node.value, options);
				rv[key] = value;
			});
		} else if (type === "Program") {
			if(node.body.length === 0) {
				rv = null;
			} else if(node.body.length === 1) {
				rv = get_val(node.body[0], options);
			} else {
				rv = new ist.MultiExpression(_.map(node.body, function(bodyi, i) {
					if(!options.only_parse_first || i === 0) {
						return get_val(bodyi, options);
					} else {
						return bodyi;
					}
				}));
			}
		} else {
			console.log(type, node);
		}
		return rv;
	};

	ist.get_parsed_$ = function (node, options) {
		var parsed_value = ist.get_parsed_val(node, _.extend({
			get_constraint: true,
			auto_add_dependency: true
		}, options));
		return parsed_value;
	};

	var func_regex = new RegExp("^\\s*function\\s*\\((\\s*[a-zA-Z$][\\w\\$]*\\s*,)*\\s*([a-zA-Z$][\\w\\$]*\\s*)?\\)\\s*{.*}\\s*$");
	var block_regex = new RegExp("^\\s*{.*}\\s*$");

	ist.parse = function (str) {
		if ((str.replace(/\n/g, "")).match(func_regex) || str.match(block_regex)) {
			str = "(" + str + ")";
		}

		try {
			return esprima.parse(str);
		} catch(e) {
			return new ist.Error({
				message: e.description
			});
		}
	};
}(interstate));

/*jslint nomen: true, vars: true, bitwise:true, debug:true */
/*global interstate,esprima,able,uid,console,window */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var do_return = {},
		do_break = {},
		do_continue = {};

	var assignments = {
		"=": function (a, b) { return b; },
		"+=": function (a, b) { return a + b; },
		"-=": function (a, b) { return a - b; },
		"*=": function (a, b) { return a * b; },
		"/=": function (a, b) { return a / b; },
		"|=": function (a, b) { return a | b; },
		"&=": function (a, b) { return a & b; },
		"^=": function (a, b) { return a ^ b; }
	};

	var call_fn = function (node, options) {
		var i, var_map, op_func, rv, test, body, prop, object,
			found_this, curr_context, context_item, id, op_context,
			args;
		if (!node) { return undefined; }
		var type = node.type;
		if (type === "BlockStatement") {
			var len = node.body.length;
			for (i = 0; i < len; i += 1) {
				var statement = node.body[i];
				rv = call_fn(statement, options);
				if (rv === do_return || rv === do_break || rv === do_continue) {
					return rv;
				}
			}
		} else if (type === "VariableDeclaration") {
			var_map = options.var_map;
			_.each(node.declarations, function (declaration) {
				var id = declaration.id.name,
					init = call_fn(declaration.init, options);
				// Do some cleanup here
				var old_value = var_map[id];
				if (old_value && cjs.isConstraint(old_value)) {
					old_value.destroy();
				}
				var_map[id] = init;
			});
			return;
		} else if (type === "Literal") {
			return node.value;
		} else if (type === "ExpressionStatement") {
			return call_fn(node.expression, options);
		} else if (type === "AssignmentExpression") {
			var left = node.left,
				right_val = call_fn(node.right, options);
			var_map = options.var_map;

			if (left.type === "Identifier") {
				id = left.name;
				var old_value = var_map[id];
				if (old_value && cjs.isConstraint(old_value)) {
					old_value.destroy();
				}
				var_map[id] = assignments[node.operator](old_value, right_val);
			} else if (left.type === "MemberExpression") {
				object = call_fn(left.object, options);
				if (left.computed) {
					prop = call_fn(left.property, options);
				} else {
					prop = left.property.name;
				}
				object[prop] = right_val;
			} else {
				console.error("Unset");
			}
		} else if (type === "BinaryExpression") {
			op_func = ist.binary_operators[node.operator];
			var left_arg = call_fn(node.left, options),
				right_arg = call_fn(node.right, options);
			return op_func.call(window, left_arg, right_arg);
		} else if (type === "UnaryExpression") {
			op_func = ist.unary_operators[node.operator];
			var arg = call_fn(node.argument, options);
			return op_func.call(window, arg);
		} else if (type === "Identifier") {
			var key = node.name;
			if (key === ist.root_name) {
				return ist.find_or_put_contextual_obj(options.pcontext.root(), options.pcontext.slice(0, 1));
			} else if (key === "container") {
				found_this = false;
				curr_context = options.pcontext;
				context_item = curr_context.points_at();

				while (!curr_context.is_empty()) {
					if (context_item instanceof ist.Dict) {
						if (found_this) {
							rv = ist.find_or_put_contextual_obj(context_item, curr_context);
							return rv;
						} else {
							found_this = true;
						}
					}
					curr_context = curr_context.pop();
					context_item = curr_context.points_at();
				}
			} else if (_.has(options.var_map, key)) {
				return cjs.get(options.var_map[key], options.auto_add_dependency);
			} else {
				return ist.get_parsed_val(node, {context: options.pcontext});
			}
		} else if (type === "ReturnStatement") {
			options.rv = call_fn(node.argument, options);
			return do_return;
		} else if (type === "IfStatement") {
			if (call_fn(node.test, options)) {
				return call_fn(node.consequent, options);
			} else {
				return call_fn(node.alternate, options);
			}
		} else if (type === "WhileStatement") {
			test = node.test;
			body = node.body;
			while (call_fn(test, options)) {
				rv = call_fn(body, options);
				if (rv === do_return) {
					return rv;
				} else if (rv === do_break) {
					break;
				}
			}
		} else if (type === "ForStatement") {
			var init = node.init,
				update = node.update;
			
			body = node.body;
			test = node.test;

			for (call_fn(init, options); call_fn(test, options); call_fn(update, options)) {
				rv = call_fn(body, options);
				if (rv === do_return) {
					return rv;
				} else if (rv === do_break) {
					break;
				}
			}
		} else if (type === "DoWhileStatement") {
			test = node.test;
			body = node.body;
			do {
				rv = call_fn(body, options);
				if (rv === do_return) {
					return rv;
				} else if (rv === do_break) {
					break;
				}
			} while (call_fn(test, options));
		} else if (type === "ConditionalExpression") {
			return call_fn(node.test, options) ? call_fn(node.consequent, options) : call_fn(node.alternate, options);
		} else if (type === "MemberExpression") {
			object = call_fn(node.object, options);
			if (node.computed) {
				prop = call_fn(node.property, options);
			} else {
				prop = node.property.name;
				if (object instanceof ist.ContextualObject && prop === "parent") {
					found_this = false;
					curr_context = object.get_pointer();
					context_item = curr_context.points_at();

					while (!curr_context.is_empty()) {
						if (context_item instanceof ist.Dict) {
							if (found_this) {
								rv = ist.find_or_put_contextual_obj(context_item, curr_context);
								return rv;
							} else {
								found_this = true;
							}
						}
						curr_context = curr_context.pop();
						context_item = curr_context.points_at();
					}
				}
			}
			if (object instanceof ist.ContextualObject) {
				if (object.is_template && object.is_template()) {
					var instances;
					if( _.isNumber(prop)) {
						instances = object.instances();
						if(instances.hasOwnProperty(prop)) {
							return instances[prop];
						} else {
							throw new Error("No such property '" + prop+ "'");
						}
					} else if(prop=== "length") {
						instances = object.instances();
						return instances.length;
					}
				}
				return object.prop_val(prop);
			} else {
				if(object) {
					return object[prop];
				}
			}
		} else if (type === "CallExpression") {
			op_context = window;
			if (node.callee.type === "MemberExpression") {
				op_context = call_fn(node.callee.object, options);
			}
			op_func = call_fn(node.callee, options);
			args = _.map(node["arguments"], function (arg) {
				return call_fn(arg, options);
			});
			if (_.isFunction(op_func)) {
				return op_func.apply(op_context, args);
			} else if (op_func instanceof ist.ParsedFunction) {
				return op_func._apply(options.js_context, options.pcontext, args);
			}
		} else if (type === "LogicalExpression") {
			var op = node.operator;
			if (op === "&&") {
				return call_fn(node.left, options) && call_fn(node.right, options);
			} else if (op === "||") {
				return call_fn(node.left, options) || call_fn(node.right, options);
			} else {
				console.log("No op " + op);
			}
		} else if (type === "UpdateExpression") {
			var value = call_fn(node.argument, options);
			var operator = node.operator;
			var resulting_value;
			if (operator === "++") {
				resulting_value = value + 1;
			} else if (operator === "--") {
				resulting_value = value - 1;
			} else {
				console.error("Unknown operator ", operator);
			}

			if (node.argument.type === "Identifier") {
				id = node.argument.name;
				options.var_map[id] = resulting_value;
			} else {
				console.error("Unset");
			}

			if (node.prefix) {
				return value;
			} else {
				return resulting_value;
			}
		} else if (type === "ThisExpression") {
			return options.js_context;
		} else if (type === "BreakStatement") {
			return do_break;
		} else if (type === "ContinueStatement") {
			return do_continue;
		} else if (type === "NewExpression") {
			op_context = window;
			if (node.callee.type === "MemberExpression") {
				op_context = call_fn(node.callee.object, options);
			}
			op_func = call_fn(node.callee, options);
			args = _.map(node["arguments"], function (arg) {
				return call_fn(arg, options);
			});
			if (_.isFunction(op_func)) {
				return ist.construct(op_func, args);
			} else if (op_func instanceof ist.ParsedFunction) {
				console.error("unhandled case");
			}
		} else if (type === "ObjectExpression") {
			rv = {};
			_.each(node.properties, function (prop_node) {
				var key = prop_node.key.name,
					value = call_fn(prop_node.value, options);
				rv[key] = value;
			});
			return rv;
		} else if (type === "DebuggerStatement") {
			debugger;
		} else if (type !== "EmptyStatement") {
			// do nothing
			return;
		} else {
			console.log(type, node);
		}
	};

	ist.ParsedFunction = function (node, options) {
		this.node = node;
		this.options = options;
	};

	(function (my) {
		var proto = my.prototype;
		proto._apply = function (js_context, pcontext, args, options) {
			var node = this.node;

			var var_map = {};
			var_map["arguments"] = args;
			_.each(node.params, function (param, index) {
				var name = param.name;
				var value = args[index];
				var_map[name] = value;
			});

			var opts = {
				var_map: var_map,
				js_context: js_context,
				pcontext: pcontext,
				ignore_inherited_in_contexts: this.options.ignore_inherited_in_contexts,
				auto_add_dependency: options && options.auto_add_dependency
			};
			var rv = call_fn(node.body, opts);
			if (rv === do_return) {
				return opts.rv;
			} else {
				return undefined;
			}
		};
		proto._call = function (js_context, pcontext) {
			return this._apply.apply(this, [js_context, pcontext, _.rest(arguments, 2)]);
		};
	}(ist.ParsedFunction));

	ist.get_fn_$ = function (node, options) {
		return new ist.ParsedFunction(node, options);
	};
}(interstate));

/*jslint nomen: true, vars: true, white: true */
/*jshint scripturl: true */
/*global interstate,esprima,able,uid,console,window,jQuery,Raphael,RedMap */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var removeIndex = function(arr, i) { arr.splice(i, 1); },
		eqeqeq = function(a,b) { return a === b; };

	// Compute the differences between two objects
	ist.get_map_diff = function(from_keys, to_keys, from_vals, to_vals, key_eq_check, val_eq_check) {
		var key_diff = cjs.arrayDiff(from_keys, to_keys, key_eq_check),
			set = [], unset = [], key_change = [], value_change = [], index_changed = [], moved = [],

			i = 0, j, mapping = key_diff.mapping, mapping_len = mapping.length,
			mi, from,from_item,item,to,to_item, old_val, new_val, set_len, unset_len, si, ui;

		val_eq_check = val_eq_check || eqeqeq;

		while(i < mapping_len) {
			mi = mapping[i];
			if(!_.has(mi, 'from')) { // added
				to = mi.to;
				to_item = mi.to_item;

				new_val = to_vals[to];

				set.push({ key: to_item, value: new_val, to: to});
			} else if(!_.has(mi, 'to')) { // removed
				from = mi.from;
				from_item = mi.from_item;

				old_val = from_vals[from];
				unset.push({key: from_item, value: old_val, from: from});
			} else {
				from = mi.from;
				to = mi.to;
				from_item = mi.from_item;
				to_item = mi.to_item;

				old_val = from_vals[from];
				new_val = to_vals[to];
				
				if(!val_eq_check(old_val, new_val)) {
					value_change.push({key: to_item, from: old_val, to: new_val});
				}
			}

			i++;
		}
		i = 0;
		set_len = set.length;
		unset_len = unset.length;

		while(i < set_len) {
			si = set[i];
			j = 0;
			while(j < unset_len) {
				ui = unset[i];

				if(val_eq_check(from_vals[ui.from], to_vals[si.to])) {
					key_change.push({from: ui.key, to: si.key});

					removeIndex(set, i);
					removeIndex(unset, j);

					i--;
					unset_len--;
					set_len--;
					break;
				}

				j++;
			}
			i++;
		}
		return { set: set, unset: unset, key_change: key_change, value_change: value_change };
	};
}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	function getTime() {
		return (new Date()).getTime();
	}

	// mouse
	ist.createMouseObject = function() {
		var clientX = cjs(0),
			clientY = cjs(0),
			pageX = cjs(0),
			pageY = cjs(0),
			screenX = cjs(0),
			screenY = cjs(0),
			move_listener = function(event) {
				cjs.wait();
				clientX.set(event.clientX);
				clientY.set(event.clientY);
				pageX.set(event.pageX);
				pageY.set(event.pageY);
				screenX.set(event.screenX);
				screenY.set(event.screenY);
				cjs.signal();
			},
			addMouseListeners = function() {
				window.addEventListener("mousemove", move_listener);
			},
			removeMouseListeners = function() {
				window.removeEventListener("mousemove", move_listener);
			},
			destroy = function(silent) {
				cjs.wait();

				removeMouseListeners();
				clientX.destroy(silent);
				clientY.destroy(silent);
				pageX.destroy(silent);
				pageY.destroy(silent);
				screenX.destroy(silent);
				screenY.destroy(silent);

				cjs.signal();
			},
			device_mouse = new ist.Dict({has_protos: false, value: {
					x: pageX,
					y: pageY,
					clientX: clientX,
					clientY: clientY,
					pageX: pageX,
					pageY: pageY,
					screenX: screenX,
					screenY: screenY
				}
			});
		device_mouse.destroy = function() {
			ist.Dict.prototype.destroy.apply(this, arguments);
			destroy();
		};
		device_mouse.__is_mouse_device__ = true;
		addMouseListeners();
		return device_mouse;
	};
	ist.register_serializable_type("ist_device_mouse",
		function (x) {
			return x.__is_mouse_device__;
		},
		function () {
			return {};
		},
		function (obj) {
			return ist.createMouseObject();
		});
	
	// keyboard
	ist.createKeyboardObject = function() {
		var key_codes = {
				shift: 16,
				ctrl: 17,
				alt: 18,
				cmd_left: 91,
				cmd_right: 93
			},
			interesting_keycodes = {},
			keyboard_info = {};

		_.each(key_codes, function(code, name) {
			keyboard_info[name] = cjs(false);
			interesting_keycodes[code] = name;
		});

		var keydown_listener = function(event) {
				var keyCode = event.keyCode,
					name = interesting_keycodes[keyCode];
				if(name) {
					keyboard_info[name].set(true);
					event.preventDefault();
				}
			},
			keyup_listener = function(event) {
				var keyCode = event.keyCode,
					name = interesting_keycodes[keyCode];

				if(interesting_keycodes[keyCode]) {
					keyboard_info[name].set(false);
					event.preventDefault();
				}
			},
			addKeyboardListeners = function() {
				window.addEventListener("keydown", keydown_listener);
				window.addEventListener("keyup", keyup_listener);
			},
			removeKeyboardListeners = function() {
				window.removeEventListener("keydown", keydown_listener);
				window.removeEventListener("keyup", keyup_listener);
			},
			destroy = function(silent) {
				cjs.wait();

				removeKeyboardListeners();

				shift.destroy(silent);
				ctrl.destroy(silent);
				alt.destroy(silent);
				cmd_left.destroy(silent);
				cmd_right.destroy(silent);
				cmd.destroy(silent);

				cjs.signal();
			},
			shift = keyboard_info.shift,
			ctrl = keyboard_info.ctrl,
			alt = keyboard_info.alt,
			cmd_left = keyboard_info.cmd_left,
			cmd_right = keyboard_info.cmd_right,
			cmd = cmd_left.or(cmd_right),
			device_keyboard = new ist.Dict({has_protos: false, value: {
					shift: shift,
					ctrl: ctrl,
					alt: alt,
					cmd_left: cmd_left,
					cmd_right: cmd_right,
					cmd: cmd
				}
			});
		device_keyboard.destroy = function() {
			ist.Dict.prototype.destroy.apply(this, arguments);
			destroy();
		};
		device_keyboard.__is_keyboard_device__ = true;
		addKeyboardListeners();
		return device_keyboard;
	};
	ist.register_serializable_type("ist_device_keyboard",
		function (x) {
			return x.__is_keyboard_device__;
		},
		function () {
			return {};
		},
		function (obj) {
			return ist.createKeyboardObject();
		});
	
	// touches
	ist.createTouchscreenObject = function() {
		var touch_props = ["identifier",
							"screenX", "screenY",
							"clientX", "clientY",
							"pageX", "pageY",
							"radiusX", "radiusY",
							"rotationAngle"],
			alias_props = {
				x: "pageX",
				y: "pageY"
			},
			touch_ids = cjs([]);

		var touches = cjs({}),
			touch_start_listener = function(event) {
				cjs.wait();

				_.each(event.changedTouches, function(ct) {
					var identifier = ct.identifier,
						touch, touch_start_obj;

					if(touches.has(identifier)) {
						touch = touches.get(identifier);

						_.each(touch_props, function(prop_name) {
							var val = ct[prop_name];

							touch.put(prop_name, val);
						});
					} else {
						touch_start_obj = {};
						touch = cjs({});
						touches.put(identifier, touch);

						_.each(touch_props, function(prop_name) {
							var val = ct[prop_name];
							touch.put(prop_name, val);
							touch_start_obj[prop_name] = val;
						});
						_.each(alias_props, function(real_prop_name, alias_prop_name) {
							var val = ct[real_prop_name];
							touch.put(alias_prop_name, val);
							touch_start_obj[alias_prop_name] = val;
						});
						touch	.put('start', touch_start_obj)
								.put('end', false)
								.put('startTime', getTime())
								.put('endTime', false)
								.put('duration', false);

					}
					if(touch_ids.indexOf(identifier) < 0) {
						touch_ids.push(identifier);
					}
				});

				event.preventDefault();
				cjs.signal();
			},
			touch_move_listener = function(event) {
				cjs.wait();

				_.each(event.changedTouches, function(ct) {
					var identifier = ct.identifier;

					if(touches.has(identifier)) {
						var touch = touches.get(identifier);

						_.each(touch_props, function(prop_name) {
							var val = ct[prop_name];
							touch.put(prop_name, val);
						});
						_.each(alias_props, function(real_prop_name, alias_prop_name) {
							var val = ct[real_prop_name];
							touch.put(alias_prop_name, val);
						});
					} else {
						console.error("Could not find changed touch");
					}
				});

				event.preventDefault();
				cjs.signal();
			},
			touch_end_listener = function(event) {
				cjs.wait();

				_.each(event.changedTouches, function(ct) {
					var identifier = ct.identifier;

					if(touches.has(identifier)) {
						var index = touch_ids.indexOf(identifier),
							touch = touches.get(identifier),
							touch_end_obj = {};

						if(index >= 0) {
							_.each(touch_props, function(prop_name) {
								var val = ct[prop_name];

								touch_end_obj[prop_name] = val;
							});
							_.each(alias_props, function(real_prop_name, alias_prop_name) {
								var val = ct[real_prop_name];
								touch_end_obj[alias_prop_name] = val;
							});

							touch_ids.splice(index, 1);

							touch	.put('end', touch_end_obj)
									.put('endTime', getTime())
									.put('duration', touch.get('endTime')-touch.get('startTime'));
						} else {
							console.error("Could not find touch");
						}
					} else {
						console.error("Could not find ended touch");
					}
				});

				event.preventDefault();
				cjs.signal();
			},
			addTouchListeners = function() {
				window.addEventListener("touchstart", touch_start_listener);
				window.addEventListener("touchmove", touch_move_listener);
				window.addEventListener("touchend", touch_end_listener);
				window.addEventListener("touchcancel", touch_end_listener);
			},
			removeTouchListeners = function() {
				window.removeEventListener("touchstart", touch_start_listener);
				window.removeEventListener("touchmove", touch_move_listener);
				window.removeEventListener("touchend", touch_end_listener);
				window.removeEventListener("touchcancel", touch_end_listener);
			},
			destroy = function(silent) {
				cjs.wait();

				removeTouchListeners();
				touch_count.destroy(silent);

				cjs.signal();
			},
			touch_count = cjs(function() {
				return touch_ids.length();
			}),
			getTouch = function(touch_number) {
				var touch_identifier = touch_ids.item(touch_number);
				if(_.isNumber(touch_identifier)) {
					return getTouchByID(touch_identifier);
				} else {
					return false;
				}
			},
			getTouchByID = function(touch_id) {
				var touch = touches.get(touch_id);
				if(touch) {
					return touch;
				} else {
					return false;
				}
			},
			device_touchscreen = new ist.Dict({has_protos: false, value: {
					finger_count: touch_count,
					getTouch: getTouch,
					getTouchByID: getTouchByID
				}
			});

		device_touchscreen.destroy = function() {
			ist.Dict.prototype.destroy.apply(this, arguments);
			destroy();
		};

		device_touchscreen.__is_touchscreen_device__ = true;
		addTouchListeners();
		return device_touchscreen;
	};
	ist.register_serializable_type("ist_device_touchscreen",
		function (x) {
			return x.__is_touchscreen_device__;
		},
		function () {
			return {};
		},
		function (obj) {
			return ist.createTouchscreenObject();
		});

	// accelorometer
	ist.createAccelorometerObject = function() {
		var x = cjs(0),
			y = cjs(0),
			z = cjs(0),
			motion_listener = function(event) {
				cjs.wait();
				x.set(event.accelerationIncludingGravity.x);
				y.set(event.accelerationIncludingGravity.y);
				z.set(event.accelerationIncludingGravity.z);
				cjs.signal();
			},
			addAccelorometerListeners = function() {
				window.addEventListener("devicemotion", motion_listener);
			},
			removeAccelorometerListeners = function() {
				window.removeEventListener("devicemotion", motion_listener);
			},
			destroy = function(silent) {
				cjs.wait();
				removeAccelorometerListeners();
				x.destroy(silent);
				y.destroy(silent);
				z.destroy(silent);
				cjs.signal();
			},
			device_accelorometer = new ist.Dict({has_protos: false, value: {
					x: x,
					y: y,
					z: z
				}
			});
		device_accelorometer.destroy = function() {
			ist.Dict.prototype.destroy.apply(this, arguments);
			destroy();
		};
		device_accelorometer.__is_accelorometer_device__ = true;
		addAccelorometerListeners();
		return device_accelorometer;
	};
	ist.register_serializable_type("ist_device_accelorometer",
		function (x) {
			return x.__is_accelorometer_device__;
		},
		function () {
			return {};
		},
		function (obj) {
			return ist.createAccelorometerObject();
		});

	// gyroscope
	ist.createGyroscopeObject = function() {
		var alpha = cjs(0),
			beta = cjs(0),
			gamma = cjs(0),
			heading = cjs(0),
			accuracy = cjs(0),
			motion_listener = function(event) {
				cjs.wait();
				alpha.set(event.alpha);
				beta.set(event.beta);
				gamma.set(event.gamma);
				heading.set(event.heading);
				accuracy.set(event.accuracy);
				cjs.signal();
			},
			addGyroscopeListeners = function() {
				window.addEventListener("deviceorientation", motion_listener);
			},
			removeGyroscopeListeners = function() {
				window.removeEventListener("deviceorientation", motion_listener);
			},
			destroy = function(silent) {
				cjs.wait();
				removeGyroscopeListeners();
				alpha.destroy(silent);
				beta.destroy(silent);
				gamma.destroy(silent);
				heading.destroy(silent);
				accuracy.destroy(silent);
				cjs.signal();
			},
			device_gyroscope = new ist.Dict({has_protos: false, value: {
					alpha: alpha,
					beta: beta,
					gamma: gamma,
					heading: heading,
					accuracy: accuracy
				}
			});
		device_gyroscope.destroy = function() {
			ist.Dict.prototype.destroy.apply(this, arguments);
			destroy();
		};
		device_gyroscope.__is_gyroscope_device__ = true;
		addGyroscopeListeners();
		return device_gyroscope;
	};
	ist.register_serializable_type("ist_device_gyroscope",
		function (x) {
			return x.__is_gyroscope_device__;
		},
		function () {
			return {};
		},
		function (obj) {
			return ist.createGyroscopeObject();
		});

	// device
	ist.createDevices = function() {
		var width = cjs(window.innerWidth),
			height = cjs(window.innerHeight),
			orientation = cjs(window.orientation),
			resize_listener = function(event) {
				cjs.wait();
				width.set(window.innerWidth);
				height.set(window.innerHeight);
				cjs.signal();
			},
			orientation_listener = function(event) {
				orientation.set(window.orientation);
			},
			addListeners = function() {
				window.addEventListener("resize", resize_listener);
				window.addEventListener("orientationchange", orientation_listener);
			},
			removeListeners = function() {
				window.removeEventListener("resize", resize_listener);
				window.removeEventListener("orientationchange", orientation_listener);
			},
			destroy = function(silent) {
				cjs.wait();
				removeListeners();
				width.destroy(silent);
				height.destroy(silent);
				cjs.signal();
			},
			mouse = ist.createMouseObject(),
			keyboard = ist.createKeyboardObject(),
			touchscreen = ist.createTouchscreenObject(),
			accelorometer = ist.createAccelorometerObject(),
			gyroscope = ist.createGyroscopeObject(),
			device = new ist.Dict({has_protos: false, value: {
					mouse: mouse,
					keyboard: keyboard,
					touchscreen: touchscreen,
					accelorometer: accelorometer,
					gyroscope: gyroscope,
					width: width,
					height: height
				}
			});

		device.destroy = function(silent) {
			ist.Dict.prototype.destroy.apply(this, arguments);
			destroy();
		};

		device.__is_device__ = true;
		addListeners();
		return device;
	};
	ist.register_serializable_type("ist_device",
		function (x) {
			return x.__is_device__;
		},
		function () {
			return {};
		},
		function (obj) {
			return ist.createDevices();
		});
	
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,window,RedSet */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;
	
	ist.find_fn = function(find_root) {
		if (arguments.length === 0) {
			var pcontext = this;
			find_root = ist.find_or_put_contextual_obj(pcontext.root());
		}
		return new ist.Query({value: find_root});
	};
	ist.register_serializable_type("ist_find_fn_func",
		function (x) {
			return x === ist.find_fn;
		},
		function () {
			return {};
		},
		function (obj) {
			return ist.find_fn;
		});

    ist.Query = function (options) {
        this.options = _.extend({
            value: [],
            parent_query: null
        }, options);
        if (!_.isArray(this.options.value)) {
            this.options.value = [this.options.value];
        }
        this.options.value = _	.chain(this.options.value)
								.map(function (cobj) {
									if (cobj instanceof ist.ContextualDict && cobj.is_template()) {
										return cobj.instances();
									} else {
										return cobj;
									}
								})
								.flatten(true)
								.value();
		this.type = options.type || "root";
    };

    (function (My) {
        var proto = My.prototype;
    
        var raw_filter_funcs = {
            "lt": function (a, b) { return a < b; },
            "gt": function (a, b) { return a > b; },
            "le": function (a, b) { return a <= b; },
            "ge": function (a, b) { return a >= b; },
            "eq": function (a, b) { return a === b; }
        };
    
        var filter_funcs = {
            "in_state": function (cobj, index, arr, state_name) {
                var statecharts, i, j;
                if (cobj instanceof ist.ContextualStatefulObj) {
                    statecharts = cobj.get_statecharts();
                } else {
                    statecharts = [];
                }
    
                for (i = 0; i < statecharts.length; i += 1) {
                    var statechart = statecharts[i];
                    var active_substates = statechart.get_active_states();
                    for (j = 0; j < active_substates.length; j += 1) {
                        var active_substate = active_substates[j];
                        if (active_substate.get_name() === state_name) {
                            return true;
                        }
                    }
                }
                return false;
            }
        };
    
        _.each(raw_filter_funcs, function (func, name) {
            filter_funcs[name] = function (pointer_val, index, arr, other_val) {
                var pointer = pointer_val.get_pointer();
                var p_val = pointer.val();
                return func(p_val, other_val);
            };
        });
    
        _.each(filter_funcs, function (func, name) {
            proto[name] = function () {
                var args = _.toArray(arguments);
                return this.filter(function () {
                    return func.apply(this, (_.toArray(arguments)).concat(args));
                });
            };
        });
    
        var map_funcs = {
            "prop": function (cobj, index, arr, name) {
                var prop_cobj = cobj.prop(name);
                return prop_cobj;
            },
            "container": function (cobj) {
                var pointer = cobj.get_pointer();
                var new_ptr = pointer.pop();
                var new_ptr_obj = new_ptr.points_at();
    
                var rv = ist.find_or_put_contextual_obj(new_ptr_obj, new_ptr);
                return rv;
            }
        };
    
        _.each(map_funcs, function (func, name) {
            proto[name] = function () {
                var args = _.toArray(arguments);
                return this.map(function () {
                    return func.apply(this, (_.toArray(arguments)).concat(args));
                });
            };
        });
    
        proto.filter = function (filter_func, context) {
            return this.op(function (values) {
                return _.filter(values, filter_func, context);
            });
        };
		proto.eq = function(index) {
			var value = this.value();
			return value[index];
		};
        proto.map = function (map_func, context) {
            return this.op(function (values) {
                return _.map(values, map_func, context);
            });
        };
        proto.size = function () {
            return this.value().length;
        };
        proto.is_empty = function () {
            return this.size() === 0;
        };
    
        var extract_items = function () {
            var items = _.chain(arguments)
                     .map(function (other_query) {
                        var other_objects;
                        if (other_query instanceof ist.Query) {
                            other_objects = other_query.value();
                        } else if (_.isArray(other_query)) {
                            other_objects = other_query;
                        } else {
                            other_objects = [other_query];
                        }
                        return other_objects;
                    })
                    .flatten(true)
                    .value();
            return items;
        };
    
        proto.add = function () {
            var my_value_set = new RedSet({value: this.value(), equals: ist.check_contextual_object_equality, hash: "hash"});
            var items = extract_items.apply(this, arguments);
            
            var new_value_set = my_value_set.add.apply(my_value_set, items);
    
            var new_query = new ist.Query({
                value: new_value_set.toArray(),
                parent_query: this,
				type: "add"
            });
            return new_query;
        };
    
        proto.not = proto.remove = function () {
            var my_value_set = new RedSet({value: this.value(), equals: ist.check_contextual_object_equality, hash: "hash"});
            var items = extract_items.apply(this, arguments);
    
            my_value_set.remove.apply(my_value_set, items);
            var new_query = new ist.Query({
                value: my_value_set.toArray(),
                parent_query: this,
				type: "not"
            });
            return new_query;
        };
    
        proto.op = function (op_func, context) {
            var value = op_func.call(context || window, this.value()),
				new_query = new My({
					value: value,
					parent_query: this,
					type: "op"
				});
            return new_query;
        };
    
        proto.value = function () {
            return this.options.value;
        };
        proto.parent_query = function () {
            return this.options.parent_query;
        };

		var is_cDict = function(cobj) {
				return cobj instanceof ist.ContextualDict;
			},
			flatten_containment_hierarchy = function(parents, not_root_call) {
				var rv = not_root_call ? parents : _.filter(parents, is_cDict); // also clones when calling filter

				_.each(rv, function(cobj) {
					var children = cobj.children();
					_.each(children, function(child_info) {
						var child = child_info.value;
						if(is_cDict(child)) {
							if(child.is_template()) {
								rv.push.apply(rv, flatten_containment_hierarchy(child.instances(), true));
							} else {
								rv.push.apply(rv, flatten_containment_hierarchy([child], true));
							}
						}
					});
				});
				return rv;
			};

		proto.inheritsFrom = function(cobj) {
			var flat_objs = flatten_containment_hierarchy(this.value()),
				value = _.filter(flat_objs, function(x) {
					return x.inherits_from(cobj);
				}),
				new_query = new My({
					value: value,
					parent_query: this,
					type: "inheritsFrom"
				});
            return new_query;
		};
    }(ist.Query));

}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.get_default_root = function(builtins) {
		var root = new ist.Dict({has_protos: false, direct_attachments: [new ist.DomAttachment({instance_options: {tag: 'div'}})]});

		ist.initialize_root(root, builtins);

		return root;
	};
	ist.initialize_root = function (root_dict, builtins) {
		if((builtins !== false && !_.isArray(builtins)) || (_.indexOf(builtins, "svg") >= 0)) {
			var svg = new ist.Dict({has_protos: false});
			root_dict.set("svg", svg);

			var paper = new ist.Dict({
				has_protos: false,
				direct_attachments: [new ist.PaperAttachment()]
			});
			paper.set("width", new ist.Cell({str: "400"}));
			paper.set("height", new ist.Cell({str: "400"}));
			paper.set("fill", new ist.Cell({str: "'white'"}));
			svg.set("paper", paper);

			var circle = new ist.Dict({has_protos: false, direct_attachments: [new ist.ShapeAttachment({
																								instance_options: {
																									shape_type: "circle",
																									constructor_params: [0, 0, 0]
																								}
																						})]
																					});
			svg.set("circle", circle);
			circle.set("show", new ist.Cell({str: "true"}));
			circle.set("clip_rect", new ist.Cell({str: "null"}));
			circle.set("cursor", new ist.Cell({str: "'default'"}));
			circle.set("cx", new ist.Cell({str: "2*r"}));
			circle.set("cy", new ist.Cell({str: "2*r"}));
			circle.set("fill", new ist.Cell({str: "'teal'"}));
			circle.set("fill_opacity", new ist.Cell({str: "1.0"}));
			circle.set("opacity", new ist.Cell({str: "1.0"}));
			circle.set("r", new ist.Cell({str: "50"}));
			circle.set("stroke", new ist.Cell({str: "'none'"}));
			circle.set("stroke_dasharray", new ist.Cell({str: "''"}));
			circle.set("stroke_opacity", new ist.Cell({str: "1.0"}));
			circle.set("stroke_width", new ist.Cell({str: "1"}));
			circle.set("transform", new ist.Cell({str: "''"}));
			circle.set("animated_properties", new ist.Cell({str: "false"}));
			circle.set("animation_duration", new ist.Cell({str: "300"}));
			circle.set("animation_easing", new ist.Cell({str: "'linear'"}));
			circle.set("shape", new ist.Cell({str: "'circle'"}));


			var ellipse = new ist.Dict({has_protos: false, direct_attachments: [new ist.ShapeAttachment({
																								instance_options: {
																									shape_type: "ellipse",
																									constructor_params: [0, 0, 0, 0]
																								}
																						})]
																					});
			svg.set("ellipse", ellipse);
			ellipse.set("show", new ist.Cell({str: "true"}));
			ellipse.set("clip_rect", new ist.Cell({str: "null"}));
			ellipse.set("cursor", new ist.Cell({str: "'default'"}));
			ellipse.set("cx", new ist.Cell({str: "2*rx"}));
			ellipse.set("cy", new ist.Cell({str: "2*ry"}));
			ellipse.set("fill", new ist.Cell({str: "'yellow'"}));
			ellipse.set("fill_opacity", new ist.Cell({str: "1.0"}));
			ellipse.set("opacity", new ist.Cell({str: "1.0"}));
			ellipse.set("rx", new ist.Cell({str: "150"}));
			ellipse.set("ry", new ist.Cell({str: "90"}));
			ellipse.set("stroke", new ist.Cell({str: "'none'"}));
			ellipse.set("stroke_dasharray", new ist.Cell({str: "''"}));
			ellipse.set("stroke_opacity", new ist.Cell({str: "1.0"}));
			ellipse.set("stroke_width", new ist.Cell({str: "1"}));
			ellipse.set("transform", new ist.Cell({str: "''"}));
			ellipse.set("animated_properties", new ist.Cell({str: "false"}));
			ellipse.set("animation_duration", new ist.Cell({str: "300"}));
			ellipse.set("animation_easing", new ist.Cell({str: "'linear'"}));
			ellipse.set("shape", new ist.Cell({str: "'ellipse'"}));
			
			var image = new ist.Dict({has_protos: false, direct_attachments: [new ist.ShapeAttachment({
																								instance_options: {
																									shape_type: "image",
																									constructor_params: ["", 0, 0, 0, 0]
																								}
																						})]
																					});
			svg.set("image", image);
			image.set("show", new ist.Cell({str: "true"}));
			image.set("clip_rect", new ist.Cell({str: "null"}));
			image.set("cursor", new ist.Cell({str: "'default'"}));
			image.set("opacity", new ist.Cell({str: "1.0"}));
			image.set("src", new ist.Cell({str: "'http://interstate.from.so/images/interstate_logo.png'"}));
			image.set("transform", new ist.Cell({str: "''"}));
			image.set("x", new ist.Cell({str: "20"}));
			image.set("y", new ist.Cell({str: "20"}));
			image.set("width", new ist.Cell({str: "150"}));
			image.set("height", new ist.Cell({str: "150"}));
			image.set("animated_properties", new ist.Cell({str: "false"}));
			image.set("animation_duration", new ist.Cell({str: "300"}));
			image.set("animation_easing", new ist.Cell({str: "'linear'"}));
			image.set("shape", new ist.Cell({str: "'image'"}));


			var rect = new ist.Dict({has_protos: false, direct_attachments: [new ist.ShapeAttachment({
																								instance_options: {
																									shape_type: "rect",
																									constructor_params: [0, 0, 0, 0]
																								}
																						})]
																					});
			svg.set("rectangle", rect);
			rect.set("show", new ist.Cell({str: "true"}));
			rect.set("clip_rect", new ist.Cell({str: "null"}));
			rect.set("cursor", new ist.Cell({str: "'default'"}));
			rect.set("x", new ist.Cell({str: "10"}));
			rect.set("y", new ist.Cell({str: "10"}));
			rect.set("fill", new ist.Cell({str: "'Chartreuse'"}));
			rect.set("fill_opacity", new ist.Cell({str: "1.0"}));
			rect.set("opacity", new ist.Cell({str: "1.0"}));
			rect.set("r", new ist.Cell({str: "0"}));
			rect.set("stroke", new ist.Cell({str: "'none'"}));
			rect.set("stroke_dasharray", new ist.Cell({str: "''"}));
			rect.set("stroke_opacity", new ist.Cell({str: "1.0"}));
			rect.set("stroke_width", new ist.Cell({str: "1"}));
			rect.set("transform", new ist.Cell({str: "''"}));
			rect.set("width", new ist.Cell({str: "150"}));
			rect.set("height", new ist.Cell({str: "100"}));
			rect.set("animated_properties", new ist.Cell({str: "false"}));
			rect.set("animation_duration", new ist.Cell({str: "300"}));
			rect.set("animation_easing", new ist.Cell({str: "'linear'"}));
			rect.set("shape", new ist.Cell({str: "'rectangle'"}));
			
			var text = new ist.Dict({has_protos: false, direct_attachments: [new ist.ShapeAttachment({
																								instance_options: {
																									shape_type: "text",
																									constructor_params: [0, 0, ""]
																								}
																						})]
																					});
			svg.set("text", text);
			text.set("show", new ist.Cell({str: "true"}));
			text.set("clip_rect", new ist.Cell({str: "null"}));
			text.set("cursor", new ist.Cell({str: "'default'"}));
			text.set("x", new ist.Cell({str: "200"}));
			text.set("y", new ist.Cell({str: "150"}));
			text.set("opacity", new ist.Cell({str: "1.0"}));
			text.set("stroke", new ist.Cell({str: "'none'"}));
			text.set("fill", new ist.Cell({str: "'grey'"}));
			text.set("fill_opacity", new ist.Cell({str: "1.0"}));
			text.set("stroke_dasharray", new ist.Cell({str: "''"}));
			text.set("stroke_opacity", new ist.Cell({str: "1.0"}));
			text.set("stroke_width", new ist.Cell({str: "1"}));
			text.set("transform", new ist.Cell({str: "''"}));
			text.set("text", new ist.Cell({str: "'hello world'"}));
			text.set("text_anchor", new ist.Cell({str: "'middle'"}));
			text.set("font_family", new ist.Cell({str: "'Arial'"}));
			text.set("font_size", new ist.Cell({str: "40"}));
			text.set("font_weight", new ist.Cell({str: "400"}));
			text.set("font_style", new ist.Cell({str: "'normal'"}));
			text.set("animated_properties", new ist.Cell({str: "false"}));
			text.set("animation_duration", new ist.Cell({str: "300"}));
			text.set("animation_easing", new ist.Cell({str: "'linear'"}));
			text.set("shape", new ist.Cell({str: "'text'"}));

			var path = new ist.Dict({has_protos: false, direct_attachments: [new ist.ShapeAttachment({
																								instance_options: {
																									shape_type: "path",
																									constructor_params: ["M0,0"]
																								}
																						})]
																					});
			svg.set("path", path);
			path.set("show", new ist.Cell({str: "true"}));
			path.set("clip_rect", new ist.Cell({str: "null"}));
			path.set("cursor", new ist.Cell({str: "'default'"}));
			path.set("fill", new ist.Cell({str: "'none'"}));
			path.set("fill_opacity", new ist.Cell({str: "1.0"}));
			path.set("opacity", new ist.Cell({str: "1.0"}));
			path.set("stroke", new ist.Cell({str: "'RoyalBlue'"}));
			path.set("stroke_dasharray", new ist.Cell({str: "''"}));
			path.set("stroke_opacity", new ist.Cell({str: "1.0"}));
			path.set("stroke_miterlimit", new ist.Cell({str: "0"}));
			path.set("stroke_width", new ist.Cell({str: "1"}));
			path.set("path", new ist.Cell({str: "'M0,0L300,300'"}));
			path.set("transform", new ist.Cell({str: "''"}));
			path.set("animated_properties", new ist.Cell({str: "false"}));
			path.set("animation_duration", new ist.Cell({str: "300"}));
			path.set("animation_easing", new ist.Cell({str: "'linear'"}));
			path.set("shape", new ist.Cell({str: "'path'"}));

			var group = new ist.Dict({has_protos: false, direct_attachments: [new ist.GroupAttachment()]});
			svg.set("group", group);
			group.set("showChildren", new ist.Cell({str: "true"}));
		}

		if((builtins !== false && !_.isArray(builtins)) || (_.indexOf(builtins, "dom") >= 0)) {
			var dom = new ist.Dict({has_protos: false});
			root_dict.set("dom", dom);

			var node = new ist.Dict({direct_attachments: [new ist.DomAttachment()]});
			dom.set("node", node);
			node.set("tag", new ist.Cell({str: "'div'"}));
			node.set("attr", new ist.Dict());
			node.set("style", new ist.Dict());
			node.set("textContent", new ist.Cell({str: "'no text'"}));
			node.set("show", new ist.Cell({str: "true"}));
			node.set("showChildren", new ist.Cell({str: "true"}));

			var div = new ist.Dict();
			dom.set("div", div);
			div._set_direct_protos(new ist.Cell({ ignore_inherited_in_first_dict: true, str: "dom.node"}));
			div.set("tag", new ist.Cell({str: "'div'"}));

			var input = new ist.Dict();
			dom.set("input", input);
			input._set_direct_protos(new ist.Cell({ ignore_inherited_in_first_dict: true, str: "dom.node"}));
			input	.set("tag", new ist.Cell({str: "'input'"}))
					.set("textContent", new ist.Cell({str: "''"}));

			_.each(["strong", "span", "ul", "ol", "li", "h1", "h2", "h3", "h4", "h5",
					"h6", "table", "tbody", "tr", "td", "th", "p", "pre", "br", "a",
					"label", "img", "select", "option", "button", "hr"],
					function(tag_name) {
						var obj = new ist.Dict();
						dom.set(tag_name, obj);
						obj._set_direct_protos(new ist.Cell({ ignore_inherited_in_first_dict: true, str: "dom.node"}));
						obj.set("tag", new ist.Cell({str: "'" + tag_name + "'"}));
					});
			/**/
		}

		if((builtins !== false && !_.isArray(builtins)) || (_.indexOf(builtins, "physics") >= 0)) {
			var physics = new ist.Dict({has_protos: false});
			root_dict.set("physics", physics);

			var world = new ist.Dict({direct_attachments: [new ist.WorldAttachment()]});
			physics.set("world", world);
			world.set("gx", new ist.Cell({str: "0.0"}));
			world.set("gy", new ist.Cell({str: "9.8"}));

			var fixture = new ist.Dict({direct_attachments: [new ist.FixtureAttachment()]});
			physics.set("fixture", fixture);
			fixture.set("fixed", new ist.Cell({str: "true"}));
			fixture.set("restitution", new ist.Cell({str: "0.2"}));
			fixture.set("friction", new ist.Cell({str: "0.5"}));
			fixture.set("density", new ist.Cell({str: "1.0"}));
			fixture.set("world", new ist.Cell({str: "physics.world"}));
			fixture.set("computed_x", new ist.Cell({str: "fetch_physics_info(this, 'getComputedX')"}));
			fixture.set("computed_y", new ist.Cell({str: "fetch_physics_info(this, 'getComputedY')"}));
			fixture.set("computed_theta", new ist.Cell({str: "fetch_physics_info(this, 'getComputedTheta')"}));
			fixture.set("applyForce", new ist.Cell({str: "physics_call(this, 'applyForce')"}));
			fixture.set("applyImpulse", new ist.Cell({str: "physics_call(this, 'applyImpulse')"}));
			fixture.set("physics_call", new ist.Cell({str: "function(p, prop_name) {" +
				"var fixture_attachment = interstate.get_attachment(p, 'box2d_fixture');" +
				//"if(fixture_attachment) {" +
				"return fixture_attachment[prop_name].bind(fixture_attachment);" +
				//"}" +
			"}"}));
			fixture.set("fetch_physics_info", new ist.Cell({str: "function(p, prop_name) {" +
				"var fixture_attachment = interstate.get_attachment(p, 'box2d_fixture');" +
				//"if(fixture_attachment) {" +
				"return fixture_attachment[prop_name]();" +
				//"}" +
			"}"}));
		}

		if((builtins !== false && !_.isArray(builtins)) || (_.indexOf(builtins, "functions") >= 0)) {
			root_dict.set("on", ist.on_event);
			root_dict.set("find", ist.find_fn);
			root_dict.set("emit", ist.emit);
		}

		if((builtins !== false && !_.isArray(builtins)) || (_.indexOf(builtins, "device") >= 0)) {
			var device = ist.createDevices();
			root_dict.set("device", device);
		}
	};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;
    
    ist.BasicObject = function (options, defer_initialization) {
		able.make_this_listenable(this);
        options = options || {};
        this._id = options.uid || uid();
        this._hash = uid.strip_prefix(this.id());
        this.options = options;
        ist.register_uid(this.id(), this);
        if (defer_initialization !== true) {
            this.initialize(options);
        }
    };
    (function (My) {
        var proto = My.prototype;
		able.make_proto_listenable(proto);

        My.builtins = { };

        ist.install_proto_builtins(proto, My.builtins);
        proto.initialize = function (options) {
			//options = options || this.options;
            ist.install_instance_builtins(this, options, My);
        };
		proto.clone = function() { };
		proto.begin_destroy = function () {
			this._emit("begin_destroy");
		};
        proto.destroy = function () {
			if(this.constructor === My) { this.begin_destroy(); }
			ist.unset_instance_builtins(this, My);
			ist.unregister_uid(this.id());
			this._emit("destroyed");
			able.destroy_this_listenable(this);
			this._destroyed = true;
        };
    
        proto.id = function () { return this._id; };
		proto.hash = function () { return this._hash; };
		proto.sid = function() { return parseInt(uid.strip_prefix(this.id()), 10); };
    
        proto.summarize = function () { return this.id(); };
    }(ist.BasicObject));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;
    
    ist.Cell = function (options, defer_initialization) {
		ist.Cell.superclass.constructor.apply(this, arguments);
    };
    (function (My) {
		_.proto_extend(My, ist.BasicObject);
        var proto = My.prototype;

        My.builtins = {
            "str": {
                start_with: function () { return cjs(""); },
                getter: function (me) { return me.get(); },
                setter: function (me, str) {
                    me.set(str, true);
                },
				destroy: function(me) {
					me.destroy(true);
				}
            },
            "ignore_inherited_in_first_dict": {
                "default": function () { return false; }
            },
            "contextual_values": {
                "default": function () {
                    return cjs.map({
                        equals: ist.check_pointer_equality,
                        hash: "hash"
                    });
                },
                settable: false,
                serialize: false,
				destroy: function(me) {
					me.forEach(function (value) {
						value.destroy(true);
					});
					me.destroy(true);
				}
            },
            "substantiated": {
                "default": function () { return false; },
				getter_name: "is_substantiated"
            }
        };
        ist.install_proto_builtins(proto, My.builtins);

        proto.initialize = function (options) {
			My.superclass.initialize.apply(this, arguments);
            ist.install_instance_builtins(this, options, My);
            this._tree = cjs(function () {
                var str = this.get_str();
                return ist.parse(str);
            }, {
				context: this
			});

			this._is_static = cjs(function () {
				var tree = this._tree.get();
				return tree.body.length === 0 ||
					(tree.body.length === 1 &&
						tree.body[0].type === 'ExpressionStatement' &&
						tree.body[0].expression.type === 'Literal');
			}, {
				context: this
			});
			this._static_value = cjs(function() {
				var tree = this._tree.get();
				if(tree.body.length > 0) {
					return tree.body[0].expression.value;
				}
			}, {
				context: this
			});
        };
		proto.substantiate = function() {
			this.set_substantiated(true);
			this._emit("substantiated");
		};
		proto.clone = function() {
			return new ist.Cell({
				str: this.get_str()
			});
		};
    
        proto.get_ignore_inherited_in_contexts = function (pcontext) {
            var i;
            if (this.get_ignore_inherited_in_first_dict()) {
                for (i = pcontext.length() - 1; i >= 0; i -= 1) {
                    var item = pcontext.points_at(i);
                    if (item instanceof ist.Dict) {
                        return [item];
                    }
                }
            }
            return [];
        };
    
		proto.get_syntax_errors = function() {
            var tree = this._tree.get();
			return tree instanceof ist.Error ? [tree.message()] : [];
		};
        proto.constraint_in_context = function (pcontext, inherited_from_cobj) {
			if(this._is_static.get()) {
				return this._static_value.get();
			} else {
				var tree = this._tree.get();
				return ist.get_parsed_$(tree, {
							context: pcontext,
							ignore_inherited_in_contexts: this.get_ignore_inherited_in_contexts(pcontext),
							get_constraint: true,
							inherited_from_cobj: inherited_from_cobj
						});
			}
        };
        proto.value_in_context = function (pcontext, inherited_from_cobj) {
			if(this._is_static.get()) {
				return this._static_value.get();
			} else {
				var tree = this._tree.get();
				return ist.get_parsed_$(tree, {
							context: pcontext,
							ignore_inherited_in_contexts: this.get_ignore_inherited_in_contexts(pcontext),
							get_constraint: false,
							inherited_from_cobj: inherited_from_cobj
						});
			}
        };
        proto.destroy = function () {
			if(this.constructor === My) { this.begin_destroy(); }

			ist.unset_instance_builtins(this, My);

            this._tree.destroy(true);
			delete this._tree;
			this._static_value.destroy(true);
			delete this._static_value;
			this._is_static.destroy(true);
			delete this._is_static;

			My.superclass.destroy.apply(this, arguments);
        };
    
        ist.register_serializable_type("cell",
            function (x) {
                return x instanceof My;
            },
            function (include_uid) {
                var rv = { };
                if (include_uid) { rv.uid = this.id(); }

                _.each(My.builtins, function (builtin, name) {
                    if (builtin.serialize !== false) {
                        var getter_name = builtin.getter_name || "get_" + name;
                        rv[name] = ist.serialize(this[getter_name]());
                    }
                }, this);

                return rv;
            },
            function (obj) {
                var rest_args = _.rest(arguments);
                
                var serialized_options = {};
                _.each(My.builtins, function (builtin, name) {
                    if (builtin.serialize !== false) {
                        serialized_options[name] = obj[name];
                    }
                });

                var rv = new My({uid: obj.uid}, true);
				var old_initialize = proto.initialize;
                rv.initialize = function () {
					delete this.initialize;
                    var options = { };
                    _.each(serialized_options, function (serialized_option, name) {
                        options[name] = ist.deserialize.apply(ist, ([serialized_option]).concat(rest_args));
                    });
					old_initialize.call(this, options);
                };

                return rv;
            });
    }(ist.Cell));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;
    
    ist.POINTERS_PROPERTY = {};
    ist.MANIFESTATIONS_PROPERTY = {};
    
    ist.is_inherited = function (pcontext) {
        return ist.inherited_root(pcontext) !== undefined;
    };
    ist.inherited_root = function (pcontext) {
        var child, parent;
        child = pcontext.points_at();
        var inh = false,
            child_src,
            i;
        for (i = pcontext.length() - 2; i >= 0; i -= 1) {
            parent = pcontext.points_at(i);
            child_src = parent.src_for_prop(child, pcontext.slice(0, i + 1));
            if (child_src === parent) {
                if (inh) {
                    return pcontext.slice(0, i + 3);
                }
            } else if (child_src !== undefined) {
                inh = true;
            }
    
            child = parent;
        }
        return undefined;
    };
    
    ist.Dict = function (options, defer_initialization) {
        options = _.extend({
            value: {},
            keys: [],
            values: [],
            has_protos: true,
			has_copies: true
        }, options);

        ist.Dict.superclass.constructor.call(this, options, defer_initialization);
    
        this.type = "ist_dict";
    };
    
    (function (My) {
		_.proto_extend(My, ist.BasicObject);

        var proto = My.prototype;
    
        proto.initialize = function (options) {
            My.superclass.initialize.apply(this, arguments);

            ist.install_instance_builtins(this, options, My);
            var direct_props = this.direct_props();
            direct_props.setValueEqualityCheck(function (info1, info2) {
                return info1.value === info2.value;
            });
        };
    
        My.builtins = {
            "direct_protos": {
                "default": function () { return cjs.array(); },
                getter_name: "direct_protos",
                setter_name: "_set_direct_protos",
                env_visible: true,
                env_name: "prototypes",
				destroy: function(me) {
					me.destroy(true);
				}
            },
    
            "direct_attachments": {
                "default": function () { return []; },
                getter_name: "direct_attachments",
				destroy: function(me) {
					if (cjs.isArrayConstraint(me)) {
						me.forEach(function(attachment) {
							attachment.destroy(true);
						});
						me.destroy(true);
					} else if(_.isArray(me)) {
						_.each(me, function(attachment) {
							attachment.destroy(true);
						});
					}
				}
            },
    
            "direct_props": {
                "default": function () {
					var keys = this.options.keys,
						values = _.map(this.options.values, function(v) {
									return {
										value: v,
										owner: this
									};
								}, this),
						value = {};

					_.each(this.options.value, function(v, k) {
						value[k] = {
							value: v,
							owner: this
						};
					}, this);

                    var rv = cjs.map({
                        keys: keys,
                        values: values,
                        value: value
                    });

                    return rv;
                },
                getter_name: "direct_props",
				destroy: function(me) {
					me.forEach(function(prop_val, name) {
						if(prop_val.value.destroy) {
							prop_val.value.destroy(true);
						}
						delete prop_val.owner;
						delete prop_val.value;
					});
					me.destroy(true);
				}
            },
    
            "copies": {
                start_with: function () { 
					return cjs.constraint(new ist.Cell({str: ""}));
				},
                env_visible: false,
                env_name: "copies",
                getter: function (me) { return me.get(); },
                setter: function (me, val) {
					var old_val = me.get();
					if(old_val && old_val.destroy) {
						old_val.destroy(true);
					}
					me.set(val, true);
				},
				destroy: function(me) {
					var val = me.get();
					if(val && val.destroy) {
						val.destroy();
					}
					me.destroy(true);
				}
            }
        };
    
        ist.install_proto_builtins(proto, My.builtins);

        
        //
        // === DIRECT PROTOS ===
        //
    
        proto.has_protos = function () {
            return this.options.has_protos;
        };

		proto.has_copies = function() {
			return this.options.has_copies;
		};
    
        
        //
        // === DIRECT PROPERTIES ===
        //
    
        proto.set = proto.set_prop = proto._set_direct_prop = function (name, value, options) {
            var index,
				info = _.extend({
					value: value,
					owner: this
				}, options);
            this.direct_props().put(name, info, info.index);
            return this;
        };
        proto.unset = proto.unset_prop = proto._unset_direct_prop = function (name) {
            this.direct_props().remove(name);
            return this;
        };
        proto._get_direct_prop = function (name) {
            var info = this._get_direct_prop_info(name);
            if (info) {
                return info.value;
            } else {
                return undefined;
            }
        };
        proto._get_direct_prop_info = function (name) {
            return this.direct_props().get(name);
        };
        proto._has_direct_prop = function (name) {
            return this.direct_props().has(name);
        };
        proto.move = proto.move_prop = proto._move_direct_prop = function (name, to_index) {
            this.direct_props().move(name, to_index);
            return this;
        };
        proto.index = proto.prop_index = proto._direct_prop_index = function (name) {
            return this.direct_props().indexOf(name);
        };
        proto.rename = proto._rename_direct_prop = function (from_name, to_name) {
            if (this._has_direct_prop(to_name)) {
                throw new Error("Already a property with name " + to_name);
            } else {
                var direct_props = this.direct_props();
                var keyIndex = direct_props.indexOf(from_name);
                if (keyIndex >= 0) {
                    var prop_val = direct_props.get(from_name);
                    cjs.wait();
                    direct_props.remove(from_name)
                                .put(to_name, prop_val, keyIndex);
                    cjs.signal();
                } else {
                    throw new Error("No such property " + from_name);
                }
            }
        };
    
        proto._get_direct_prop_names = function () {
            return this.direct_props().keys();
        };
        
        //
        // === BUILTIN PROPERTIES ===
        //
        
        proto.get_builtins = function () {
            var builtins = _.clone(this.constructor.builtins);
            var supah = this.constructor.superclass;
            while (supah) {
                _.extend(builtins, supah.constructor.builtins);
                supah = supah.superclass;
            }
            return builtins;
        };
        
		var protos_array = ["prototypes"], empty_array = [];
        proto._get_builtin_prop_names = function () {
			return this.has_protos() ? protos_array : empty_array;
			/*
            var rv = [];
            _.each(this.get_builtins(), function (val, name) {
                if (val.env_visible === true) {
                    if (name === "direct_protos" && !this.has_protos()) {
                        return;
                    }
                    name = val.env_name || name;
                    rv.push(name);
                }
            }, this);
            return rv;
			*/
        };
        proto._get_builtin_prop_info = function (prop_name) {
            var builtins = this.get_builtins();
            var builtin_name;
            for (builtin_name in builtins) {
                if (builtins.hasOwnProperty(builtin_name)) {
                    var builtin = builtins[builtin_name];
                    if (builtin.env_visible === true) {
                        var env_name = builtin.env_name || builtin_name;
                        if (prop_name === env_name) {
                            var getter_name = builtin.getter_name || "get_" + builtin_name;
                            return {value: this[getter_name]()};
                        }
                    }
                }
            }
        };
        proto._get_builtin_prop = function (prop_name) {
            var info = this._get_builtin_prop_info(prop_name);
            if (info) {
                return info.value;
            } else {
                return undefined;
            }
        };
        proto._has_builtin_prop = function (prop_name) {
			return prop_name === "prototypes" && this.has_protos();
			/*
            var rv = false;
            return _.any(this.get_builtins(), function (val, name) {
                if (val.env_visible === true) {
                    name = val.env_name || name;
                    if (name === prop_name) {
                        return true;
                    }
                }
                return false;
            });
			*/
        };
        
        //
        // === DIRECT ATTACHMENTS ===
        //
    
        proto._get_direct_attachments = function () {
            var direct_attachments = this.direct_attachments();
            if (cjs.isArrayConstraint(direct_attachments)) {
                return this.direct_attachments().toArray();
            } else if (_.isArray(direct_attachments)) {
                return direct_attachments;
            } else {
                return [direct_attachments];
            }
        };

		proto.clone = function() {
			return ist.deserialize(ist.serialize(this, false));
		};
    
        //
        // === BYE BYE ===
        //
    
        proto.destroy = function () {
			if(this.constructor === My) { this.begin_destroy(); }
			ist.unset_instance_builtins(this, My);
			My.superclass.destroy.apply(this, arguments);
        };
    
        proto.toString = function () {
            return "dict:" + this.uid;
        };
    
        proto.serialize = function (include_uid) {
            var rv = {
                has_protos: this.has_protos(),
				has_copies: this.has_copies()
            };
            if (include_uid) { rv.uid = this.id(); }
    
            var args = _.toArray(arguments);
            _.each(this.get_builtins(), function (builtin, name) {
                var getter_name = builtin._get_getter_name();
                rv[name] = ist.serialize.apply(ist, ([this[getter_name]()]).concat(args));
            }, this);
    
            return rv;
        };
        ist.register_serializable_type("dict",
            function (x) {
                return x instanceof My && x.constructor === My;
            },
            proto.serialize,
            function (obj) {
                var rest_args = _.rest(arguments);
                var serialized_options = {};
                _.each(My.builtins, function (builtin, name) {
                    serialized_options[name] = obj[name];
                });

                var rv = new My({uid: obj.uid, has_protos: obj.has_protos, has_copies: obj.has_copies}, true),
					old_initialize = proto.initialize;
                rv.initialize = function () {
					delete this.initialize;
                    var options = {};
                    _.each(serialized_options, function (serialized_option, name) {
                        options[name] = ist.deserialize.apply(ist, ([serialized_option]).concat(rest_args));
                    });
					old_initialize.call(this, options);
                };

                return rv;
            });
    }(ist.Dict));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;
    
    ist.StatefulObj = function (options, defer_initialization) {
        ist.StatefulObj.superclass.constructor.apply(this, arguments);
        this.type = "ist_stateful_obj";
    };
    (function (My) {
        _.proto_extend(My, ist.Dict);
        var proto = My.prototype;
    
        proto.initialize = function (options) {
            My.superclass.initialize.apply(this, arguments);
            ist.install_instance_builtins(this, options, My);
        };
    
        My.builtins = {
            "direct_statechart": {
                "default": function () { return new ist.Statechart(); },
                getter_name: "get_own_statechart",
                settable: false,
				destroy: function(me) {
					me.destroy(true);
				}
            }
        };
        ist.install_proto_builtins(proto, My.builtins);

        proto.destroy = function () {
			if(this.constructor === My) { this.begin_destroy(); }
            My.superclass.destroy.apply(this, arguments);
			ist.unset_instance_builtins(this, My);
        };

        ist.register_serializable_type("stateful_obj",
            function (x) {
                return x instanceof My;
            },
            My.superclass.serialize,
            function (obj) {
                var rest_args = _.rest(arguments);
                var builtins = _.extend({}, My.builtins, My.superclass.constructor.builtins);

                var serialized_options = {};
                _.each(builtins, function (builtin, name) {
                    serialized_options[name] = obj[name];
                });

                var rv = new My({uid: obj.uid}, true),
					old_initialize = proto.initialize;
                rv.initialize = function () {
                    var options = {};
                    _.each(serialized_options, function (serialized_option, name) {
                        options[name] = ist.deserialize.apply(ist, ([serialized_option]).concat(rest_args));
                    });
					old_initialize.call(this, options);
                };

                return rv;
            });
    }(ist.StatefulObj));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;
    
    ist.StatefulProp = function (options, defer_initialization) {
		ist.StatefulProp.superclass.constructor.apply(this, arguments);
    };
    (function (My) {
		_.proto_extend(My, ist.BasicObject);
        var proto = My.prototype;
    
        proto.initialize = function (options) {
			My.superclass.initialize.apply(this, arguments);
            ist.install_instance_builtins(this, options, My);
            this.get_direct_values().setHash("hash");
        };
    
        My.builtins = {
            "direct_values": {
                "default": function () { return cjs.map(); },
                env_visible: false,
				destroy: function(me) {
					me.forEach(function(val) {
						val.destroy(true);
					});
					me.destroy(true);
				}
            },
    
            "can_inherit": {
                "default": function () { return true; }
            },
    
            "statechart_parent": {
                "default": function () {
                    return "parent";
                },
				destroy: function(me) {
				}
            }
        };
    
        ist.install_proto_builtins(proto, My.builtins);
    
        //
        // === PARENTAGE ===
        //
    
        var state_basis = function (state) {
            var basis = state.basis();
            if (_.isUndefined(basis)) {
                basis = state;
            }
            return basis;
        };
    
    
        //
        // === DIRECT VALUES ===
        //
        proto.set = proto._set_direct_value_for_state = function (state, value) {
			if(value instanceof ist.Cell) {
				if(!this.get_can_inherit()) {
					value.set_ignore_inherited_in_first_dict(true);
				}
			}
            state = state_basis(state);
            this.get_direct_values().put(state, value);
        };
		proto.clone = function(cprop) {
			var infos = cprop.get_values();
			var keys = [];
			var vals = [];
			_.each(infos, function(info) {
				keys.push(info.state.basis());
				vals.push(info.value.clone());
			});
			var direct_values = cjs.map({
				keys: keys,
				values: vals
			});
			var rv = new ist.StatefulProp({
				direct_values: direct_values
			});
			return rv;
		};
        proto.unset = proto._unset_direct_value_for_state = function (state) {
            var dvs = this.get_direct_values();
            state = state_basis(state);
            dvs.remove(state);
        };
        proto._direct_value_for_state = function (state) {
            state = state_basis(state);
            return this.get_direct_values().get(state);
        };
        proto._has_direct_value_for_state = function (state) {
            state = state_basis(state);
            return this.get_direct_values().has(state);
        };
        
        proto.destroy = function () {
			if(this.constructor === My) { this.begin_destroy(); }

			ist.unset_instance_builtins(this, My);

			My.superclass.destroy.apply(this, arguments);
        };
    
        ist.register_serializable_type("stateful_prop",
            function (x) {
                return x instanceof My;
            },
            function (include_uid) {
                var args = _.toArray(arguments);
                var rv = {
                    //direct_values: ist.serialize.apply(ist, ([this.get_direct_values()]).concat(arg_array))
                    //can_inherit: ist.serialize.apply(ist, ([this._can_inherit]).concat(args))
                    //ignore_inherited_in_contexts: ist.serialize.apply(ist, ([this._ignore_inherited_in_contexts]).concat(args))
                    //, check_on_nullify: ist.serialize.apply(ist, ([this._check_on_nullify]).concat(args))
                };
                _.each(My.builtins, function (builtin, name) {
                    if (builtin.serialize !== false) {
                        var getter_name = builtin._get_getter_name();
                        rv[name] = ist.serialize.apply(ist, ([this[getter_name]()]).concat(args));
                    }
                }, this);
                if (include_uid) {
                    rv.uid = this.id();
                }
                return rv;
            },
            function (obj, options) {
                var rv = new My({uid: obj.uid}, true);
    
                var serialized_options = {};
                _.each(My.builtins, function (builtin, name) {
                    if (builtin.serialize !== false) {
                        serialized_options[name] = obj[name];
                    }
                });
    
                var rest_args = _.rest(arguments, 2);
				var old_initialize = proto.initialize;
                rv.initialize = function () {
					delete this.initialize;
                    options = _.extend({
                        //direct_values: ist.deserialize.apply(ist, ([obj.direct_values]).concat(rest_args))
                    //	can_inherit: ist.deserialize.apply(ist, ([obj.can_inherit, options]).concat(rest_args))
                    //	, ignore_inherited_in_contexts: ist.deserialize.apply(ist, ([obj.ignore_inherited_in_contexts, options]).concat(rest_args))
                    //	, check_on_nullify: ist.deserialize.apply(ist, ([obj.check_on_nullify, options]).concat(rest_args))
                    }, options);
                    _.each(serialized_options, function (serialized_option, name) {
                        options[name] = ist.deserialize.apply(ist, ([serialized_option, options]).concat(rest_args));
                    });
					old_initialize.call(this, options);
					options = null;
                };
                return rv;
            });
    }(ist.StatefulProp));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.find_stateful_obj_and_context = function (context) {
		var popped_item, last;
		while (!context.is_empty()) {
			last = context.points_at();
			if (last instanceof ist.StatefulObj) {
				return {
					stateful_obj: last,
					context: context
				};
			}
			popped_item = last;
			context = context.pop();
		}
		return undefined;
	};

	ist.Pointer = function (options) {
		this._stack = (options && options.stack) || [];
		this._hashes = (options && options.hashes) || [];
		this._special_contexts = (options && options.special_contexts) || new Array(this._stack.length);

		if (this._stack.length !== this._special_contexts.length) {
			throw new Error("Different lengths for stack and special contexts");
		}
	};
	(function (my) {
		var proto = my.prototype;
		proto.points_at = function (index) {
			if (!_.isNumber(index)) {
				index = this._stack.length - 1;
			} else if (index < 0) {
				index += this._stack.length;
			}
			return this._stack[index];
		};
		proto.length = function () { return this._stack.length; };
		proto.special_contexts = function (index) {
			if (!_.isNumber(index)) {
				index = this._special_contexts.length - 1;
			} else if (index < 0) {
				index += this._special_contexts.length;
			}
			return this._special_contexts[index] || [];
		};
		proto.has_special_contexts = function(index) {
			if (!_.isNumber(index)) {
				index = this._special_contexts.length - 1;
			}
			return _.isArray(this._special_contexts[index]);
		};
		proto.raw_last_special_contexts = function(index) {
			return this._special_contexts[this._special_contexts.length-1];
		};
		proto.slice = function () {
			return new ist.Pointer({
				stack: this._stack.slice.apply(this._stack, arguments),
				special_contexts: this._special_contexts.slice.apply(this._special_contexts, arguments),
				hashes: this._hashes.slice.apply(this._hashes, arguments)
			});
		};
		proto.splice = function () {
			var stack_copy = _.clone(this._stack),
				special_contexts_copy = _.clone(this._special_contexts),
				hashes_copy = _.clone(this._hashes);

			stack_copy.splice.apply(stack_copy, arguments);
			special_contexts_copy.splice.apply(special_contexts_copy, arguments);
			hahes_copy.splice.apply(hashes_copy, arguments);
			return new ist.Pointer({
				stack: stack_copy,
				special_contexts: special_contexts_copy,
				hashees: hashes_copy
			});
		};
		proto.push = function (onto_stack, onto_special_contexts) {
			var new_special_contexts;
			if (onto_special_contexts) {
				if(_.isArray(onto_special_contexts)) {
					if(onto_special_contexts.length > 0) {
						new_special_contexts = this._special_contexts.concat([onto_special_contexts]);
					} else {
						new_special_contexts = this._special_contexts.concat(undefined);
					}
				} else {
					new_special_contexts = this._special_contexts.concat([[onto_special_contexts]]);
				}
			} else {
				new_special_contexts = this._special_contexts.concat(undefined);
			}
			return new ist.Pointer({
				stack: this._stack.concat(onto_stack),
				special_contexts: new_special_contexts,
				hashes: _.clone(this.hashes)
			});
		};
		proto.push_special_context = function (special_context) {
			var new_special_contexts_obj = _.clone(this._special_contexts);
			var len_m_1 = new_special_contexts_obj.length - 1;
			var nscolm1 = new_special_contexts_obj[len_m_1];
			if (nscolm1) {
				new_special_contexts_obj[len_m_1] = nscolm1.concat(special_context);
			} else {
				new_special_contexts_obj[len_m_1] = [special_context];
			}
			return new ist.Pointer({
				stack: this._stack,
				special_contexts: new_special_contexts_obj,
				hashes: _.clone(this.hashes)
			});
		};
		proto.pop = function () {
			var len_minus_1 = this._stack.length-1;
			return new ist.Pointer({
				stack: this._stack.slice(0, len_minus_1),
				special_contexts: this._special_contexts.slice(0, len_minus_1),
				hashes: this._hashes.slice(0, len_minus_1)
			});
		};
		proto.has = function (item) {
			return this.indexOf(item) >= 0;
		};
		proto.indexOf = function (item) {
			return this._stack.indexOf(item);
		};
		proto.lastIndexOf = function (item) {
			return this._stack.lastIndexOf(item);
		};
		proto.root = function () {
			return this._stack[0];
		};

		proto.is_empty = function () {
			return this._stack.length === 0;
		};

		proto.eq = function (other) {
			if(this === other) {
				return true;
			} else if(this.hash() !== other.hash()) {
				return false;
			} else  {
				var my_stack = this._stack,
					other_stack = other._stack,
					my_stack_len = my_stack.length,
					other_stack_len = other_stack.length;

				if (my_stack_len !== other_stack_len) {
					return false;
				}
				var i, j;
				for (i = my_stack_len - 1; i >= 0; i -= 1) {
					if (my_stack[i] !== other_stack[i]) {
						return false;
					}

					var my_special_contexts = this._special_contexts[i],
						other_special_contexts = other._special_contexts[i];
					if (my_special_contexts && other_special_contexts) {
						var my_len = my_special_contexts.length;
						if (my_len !== other_special_contexts.length) {
							return false;
						}
						for (j = 0; j < my_len; j++) {
							if (!my_special_contexts[j].eq(other_special_contexts[j])) {
								return false;
							}
						}
					} else if (my_special_contexts || other_special_contexts) { // One is an array and the other is not, assumes the previous IF FAILED
						return false;
					}
				}
				return true;
			}
		};

		var num_to_hash = 2;
		proto.compute_hash = function () {
			var hash = 0,
				i = this._stack.length - 1,
				mini = Math.max(0, i - num_to_hash);

			while(i >= mini) {
				hash += this.itemHash(i--);
			}

			return hash;
		};

		proto.compute_item_hash = function(i) {
			var hash = 1, j = 0, lenj, sc = this._special_contexts[i];
			if(this._stack[i].hash) {
				hash += this._stack[i].hash();
			}

			if (sc) {
				lenj = sc.length;

				while(j < lenj) {
					hash += sc[j++].hash();
				}
			}
			return hash;
		};

		/* jshint -W093 */
		proto.hash = function() {
			return this.computed_hash || (this.computed_hash = this.compute_hash());
		};
		proto.itemHash = function(i) {
			return this._hashes[i] || (this._hashes[i] = this.compute_item_hash(i));
		};
		/* jshint +W093 */

		proto.toString = function () {
			return "pointer (" + _.map(this._stack, function (x, i) {
				var id = x.id ? uid.strip_prefix(x.id()) : x.toString(),
					sc = this._special_contexts[i];
				if(sc) {
					_.each(sc, function(c) {
						if(c instanceof ist.CopyContext) {
							id += "[" + c.get_copy_num() + "]";
						}
					});
				}
				return id;
			}, this).join(", ") + ")";
		};

		proto.getContextualObjects = function() {
			return _.map(this._stack, function(item, i) {
				return ist.find_or_put_contextual_obj(item, this.slice(0, i+1));
			}, this);
		};

		proto.summarize = function () {
			var stack_ids = _.map(this._stack, function (x) {
				return x.id();
			});
			var special_context_infos = _.map(this._special_contexts, function (sc) {
				if (_.isArray(sc)) {
					return _.map(sc, function (c) {
						if (c instanceof ist.CopyContext) {
							return {
								type: "manifestation_context",
								index: c.get_copy_num()
							};
						} else if (c instanceof ist.StateContext) {
							return {
								type: "event_context"
							};
						} else {
							console.error("Unknown special context type");
						}
					});
				} else {
					return undefined;
				}
			});
			return {
				stack_ids: stack_ids,
				special_context_info: special_context_infos
			};
		};

		my.desummarize = function (obj) {
			var stack = _.map(obj.stack_ids, function (stack_id) {
				return ist.find_uid(stack_id);
			});
			var i;
			var special_contexts = [];
			var special_context_info = obj.special_context_info;
			var each_special_context_info_item = function (info) {
				if (info.type === "manifestation_context") {
					var pointer = ist.create("pointer", {stack: stack.slice(0, i)});
					var dict = stack[i];
					var manifestations = dict.get_manifestations(pointer);
				} else {
					console.error("Unhandled special context type");
				}
			};
			
			for (i = 0; i < special_context_info.length; i += 1) {
				if (_.isArray(special_context_info[i])) {
					special_contexts[i] = _.map(special_context_info[i], each_special_context_info_item);
				} else {
					special_contexts[i] = undefined;
				}
			}
			var rv = ist.create("pointer", {stack: stack, special_contexts: special_contexts});
			return rv;
		};
	}(ist.Pointer));

	ist.is_pointer = function (obj) {
		return obj instanceof ist.Cell || obj instanceof ist.StatefulProp;
	};


	ist.check_pointer_equality =  ist.check_pointer_equality_eqeqeq = function (itema, itemb) {
		if (itema instanceof ist.Pointer && itemb instanceof ist.Pointer) {
			return itema.eq(itemb);
		} else {
			return itema === itemb;
		}
	};

	ist.pointer_hash = function(item) {
		if(item && item.hash) {
			return item.hash();
		} else {
			return item.toString();
		}
	};
	ist.check_special_context_equality = function (sc1, sc2) {
		var sc1_len = sc1.length,
			sc2_len = sc2.length;
		var i;
		if (sc1_len === sc2_len) {
			for (i = sc1_len - 1; i >= 0; i -= 1) {
				if (!sc1[i].eq(sc2[i])) {
					return false;
				}
			}
			return true;
		} else {
			return false;
		}
	};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var scid = 0;

	ist.SpecialContext = function () {
		this._id = "c" + (scid += 1);
		this.context_obj = {};
	};
	(function (My) {
		var proto = My.prototype;
		proto.id = proto.hash = function () {
			return this._id;
		};
		proto.get_context_obj = function () {
			return this.context_obj;
		};
		proto.eq = function (other_context) {
			return this === other_context;
		};
	}(ist.SpecialContext));

	ist.ProvisionalContext = function (values) {
		this.values = values || {};
	};
	(function (My) {
		_.proto_extend(My, ist.SpecialContext);
		var proto = My.prototype;
		proto.has = function (name) {
			return this.values.hasOwnProperty(name);
		};
		proto.get = function (name) {
			return this.values[name];
		};
		proto.set = function (name, value) {
			this.values[name] = value;
		};
		proto.eq = function(other_context) {
			return other_context instanceof My;
		};
	}(ist.ProvisionalContext));

/*
	var ec_counter = 1;
	ist.EventContext = function (event) {
		ist.EventContext.superclass.constructor.apply(this, arguments);
		this.event = event;
		this.context_obj = {
			event: { value: event }
		};
	};

	(function (My) {
		_.proto_extend(My, ist.SpecialContext);
		var proto = My.prototype;
		proto.get_event = function () {
			return this.event;
		};
	}(ist.EventContext));
	*/

	ist.StateContext = function (state) {
		ist.StateContext.superclass.constructor.apply(this, arguments);
		this.state = state;
		this.context_obj = {
			event: { value: state._last_run_event }
		};
	};

	(function (My) {
		_.proto_extend(My, ist.SpecialContext);
		var proto = My.prototype;
		proto.get_state = function () {
			return this.state;
		};
		proto.get_event = function () {
			var state = this.get_state();
			return state.get_event();
		};
		proto.eq = function(other_context) {
			return other_context instanceof My && other_context.state === this.state;
		};
		proto.hash = function() {
			return this.state.hash();
		};
	}(ist.StateContext));

	ist.CopyContext = function (owner, my_copy, copy_num, options) {
		ist.CopyContext.superclass.constructor.apply(this, arguments);
		this.my_copy = my_copy;
		this.copy_num = copy_num;
		this.context_obj = {
			my_copy: _.extend({
				value: my_copy
			}, options),
			copy_num: _.extend({
				value: copy_num
			}, options)
		};
		this._owner = owner;
	};
	(function (My) {
		_.proto_extend(My, ist.SpecialContext);
		var proto = My.prototype;
		proto.get_copy_num = function () {
			return this.copy_num;
		};
		proto.hash = function () {
			return this.copy_num+1;
		};
	}(ist.CopyContext));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;


	ist.ContextualObject = function (options) {
		var id = uid();

		ist.register_uid(id, this);

		this._id = id;
        this._hash = uid.strip_prefix(id);
		this._initialized = false;
		this._destroyed = false;
		this._type = "none";
		this._cobj_children = cjs.map({
			hash: function(x) { return x.hash(); },
			equals: function(a, b) {
				return a.eq(b);
			}
		});

		able.make_this_listenable(this);

		this.object = options.object;
		this.pointer = options.pointer;
		this.inherited_from = options.inherited_from || false;


		this.$value = new cjs.Constraint(this._getter, {
			context: this,
			check_on_nullify: options && (options.check_on_nullify === true),
			equals: (options && options.equals) || undefined
		});
		this._do_destroy_no_args = function() { this.destroy(); };
		this.object.on("begin_destroy", this._do_destroy_no_args, this);

		//if(this.sid() === 2440) { debugger; }
		//if(this.sid() === 2770) { debugger; }

		if(options.defer_initialization !== true) {
			this.initialize(options);
		}
	};

	(function (My) {
		var proto = My.prototype;
		able.make_proto_listenable(proto);
		proto.initialize = function(options) {
			if(this.constructor === My) { this.flag_as_initialized();  }
			if(this.constructor === My) { this.shout_initialization();  }
		};
		proto.flag_as_initialized = function() {
			this._initialized = true;
		};
		proto.shout_initialization = function() {
			this._emit("initialized", this);
		};
		proto.is_initialized = function() {
			return this._initialized;
		};
		proto.is_inherited = function() {
			return this.inherited_from;
		};
		proto.is_template = function() { return false; };
		proto.instances = function() { return false; };
		proto.get_name = function() {
			var pointer = this.get_pointer(),
				my_index = pointer.indexOf(this.get_object()),
				parent_obj, parent_pointer, name;

			if(my_index === 0) {
				return ist.root_name;
			} else {
				parent_obj = pointer.points_at(my_index-1);
				parent_pointer = pointer.slice(0, my_index-1);
				if(parent_obj instanceof ist.Dict) {
					name = ist.Dict.get_prop_name(parent_obj, this.get_object(), this.get_pointer().pop());
					return name;
				}
			}
		};
		proto.get_colloquial_name = function() {
			var pointer = this.get_pointer();
			var my_index = pointer.indexOf(this.get_object());
			if(my_index === 0) {
				return "(" + ist.root_name + ")";
			} else {
				var parent_obj = pointer.points_at(my_index-1);
				var parent_pointer = pointer.slice(0, my_index-1);
				if(parent_obj instanceof ist.Dict) {
					var sp_contexts = pointer.special_contexts();
					var extra_txt = "";
					if(sp_contexts.length > 0) {
						var sp_context;
						for(var i = 0; i<sp_contexts.length; i++) {
							sp_context = sp_contexts[i];
							if(sp_context instanceof ist.CopyContext) {
								extra_txt = "[" + sp_context.copy_num + "]";
								break;
							}
						}
					}
					var name = ist.Dict.get_prop_name(parent_obj, this.get_object(), this.get_pointer().pop());

					return "("+name+extra_txt+")";
				} else {
					return "(object)";
				}
			}
		};

		proto.id = function () { return this._id; };
		proto.hash = function() { return this._hash; };
		proto.sid = function() { return parseInt(uid.strip_prefix(this.id()), 10); };
		proto.get_pointer = function () { return this.pointer; };
		proto.get_object = function () { return this.object; };
		proto.is_destroyed = function() { return this._destroyed; };
		proto._getter = function () { return this.get_object(); };
		proto.type = function () { return this._type; };
		proto.val = function () { return this.$value.get(); };

		proto.summarize = function () {
			var pointer = this.get_pointer(),
				object = this.get_object(),
				summarized_pointer = pointer.summarize(),
				summarized_object = object.id();
			return {
				id: this.id(),
				pointer: summarized_pointer,
				object_uid: summarized_object,
				obj_id: object.id(),
				type: this.type()
			};
		};

		proto.desummarize = function (obj) {
			var pointer = ist.Pointer.desummarize(obj.pointer),
				object = ist.find_uid(obj.object_uid);
			return ist.find_or_put_contextual_obj(object, pointer);
		};

		proto.toString = function () {
			return "p_" + this.get_pointer().toString();
		};

		proto.emit_begin_destroy = function() {
			this._emit("begin_destroy", this);
		};

		proto.begin_destroy = function(silent) {
			this.$value.setOption("check_on_nullify", false); // don't re-evaluate on nullification

			if(this.object) {
				this.object.off("begin_destroy", this._do_destroy_no_args, this);
				delete this._do_destroy_no_args;
			}
			var to_destroy = this._cobj_children.values();
			_.each(to_destroy, function(cobj) {
				cobj.off("begin_destroy", this.remove_cobj_child, this);
				cobj.begin_destroy(true);
			}, this);

			this.emit_begin_destroy();
		};

		proto.destroy = function (avoid_begin_destroy) {
			if(this.constructor === My && !avoid_begin_destroy) { this.begin_destroy(true); }

			//if(this.sid() === 2440) { debugger; }
			//if(this.sid() === 2770) { debugger; }


			var to_destroy = this._cobj_children.values();
			_.each(to_destroy, function(cobj) {
				cobj.destroy(true); // avoid begin destroy call
			});

			this._cobj_children.clear();

			this._destroyed = true;

			ist.remove_cobj_cached_item(this);

			this.$value.destroy(true);
			delete this.object;
			delete this.pointer;
			delete this.inherited_from;
			delete this.$value;
			ist.unregister_uid(this.id());
			this._emit("destroyed");
			able.destroy_this_listenable(this);
		};

		proto._get_valid_cobj_children = function() { return []; };


		proto.update_cobj_children = function(recursive) {
			cjs.wait();
			var valid_children = this._get_valid_cobj_children(),
				to_destroy = {},
				to_initialize = [],
				remove_from_destroy_list = _.bind(function(obj, ptr, options) {
					var cobj = this._cobj_children.get(ptr);

					if(cobj) {
						to_destroy[cobj.id()] = false;

						if(cobj instanceof ist.ContextualDict && cobj.is_template()) {
							var instances = cobj.instances();

							_.each(instances, function(instance) {
								remove_from_destroy_list(instance.get_object(), instance.get_pointer());
							}, this);
						}
					} else {
						cobj = ist.create_contextual_object(obj, ptr, _.extend({
								defer_initialization: true
							}, options));
						this._cobj_children.put(ptr, cobj);
						cobj.on("begin_destroy", this.remove_cobj_child, this, ptr);
						to_initialize.push(cobj);
					}
				}, this);

			this._cobj_children.forEach(function(cobj, ptr) {
				to_destroy[cobj.id()] = cobj;
			});

			_.each(valid_children, function(valid_child) {
				remove_from_destroy_list(valid_child.obj, valid_child.pointer, valid_child.options);
			}, this);

			_.each(to_initialize, function(cobj) {
				cobj.initialize();
				if(cobj instanceof ist.ContextualDict && cobj.is_template()) {
					var instances = cobj.instances();

					_.each(instances, function(instance) {
						remove_from_destroy_list(instance.get_object(), instance.get_pointer());
					}, this);
				}
			}, this);

			var to_destroy_list = _.compact(_.values(to_destroy));

			_.each(to_destroy_list, function(cobj) {
				cobj.begin_destroy();
			});
			_.each(to_destroy_list, function(cobj) {
				cobj.destroy(true);
			});

			this.updateAttachments();
			cjs.signal();
		};

		proto.get_or_put_cobj_child = function (obj, special_contexts, hash, options, avoid_initialization) {
			var ptr = this.pointer.push(obj, special_contexts),
				must_initialize = false,
				cobj = this._cobj_children.getOrPut(ptr, function() {
					var rv = ist.create_contextual_object(obj, ptr, _.extend({
						defer_initialization: true
					}, options));
					must_initialize = true;
					return rv;
				});

			if(must_initialize) {
				if(avoid_initialization !== true) {
					cobj.initialize();
				}

				cobj.on("begin_destroy", this.remove_cobj_child, this, ptr);
			}

			return cobj;
		};

		proto.remove_cobj_child = function(ptr, silent) {
			this._cobj_children.remove(ptr, silent);
		};

		proto.pause  = function(recursive) {};
		proto.resume = function(recursive) {};

		proto.updateAttachments = function(){};

		proto.toString = function() {
			return My + " " + this.id();
		};
		proto.print = function (logging_mechanism) {
			return ist.print(this.pointer, logging_mechanism);
		};
	}(ist.ContextualObject));

	ist.check_contextual_object_equality =  ist.check_contextual_object_equality_eqeqeq = function (itema, itemb) {
		if (itema instanceof ist.ContextualObject && itemb instanceof ist.ContextualObject) {
			return itema.get_pointer().eq(itemb.get_pointer()) && itema.get_object() === itemb.get_object();
		} else {
			return itema === itemb;
		}
	};

	ist.create_contextual_object = function (object, pointer, options) {
		options = _.extend({
			object: object,
			pointer: pointer
		}, options);

		var rv;
		if (object instanceof ist.Cell) {
			rv = new ist.ContextualCell(options);
		} else if (object instanceof ist.StatefulProp) {
			rv = new ist.ContextualStatefulProp(options);
		} else if (object instanceof ist.StatefulObj) {
			rv = new ist.ContextualStatefulObj(options);
		} else if (object instanceof ist.Dict) {
			rv = new ist.ContextualDict(options);
		} else {
			rv = new ist.ContextualObject(options);
		}

		return rv;
	};

	var cobj_hashes = cjs.map({
			equals: function(a, b) {
				return a.eq(b);
			},
			hash: function(ptr){  
				return ptr.hash();
			}
		}),
		cobj_roots = {};


	ist.find_or_put_contextual_obj = function (obj, pointer, options) {
		if(!pointer) {
			pointer = new ist.Pointer({stack: [obj]});
		}

		var must_initialize = false,
			rv = cobj_hashes.getOrPut(pointer, function() {
			var len = pointer.length(),
				pointer_root, hvi, i, ptr_i, sc_i, hash_i, new_cobj, node, opts;

			pointer_root = pointer.root();
			hash_i = pointer_root.id();
			node = cobj_roots[hash_i];

			//must_initialize = true;

			if(!node) {
				if(len === 1) {
					node = cobj_roots[hash_i] = ist.create_contextual_object(obj, pointer, _.extend({
						defer_initialization: true
					}, options));
				} else {
					node = ist.find_or_put_contextual_obj(pointer_root, pointer.slice(0,1));
				}
			/*
				opts = {
					object: pointer_root,
					pointer: pointer.slice(0, 1),
					defer_initialization: true
				};
				*/
				/*

				if(pointer_root instanceof ist.StatefulObj) {
					node =  = new ist.ContextualStatefulObj(opts);
				} else if(pointer_root instanceof ist.Dict) {
					node = cobj_roots[hash_i] = new ist.ContextualDict(opts);
				} else {
					throw new Error("Root pointer should be a dictionary");
				}
				//must_initialize.push(node);
				if(len > 1) {
					node.initialize();
				}
				*/
			}

			i = 1;
			
			while (i < len) {
				ptr_i = pointer.points_at(i);
				sc_i = pointer.special_contexts(i);
				hash_i = pointer.itemHash(i);
				//debugger;
				node = node.get_or_put_cobj_child(ptr_i, sc_i, hash_i, i === len-1 ? options : false);//, i === len-1 ? true : false);
				i++;
			}

			//if(node.sid() === 2440) { debugger; }

			return node;
		});

		if(must_initialize) {
			rv.initialize();
		}

		return rv;
	};

	ist.remove_cobj_cached_item = function(cobj) {
		var pointer = cobj.get_pointer(),
			obj = cobj.get_object();

		cobj_hashes.remove(pointer); // TODO: fix
		//cobj_hashes.remove(pointer);
		//cobj_hashes.remove(pointer);
		//cobj_hashes.remove(pointer);
		//cobj_hashes.remove(pointer);

		if(pointer.length() === 1) {
			delete cobj_roots[obj.id()];
			cobj_hashes.clear();
			cobj_hashes.destroy();
		}
	};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,RedSet,RedMap */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var proto_eq = function (a, b) {
		var i;
		if (_.isArray(a) && _.isArray(b)) {
			var len = a.length;
			if (len !== b.length) {
				return false;
			}
		
			for (i = 0; i < len; i += 1) {
				if (a[i] !== b[i]) {
					return false;
				}
			}
			return true;
		} else {
			return a === b;
		}
	};
	var get_cobj_object = function (x) {
			if (x && x instanceof ist.ContextualDict) {
				return x.get_object();
			} else {
				return false;
			}
		},
		is_cdict = function (x) {
			return x && x instanceof ist.ContextualDict;
		};
	ist.Dict.get_proto_vals = function (cobj, non_recursive) {
		var originalCobj = cobj,
			rv = new RedSet({
				value: [originalCobj],
				hash: "hash",
				equals: ist.check_contextual_object_equality
			}),
			i = 0,
			dict, proto_val, proto_cobj, rv_arr;
		

		while (i < rv.len()) {
			cobj = rv.item(i);
			if(cobj instanceof ist.ContextualDict) {
				proto_cobj = cobj.proto_cobj();
			} else {
				proto_cobj = [];
			}

			if(proto_cobj instanceof ist.ContextualObject) {
				proto_val = proto_cobj.val();
			} else {
				proto_val = proto_cobj;
			}

			if(!_.isArray(proto_val)) {
				proto_val = [proto_val];
			}

			proto_val = _.filter(proto_val, is_cdict);

			rv.add_at.apply(rv, ([i + 1].concat(proto_val)));
			i++;

			if(non_recursive) { break; }
		}
		rv_arr = rv.toArray();

		return rv_arr.slice(1); // don't include the original dict
	};

	ist.Dict.get_prop_name = function (dict, value, pcontext) {
		var direct_props = dict.direct_props(),
			rv = direct_props.keyForValue({value: value}),
			cobj, i, protos, protoi, len;

		if (_.isUndefined(rv) && pcontext) {
			cobj = ist.find_or_put_contextual_obj(dict, pcontext);
			protos = cobj.get_all_protos();
			for (i = 0, len = protos.length; i < len; i++) {
				protoi = protos[i];
				rv = protoi.get_direct_prop_name(value);

				if (!_.isUndefined(rv)) {
					break;
				}
			}
		}
		return rv;
	};

	ist.Dict.get_prop_info = function (dict, prop_name, pcontext) {
		if (dict._has_builtin_prop(prop_name)) {
			return dict._get_builtin_prop_info(prop_name);
		} else if (dict._has_direct_prop(prop_name)) {
			return dict._get_direct_prop_info(prop_name);
		} else if (dict._has_special_context_prop(prop_name, pcontext)) {
			return dict._get_special_context_prop_info(prop_name, pcontext);
		} else {
			return this._get_inherited_prop_info(prop_name, pcontext);
		}
	};

	ist.Dict.get_prop = function (dict, prop_name, pcontext) {
		var info = ist.Dict.get_prop_info(dict, prop_name, pcontext);
		if (info) {
			return info.value;
		} else {
			return undefined;
		}
	};

	var get_contextual_object = function (value, pointer, options) {
		var value_ptr = pointer.push(value);

		if (value instanceof ist.Dict || value instanceof ist.Cell || value instanceof ist.StatefulProp) {
			var contextual_object = ist.find_or_put_contextual_obj(value, value_ptr, options);
			return contextual_object;
		} else {
			return value;
		}
	};

	ist.get_dom_obj = function(cdict) {
		if(cdict.get_dom_obj) {
			return cdict.get_dom_obj();
		} else {
			return false;
		}
	};

	ist.ContextualDict = function (options) {
		this.inherits_from = cjs.memoize(this._inherits_from, {context: this});
		this.get_all_protos = cjs.memoize(this._get_all_protos, {context: this});
		this.get_dom_obj_and_src = cjs.memoize(this._get_dom_obj_and_src, {context: this});
		this.prop_val = cjs.memoize(this._prop_val, {context: this});
		this.prop = cjs.memoize(this._prop, {context: this});
		this.children = cjs.memoize(this._children, {context: this});
		this.instances = cjs.memoize(this._instances, {context: this});
		this.is_template = cjs.memoize(this._is_template, {context: this});
		this.get_dom_children = cjs.memoize(this._get_dom_children, {context: this});
		this.has = cjs.memoize(this._has, {context: this});
		this._attachment_instances = { };
		this._manifestation_objects = new RedMap({ });
		ist.ContextualDict.superclass.constructor.apply(this, arguments);
		this._type = "dict";
	};

	(function (My) {
		_.proto_extend(My, ist.ContextualObject);
		var proto = My.prototype;
		proto.initialize = function() {
			if(this.constructor === My) { this.flag_as_initialized();  }
			My.superclass.initialize.apply(this, arguments);
			if(ist.__garbage_collect) {
				this._live_cobj_child_updater = cjs.liven(function() {
					this.update_cobj_children();
				}, {
					context: this,
					priority: 2,
					pause_while_running: true
				});
			}
			if(this.constructor === My) { this.shout_initialization();  }
		};

		proto.proto_cobj = function() {
			var obj = this.get_object(),
				proto_obj = obj.direct_protos(),
				pointer, proto_cobj;
			
			if(cjs.isArrayConstraint(proto_obj)) {
				return proto_obj.toArray();
			} else if(proto_obj) {
				pointer = this.get_pointer();
				return ist.find_or_put_contextual_obj(proto_obj, pointer.push(proto_obj), {
					check_on_nullify: true,
					equals: proto_eq
				});
			} else {
				return [];
			}
		};

		proto.has_copies = function() {
			var dict = this.object;
			return dict.has_copies();
		};

		proto._get_all_protos = function(avoid_recursion) {
			if(this.is_template()) {
				return [];
			}
			return ist.Dict.get_proto_vals(this, avoid_recursion);
		};

		proto.raw_children = function (exclude_builtins) {
			//console.log("-begin raw children-");
			var dict = this.get_object(),
				pointer = this.get_pointer(),
				my_ptr_index = pointer.lastIndexOf(dict),
				special_context_names = [],
				builtin_names = exclude_builtins === true ? [] : dict._get_builtin_prop_names(),
				direct_names = this.get_direct_prop_names(),
				owners = {},
				proto_objects = this.get_all_protos(true),
				inherited_names = [],
				i;

			//if(this.sid() === 25) {
				//console.log(proto_objects);
			//}
			//console.log("-end raw children-");

			_.each(builtin_names, function (name) {
				owners[name] = this;
			}, this);

			_.each(direct_names, function (name) {
				owners[name] = this;
			}, this);

			if (exclude_builtins !== true && my_ptr_index >= 0) {
				var special_contexts = pointer.special_contexts(my_ptr_index),
					len = special_contexts.length,
					sc, co,
					each_co = function (v, k) {
						if (!owners.hasOwnProperty(k)) {
							owners[k] = sc;
							special_context_names.push(k);
						}
					};

				for (i = 0; i < len; i++) {
					sc = special_contexts[i];
					co = sc.get_context_obj();
					_.each(co, each_co);
				}
			}

			_.each(proto_objects, function (p) {
				var p_children = p.raw_children(true);
				_.each(p_children, function(child_info) {
					var name = child_info.name;
					if (!owners.hasOwnProperty(name)) {
						owners[name] = p;
						inherited_names.push(name);
					}
				});
			}, this);


			var rv = [];
			_.each([
				["special_context", special_context_names],
				["builtin", builtin_names],
				["direct", direct_names],
				["inherited", inherited_names]
			], function (info) {
				var type = info[0],
					names = info[1],
					is_inherited = type==="inherited",
					is_builtin = type==="builtin" || type==="special_context",
					getter_fn, infos;

				if (type === "builtin") {
					infos = _.map(names, function (name) {
						return this.get_builtin_prop_info(name);
					}, this);
				} else if (type === "direct") {
					infos = _.map(names, function (name) {
						return this.prop_info(name, true);
					}, this);
				} else if (type === "inherited") {
					infos = _.map(names, function (name) {
						var owner = owners[name],
							value = owner.prop(name),
							value_obj = value instanceof ist.ContextualObject ? value.get_object() : value,
							info = {
								value: value_obj,
								owner: owner,
								inherited_from: value
							};
						return info;
					}, this);
				} else if (type === "special_context") {
					infos = _.map(names, function (name) {
						var sc = owners[name],
							co = sc.get_context_obj();
						return co[name];
					}, this);
				}

				var contextual_objects = _.map(infos, function (info, i) {
					var name = names[i];
					return {
						name: name,
						value: info.value,
						inherited_from: info.inherited_from || false,
						inherited: is_inherited,
						builtin: is_builtin
					};
				}, this);
				rv.push.apply(rv, contextual_objects);
			}, this);

			return rv;
		};
		proto.builtin_children = function() {
			if(this.is_template()) {
				// This is a bit of a hack; when "copies" changes from "" to "5", then my
				// children's contextual objects are destroyed. However, when I switch back
				// any constraints on the value of children aren't nullified.
				//
				// Adding the is_template() check ensures that they will be nullified
				return [];
			} else {
				var dict = this.object,
					pointer = this.pointer,
					my_ptr_index = pointer.lastIndexOf(dict),
					builtin_names = dict._get_builtin_prop_names(),
					special_context_names = [],
					owners = {},
					builtin_infos = _.map(builtin_names, function (name) {
						return dict._get_builtin_prop_info(name);
					}),
					builtin_contextual_objects = _.map(builtin_infos, function (info, i) {
						var name = builtin_names[i];
						return {name: name, value: info.value, inherited: false, builtin: true };
					}, this);

				if (my_ptr_index >= 0) {
					var special_contexts = pointer.special_contexts(my_ptr_index),
						len = special_contexts.length,
						sc, co, i,
						each_co = function (v, k) {
							owners[k] = sc;
							special_context_names.push(k);
						};

					for (i = 0; i < len; i += 1) {
						sc = special_contexts[i];
						co = sc.get_context_obj();
						_.each(co, each_co);
					}
				}

				var special_context_infos = _.map(special_context_names, function (name) {
							var sc = owners[name];
							var co = sc.get_context_obj();
							return co[name];
						}),
					special_context_contextual_objects = _.map(special_context_infos, function (info, i) {
						var name = special_context_names[i];
						return {name: name, value: info.value, inherited: false, builtin: true };
					}, this);
				
				var contextual_objects = special_context_contextual_objects.concat(builtin_contextual_objects),
					children = _.map(contextual_objects, function(raw_child) {
						var opts = {};
						if(raw_child.inherits_from) {
							opts.inherits_from = raw_child.inherits_from;
						}
						return _.extend({}, raw_child, {
							value: get_contextual_object(raw_child.value, pointer, opts)
						});
					});


				return children;
			}
		};

		proto._children = function (exclude_builtins) {
			if(this.is_template()) {
				// This is a bit of a hack; when "copies" changes from "" to "5", then my
				// children's contextual objects are destroyed. However, when I switch back
				// any constraints on the value of children aren't nullified.
				//
				// Adding the is_template() check ensures that they will be nullified
				return [];
			} else {
				var raw_children = this.raw_children(exclude_builtins);
				var pointer = this.pointer;
				var children = _.map(raw_children, function(raw_child) {
					var opts = {};
					if(raw_child.inherited_from) {
						opts.inherited_from = raw_child.inherited_from;
					}
					return _.extend({}, raw_child, {
						value: get_contextual_object(raw_child.value, pointer, opts)
					});
				});
				return children;
			}
		};
		proto.parent = function() {
			var popped_pointer = this.pointer.pop();
			var contextual_object = ist.find_or_put_contextual_obj(popped_pointer.points_at(), popped_pointer);
			return contextual_object;
		};
		proto._has = function (name, ignore_inherited) {
			if(this.is_template()) {
				return false;
			}

			var dict = this.get_object();
			var i;
			if (dict._has_direct_prop(name) || dict._has_builtin_prop(name)) {
				return true;
			} else if (ignore_inherited !== true) {
				var proto_objects = this.get_all_protos();
				if (_.any(proto_objects, function (d) { return d.has_direct_prop(name); })) {
					return true;
				}

				var pointer = this.get_pointer();
				var my_ptr_index = pointer.lastIndexOf(dict);
				if (my_ptr_index >= 0) {
					var special_contexts = pointer.special_contexts(my_ptr_index);
					var len = special_contexts.length;
					var sc, co;
					for (i = 0; i < len; i += 1) {
						sc = special_contexts[i];
						co = sc.get_context_obj();
						if (co.hasOwnProperty(name)) {
							return true;
						}
					}
				}
			}
			return false;
		};
		proto.prop_info = function (name, ignore_inherited) {
			var dict = this.get_object(),
				info,
				i,
				len;
			if (dict._has_builtin_prop(name)) {
				info = dict._get_builtin_prop_info(name);
			} else if (dict._has_direct_prop(name)) {
				info = dict._get_direct_prop_info(name);
			} else {
				var pointer = this.get_pointer();
				var my_ptr_index = pointer.lastIndexOf(dict);
				if (my_ptr_index >= 0) {
					var special_contexts = pointer.special_contexts(my_ptr_index);
					len = special_contexts.length;
					var sc, co;
					for (i = 0; i < len; i += 1) {
						sc = special_contexts[i];
						co = sc.get_context_obj();
						if (co.hasOwnProperty(name)) {
							info = co[name];
							break;
						}
					}
				}
				if (!info && ignore_inherited !== true) {
					var proto_objects = this.get_all_protos();
					len = proto_objects.length;
					var d;
					for (i = 0; i < len; i += 1) {
						d = proto_objects[i];
						if (d.has_direct_prop(name)) {
							info = _.extend({
										inherited_from: d
									}, d.get_direct_prop_info(name));
							break;
						}
					}
				}
			}
			return info;
		};
		proto._prop = function (name, ignore_inherited) {
			var info = this.prop_info(name, ignore_inherited);

			if (info) {

				var pointer = this.get_pointer();

				//if(window.dbg && pointer.hash() === 35) { debugger; }

				var opts = {};
				if(info.inherited_from) {
					opts.inherited_from = info.inherited_from;
				}

				var value = get_contextual_object(info.value, pointer, opts);

				//if(value.is_destroyed && value.is_destroyed()) { debugger; }

				return value;
			} else {
				return undefined;
			}
		};

		proto._prop_val = function (name, ignore_inherited) {
			var value = this.prop(name, ignore_inherited);

			if (value instanceof ist.ContextualObject) {
				return value.val();
			} else {
				return cjs.get(value);
			}
		};

		proto.copies_obj = function () {
			var object = this.get_object();
			var copies = object.get_copies();
			return copies;
		};

		proto.get_direct_prop_name = function(value) {
			var obj = this.get_object(),
				direct_props = obj.direct_props(),
				rv = direct_props.keyForValue({value: value});
			return rv;
		};

		proto.get_direct_prop_names = function() {
			var object = this.get_object();
			return object._get_direct_prop_names();
		};

		proto.get_builtin_prop_info = function(name) {
			var object = this.get_object();
			return object._get_builtin_prop_info(name);
		};

		proto.has_direct_prop = function(name) {
			var object = this.get_object();
			return object._has_direct_prop(name);
		};

		proto.get_direct_prop_info = function(name) {
			var object = this.get_object();
			return object._get_direct_prop_info(name);
		};

		proto.get_direct_attachments = function() {
			var object = this.get_object();
			return object.direct_attachments();
		};

		proto.get_manifestations_value = function () {
			var pointer = this.get_pointer();

			var manifestations = this.copies_obj();
			if (manifestations instanceof ist.Cell) {
				var constraint = manifestations.value_in_context(pointer);
				return cjs.get(constraint);
				//return constraint.get();
			/*
				var manifestations_pointer = pointer.push(manifestations),
					manifestations_contextual_object = ist.find_or_put_contextual_obj(manifestations, manifestations_pointer),
					manifestations_value = manifestations_contextual_object.val();
				manifestations_value = cjs.get(manifestations_value);
				return manifestations_value;
				*/
			} else {
				return cjs.get(manifestations);
			}
		};

		proto.is_instance = function() {
			var pointer = this.get_pointer(),
				object = this.get_object(),
				obj_index = pointer.lastIndexOf(object),
				i, special_contexts, special_context;

			if (obj_index >= 0) {
				special_contexts = pointer.special_contexts(obj_index);

				for (i = special_contexts.length - 1; i >= 0; i -= 1) {
					special_context = special_contexts[i];
					if (special_context instanceof ist.CopyContext) {
						return true;
					}
				}
			}
			return false;
		};

		proto._is_template = function () {
			if(this.is_instance()) {
				return false;
			} else {
				var manifestations_value = this.get_manifestations_value();
				return (_.isNumber(manifestations_value) && !isNaN(manifestations_value)) || _.isArray(manifestations_value);
			}
		};

		proto._inherits_from = function(cobj) {
			var proto_cobjs = this.get_all_protos(),
				rv = _.contains(proto_cobjs, cobj);
			return rv;
		};

		proto.is_instance = function () {
			var pointer = this.get_pointer();
			var object = this.get_object();
			var obj_index = pointer.lastIndexOf(object);
			var i;

			if (obj_index >= 0) {
				var special_contexts = pointer.special_contexts(obj_index);
				var special_context;
				for (i = special_contexts.length - 1; i >= 0; i -= 1) {
					special_context = special_contexts[i];
					if (special_context instanceof ist.CopyContext) {
						return true;
					}
				}
			}
			return false;
		};

		proto.get_template_info = function () {
			var pointer = this.get_pointer();
			var object = this.get_object();
			var obj_index = pointer.lastIndexOf(object);
			var i;

			if (obj_index >= 0) {
				var ptr = pointer.slice(0, obj_index);
				ptr = ptr.push(object);

				var special_contexts = pointer.special_contexts(obj_index);
				var special_context;
				for (i = special_contexts.length - 1; i >= 0; i -= 1) {
					special_context = special_contexts[i];
					if (special_context instanceof ist.CopyContext) {
						return {cobj: ist.find_or_put_contextual_obj(object, ptr), index: special_context.get_copy_num()};
					}
				}
			}
			return false;
		};

		proto.instance_pointers = function() {
			var manifestations_value = this.get_manifestations_value();
			var i;
			if (_.isNumber(manifestations_value)) {
				var len = manifestations_value;
				manifestations_value = [];

				for (i = 0; i < len; i += 1) {
					manifestations_value[i] = i;
				}
			}

			var pointer = this.get_pointer();
			var manifestation_pointers = _.map(manifestations_value, function (basis, index) {
					var manifestation_obj = this._manifestation_objects.get_or_put(basis, function () {
						return new ist.CopyContext(this, basis, index);
					}, this);
					var manifestation_pointer = pointer.push_special_context(manifestation_obj);
					return manifestation_pointer;
				}, this);

			return manifestation_pointers;
		};
		proto._instances = function () {
			var object = this.get_object();
			var instance_pointers = this.instance_pointers();
			var manifestation_contextual_objects = _.map(instance_pointers, function(instance_pointer) {
				var contextual_object = ist.find_or_put_contextual_obj(object, instance_pointer);
				return contextual_object;
			});

			return manifestation_contextual_objects;
		};

		proto.get_attachment_instance = function (type) {
			var info = this.get_attachment_instance_and_src(type);
			if(info) {
				var attachment = info.attachment;
				var attachment_instance;
				if (this._attachment_instances.hasOwnProperty(type)) {
					attachment_instance = this._attachment_instances[type];
					if(attachment_instance.get_creator() !== info.attachment) {
						attachment_instance.destroy();
						attachment_instance = this._attachment_instances[type] = attachment.create_instance(this, info.owner);
						attachment_instance.on_ready();
					}
				} else {
					attachment_instance = this._attachment_instances[type] = attachment.create_instance(this, info.owner);
					attachment_instance.on_ready();
				}
				return attachment_instance;
			} else {
				return undefined;
			}
		};

		proto.get_attachment_instance_and_src = function (type) {
			var info, attachment_instance;
			if(!this.is_template()) {
				var dict = this.get_object(),
					direct_attachments = dict.direct_attachments(),
					len = direct_attachments.length,
					attachment, i, j;

				for (i = 0; i < len; i += 1) {
					attachment = direct_attachments[i];
					if (attachment.get_type() === type) {
						info = {
							attachment: attachment,
							owner: dict
						};
						break;
					}
				}

				if (!info) {
					var proto_objects = this.get_all_protos();
					var plen = proto_objects.length;
					var proto_obj;

					outer_loop:
					for (i = 0; i < plen; i += 1) {
						proto_obj = proto_objects[i];
						direct_attachments = proto_obj.get_direct_attachments();
						len = direct_attachments.length;
						for (j = 0; j < len; j += 1) {
							attachment = direct_attachments[j];
							if (attachment.get_type() === type) {
								info = {
									attachment: attachment,
									owner: dict
								};
								break outer_loop;
							}
						}
					}
				}
			}

			if (info) {
				return info;
			} else {
				if (this._attachment_instances.hasOwnProperty(type)) {
					attachment_instance = this._attachment_instances[type];
					attachment_instance.destroy();
					delete this._attachment_instances[type];
				}
				return undefined;
			}
		};
		proto.updateAttachments = function() {
			this.get_attachment_instance("dom");
			this.get_attachment_instance("shape");
			this.get_attachment_instance("box2d_fixture");
		};

		proto._get_valid_cobj_children = function() {
			var rv = [],
				my_pointer = this.get_pointer(),
				is_template = this.is_template();

			if(!is_template) {
				var protos_objs = this.get_all_protos();
				rv.push.apply(rv, _.chain(protos_objs)
									.map(function(cobj) {
										if(cobj instanceof ist.ContextualDict) {
											var proto_cobj = cobj.proto_cobj();
											if(proto_cobj instanceof ist.ContextualObject) {
												return {obj: proto_cobj.get_object(), pointer: proto_cobj.get_pointer()};
											}
										}
									})
									.compact()
									.value());

				var child_infos = this.raw_children();
				_.each(child_infos, function(child_info) {
					var value = child_info.value,
						ptr, cobj, instances;

					if (value instanceof ist.Dict || value instanceof ist.Cell || value instanceof ist.StatefulProp) {
						ptr = my_pointer.push(value);
						rv.push({
							obj: value,
							pointer: ptr,
							options: {
								inherited_from: child_info.inherited_from
							}
						});
					}
				}, this);
			}

			return rv;
		};

		proto.begin_destroy = function() {
			//The attachment instances might be listening for property changes for destroy them first
			_.each(this._attachment_instances, function(attachment_instance, type) {
				attachment_instance.destroy(true);
				delete this._attachment_instances[type];
			}, this);
			delete this._attachment_instances;

			if(this._live_cobj_child_updater) {
				this._live_cobj_child_updater.destroy(true);
				delete this._live_cobj_child_updater;
			}


			My.superclass.begin_destroy.apply(this, arguments);
		};

		proto.destroy = function (avoid_begin_destroy) {
			if(this.constructor === My && !avoid_begin_destroy) { this.begin_destroy(true); }

			this._manifestation_objects.destroy(true);
			delete this._manifestation_objects;

			My.superclass.destroy.apply(this, arguments);

			// Sometimes I switch get_all_protos to a non-memoized form so check
			if(this.get_all_protos.destroy) {
				this.get_all_protos.destroy(true);
				delete this.get_all_protos.options.context;
				delete this.get_all_protos.options.args_map;
			}
			if(this.inherits_from.destroy) {
				this.inherits_from.destroy(true);
				delete this.inherits_from.options.context;
				delete this.inherits_from.options.args_map;
			}
			if(this.get_dom_obj_and_src.destroy) {
				this.get_dom_obj_and_src.destroy(true);
				delete this.get_dom_obj_and_src.options.context;
				delete this.get_dom_obj_and_src.options.args_map;
			}
			if(this.prop_val.destroy) {
				this.prop_val.destroy(true);
				delete this.prop_val.options.context;
				delete this.prop_val.options.args_map;
			}
			if(this.prop.destroy) {
				this.prop.destroy(true);
				delete this.prop.options.context;
				delete this.prop.options.args_map;
			}
			if(this.children.destroy) {
				this.children.destroy(true);
				delete this.children.options.context;
				delete this.children.options.args_map;
			}
			if(this.instances.destroy) {
				this.instances.destroy(true);
				delete this.instances.options.context;
				delete this.instances.options.args_map;
			}
			if(this.is_template.destroy) {
				this.is_template.destroy(true);
				delete this.is_template.options.context;
				delete this.is_template.options.args_map;
			}
			if(this.get_dom_children.destroy) {
				this.get_dom_children.destroy(true);
				delete this.get_dom_children.options.context;
				delete this.get_dom_children.options.args_map;
			}
			if(this.has.destroy) {
				this.has.destroy(true);
				delete this.has.options.context;
				delete this.has.options.args_map;
			}
		};

		proto._getter = function () {
			return this;
		};
		proto._get_dom_obj_and_src = function () {
			var dom_attachment = this.get_attachment_instance("dom"),
				show = this.has("show") ? this.prop_val("show") : true,
				dom_obj, robj;
			if(show) {
				if (dom_attachment) {
					dom_obj = dom_attachment.get_dom_obj();
					if (dom_obj) {
						return [dom_obj, dom_attachment];
					}
				} else {
					var paper_attachment = this.get_attachment_instance("paper");
					if(paper_attachment) {
						dom_obj = paper_attachment.get_dom_obj();

						if(dom_obj) {
							return [dom_obj, paper_attachment];
						}
					} else {
						var raphael_attachment = this.get_attachment_instance("shape");
						if(raphael_attachment) {
							robj = raphael_attachment.get_robj();
							if(robj) {
								return [robj[0], raphael_attachment];
							}
						} else {
							var group_attachment_instance = this.get_attachment_instance("group");
							if(group_attachment_instance) {
								var robjs_and_srcs = _.compact(_.map(group_attachment_instance.get_children(), function(raphael_attachment) {
										var robj = raphael_attachment.get_robj();
										if(robj) {
											return [robj[0], raphael_attachment];
										} else {
											return false;
										}
									})),
									rv = [
										_.pluck(robjs_and_srcs, 0),
										_.pluck(robjs_and_srcs, 1)
									];
								return rv;
							}
						}
					}
				}
			}
			return false;
		};

		proto.get_dom_obj = function() {
			var info = this.get_dom_obj_and_src();
			return info[0];
		};

		proto._get_dom_children = function() {
			var srcs = [],
				children = [];
			if (this.is_template()) {
				var instances = this.instances();
				var cs_and_dom_objs = _.chain(instances)
										.map(function(instance) {
											return instance.get_dom_obj_and_src();
										})
										.compact()
										.value();

				var dom_objs = _.pluck(cs_and_dom_objs, 0);
				var obj_srcs = _.pluck(cs_and_dom_objs, 1);
				return {srcs: obj_srcs, children: dom_objs};
			} else {
				var dom_obj_and_src = this.get_dom_obj_and_src();
				if (dom_obj_and_src) {
					return {srcs: [dom_obj_and_src[1]], children: [dom_obj_and_src[0]]};
				}
			}
			return false;
		};

		proto.pause  = function(recursive) {
			My.superclass.pause.apply(this, arguments);
			
			if(recursive) {
			}
		};
		proto.resume = function(recursive) {
			My.superclass.resume.apply(this, arguments);
			
			if(recursive) {
			}
		};
	}(ist.ContextualDict));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.ContextualCell = function (options) {
		ist.ContextualCell.superclass.constructor.apply(this, arguments);
		this._errors = new cjs.Constraint([]);

		var constraint = false,
			pointer = this.get_pointer(),
			is_inherited = this.is_inherited();
		this.value_constraint = cjs(function() {
			if(constraint && constraint.destroy) {
				constraint.destroy(true);
			}
			constraint = this.object.constraint_in_context(pointer, is_inherited);
			return constraint;
		}, {
			context: this,
		});
		var old_destroy = this.value_constraint.destroy;
		this.value_constraint.destroy = function() {
			if(constraint && constraint.destroy) {
				constraint.destroy(true);
				constraint = false;
			}
			old_destroy.apply(this, arguments);
		};

		this._type = "cell";
	};

	(function (My) {
		_.proto_extend(My, ist.ContextualObject);
		var proto = My.prototype;
		proto.initialize = function(options) {
			if(this.constructor === My) { this.flag_as_initialized();  }
			My.superclass.initialize.apply(this, arguments);
			if(this.constructor === My) { this.shout_initialization();  }
		};
		proto.destroy = function (avoid_begin_destroy) {
			if(this.constructor === My && !avoid_begin_destroy) { this.begin_destroy(true); }

			this.value_constraint.destroy(true);
			delete this.value_constraint;
			My.superclass.destroy.apply(this, arguments);
		};
		proto._getter = function (node, is_preemptive) {
			var value;
			if(ist.__debug && !is_preemptive) {
				value = cjs.get(this.value_constraint.get());
			} else {
				try {
					value = cjs.get(this.value_constraint.get());
				} catch (e) {
					if(ist.__log_errors) {
						console.error(e);
					}
				}
			}
			return value;
		};
		proto.get_str = function () {
			var cell = this.get_object();
			return cell.get_str();
		};
		proto.get_syntax_errors = function() {
			var cell = this.get_object();
			return cell.get_syntax_errors();
		};
	}(ist.ContextualCell));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,RedMap */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.ContextualStatefulObj = function (options) {
		this.statecharts_per_proto = new RedMap({
			hash: "hash"
		});
		ist.ContextualStatefulObj.superclass.constructor.apply(this, arguments);
		this._type = "stateful";
	};

	(function (My) {
		_.proto_extend(My, ist.ContextualDict);
		var proto = My.prototype;

		proto.initialize = function() {
			if(this.constructor === My) { this.flag_as_initialized(); }
			My.superclass.initialize.apply(this, arguments);
			this._live_statechart_child_updater = cjs.liven(function() {
				this.update_statecharts();
			}, {
				context: this,
				priority: 1,
				pause_while_running: true
			});
			if(this.constructor === My) { this.shout_initialization(); }
		};

		proto.get_own_statechart = function () {
			return this.get_statechart_for_proto(this.get_object());
		};

		proto.get_statechart_for_proto = function (proto) {
			cjs.wait();
			var must_initialize = false;
			var sc = this.statecharts_per_proto.get_or_put(proto, function () {
				var super_sc = proto.get_own_statechart();
				var shadow_sc = super_sc.create_shadow({
					context: this.get_pointer(),
					running: true,
					basis: super_sc,
					concurrent: super_sc.is_concurrent(),
					set_basis_as_root: true
				}, true);
				must_initialize = super_sc;
				return shadow_sc;
			}, this);
			if(must_initialize) {
				var super_sc = must_initialize;
				sc.initialize();
			}
			cjs.signal();
			return sc;
		};

		proto.update_statecharts = function() {
			var valid_statecharts = this.get_valid_statecharts(),
				current_statecharts = this.statecharts_per_proto.values(),
				to_destroy = {};

			this.statecharts_per_proto.forEach(function(sc, proto_obj) {
				to_destroy[sc.id()] = {key: proto_obj, sc: sc};
			});
			_.each(valid_statecharts, function(sc) {
				to_destroy[sc.id()] = false;
			});

			var to_destroy_arr = _.compact(_.values(to_destroy));
			_.each(to_destroy_arr, function(info) {
				var sc = info.sc,
					key = info.key;
				this.statecharts_per_proto.remove(key);
				sc.destroy(true);
			}, this);
		};

		proto.get_valid_statecharts = function() {
			return this.get_statecharts();
		};

		proto.get_statecharts = function () {
			if(this.is_template()) {
				return [];
			}

			var contextual_protos = this.get_all_protos();
			var proto_statecharts = _	.chain(contextual_protos)
										.map(function (x) {
											if (x instanceof ist.ContextualStatefulObj) {
												return this.get_statechart_for_proto(x.get_object());
											} else {
												return false;
											}
										}, this)
										.compact()
										.value();

			return ([this.get_own_statechart()]).concat(proto_statecharts);
		};

		proto.reset = function () {
			var statecharts = this.get_statecharts();
			_.each(statecharts, function(statechart) {
				statechart.reset();
			}, this);
		};

		proto.begin_destroy = function() {
			if(this._live_statechart_child_updater) {
				this._live_statechart_child_updater.destroy(true);
				delete this._live_statechart_child_updater;
			}

			this.statecharts_per_proto.forEach(function(statechart) {
				statechart.destroy(true);
			});

			this.statecharts_per_proto.destroy(true);
			delete this.statecharts_per_proto;

			My.superclass.begin_destroy.apply(this, arguments);
		};

		proto.destroy = function (avoid_begin_destroy) {
			cjs.wait();
			if(this.constructor === My && !avoid_begin_destroy) { this.begin_destroy(true); }

			My.superclass.destroy.apply(this, arguments);
			cjs.signal();
		};

		proto.pause  = function(recursive) {
			My.superclass.pause.apply(this, arguments);

			var statecharts = this.get_statecharts();
			_.each(statecharts, function(statechart) {
				statechart.pause();
			});
		};
		proto.resume = function(recursive) {
			My.superclass.resume.apply(this, arguments);

			var statecharts = this.get_statecharts();
			_.each(statecharts, function(statechart) {
				statechart.resume();
			});
		};
	}(ist.ContextualStatefulObj));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var NO_VAL = {};

	ist.ContextualStatefulProp = function (options) {
		this.transition_times_run = {};
		this._last_value = NO_VAL;

		this.$active_value = new cjs.Constraint(this.active_value_getter, { context: this });

		this._has_runtime_errors = false;
		this.$runtime_errors = new cjs.Constraint([]);

		ist.ContextualStatefulProp.superclass.constructor.apply(this, arguments);
		this._type = "stateful_prop";
	};

	(function (My) {
		_.proto_extend(My, ist.ContextualObject);
		var proto = My.prototype;

		proto.initialize = function() {
			if(this.constructor === My) { this.flag_as_initialized(); }
			My.superclass.initialize.apply(this, arguments);
			var active_value_info = this.active_value();
			this.$value.onChange(this.$value.get, this.$value);
			// If we went back to set my value to the start transition's value,
			// then invalidate the active value so that it gets recomputed before
			// any transitions run
			if(active_value_info.is_fallback) {
				this.$active_value.invalidate();
			}
			if(this.constructor === My) { this.shout_initialization(); }
		};

		proto.get_parent = function () {
			var context = this.get_pointer(),
				contextual_object,
				popped_item, last;
				
			while (!context.is_empty()) {
				last = context.points_at();
				if (last instanceof ist.StatefulObj) {
					contextual_object = ist.find_or_put_contextual_obj(last, context);
					return contextual_object;
				}
				popped_item = last;
				context = context.pop();
			}
			return undefined;
		};

		proto.get_states = function () {
			var parent = this.get_parent();
			var stateful_prop = this.get_object();
			var statecharts;
			if (stateful_prop.get_can_inherit()) {
				statecharts = parent.get_statecharts();
			} else {
				var sc_parent = stateful_prop.get_statechart_parent();
				if (sc_parent === "parent") {
					sc_parent = parent.get_object();
				}
				statecharts = [parent.get_statechart_for_proto(sc_parent)];
			}
			var substates = _.chain(statecharts)
				.map(function (sc) {
					var flat_substates = sc.flatten_substates(true);
					var substates = flat_substates.splice(0, flat_substates.length-1);
					return substates;
				})
				.flatten(true)
				.map(function (state) {
					var incoming_transitions = state.get_incoming_transitions();
					incoming_transitions = _.filter(incoming_transitions, function(trans) {
						return trans.from() instanceof ist.Statechart;
					});
					return ([state]).concat(incoming_transitions);
				})
				.flatten(true)
				.value();

			return substates; // includes transitions
		};

		proto.get_raw_values = function (avoid_inherited) {
			var parent = this.get_parent();
			var stateful_prop = this.get_object();
			var statecharts, entries, name, i, values;

			if (stateful_prop.get_can_inherit() && avoid_inherited !== true) {
				var pointer = this.get_pointer();


				var my_names = [];
				i = pointer.lastIndexOf(parent.get_object());
				var len = pointer.length();
				var item_im1 = pointer.points_at(i),
					item_i;

				i += 1;
				while (i < len) {
					item_i = pointer.points_at(i);
					name = ist.Dict.get_prop_name(item_im1, item_i, pointer.slice(0, i));
					my_names.push(name);
					item_im1 = item_i;
					i += 1;
				}

				var my_names_len = my_names.length;
				//var protos_and_me = ([parent]).concat(parent.get_all_protos(true));
				var protos_and_me = parent.get_all_protos(true);

				var inherits_from = _	.chain(protos_and_me)
										.map(function (cdict, proto_num) {
											var i;
											for (i = 0; i < my_names_len; i += 1) {
												name = my_names[i];

												if (cdict instanceof ist.ContextualDict && cdict.has(name)) { // ignore inherited
													cdict = cdict.prop(name);
												} else {
													return false;
												}
											}
											return cdict;
										}, this)
										.compact()
										.value();

				inherits_from = _.uniq([this].concat(inherits_from)); // when setting an already-set property, odd situations can come up
												// where 'this' wasn't included


				entries = [];
				var cifrom, ifrom;
				var inherits_from_len = inherits_from.length;
				var dv_entries_map_fn = function (x) {
						return {
							key: x.key,
							value: x.value
						};
					},
					set_inherited_from_to_cifrom = function(entry) {
						entry.inherited_from = cifrom;
					};
				for (i = 0; i < inherits_from_len; i += 1) {
					cifrom = inherits_from[i];
					if(cifrom instanceof ist.ContextualObject) {
						//if(cifrom.is_destroyed()) { continue; } // TODO: fix this

						ifrom = cifrom.get_object();
						if (cifrom instanceof ist.ContextualStatefulProp) {
							values = cifrom.get_raw_values(cifrom === this ? true : false);
							//var values = cifrom.get_raw_values(true);

							_.each(values, set_inherited_from_to_cifrom);

							entries.push.apply(entries, values);
						} else if (cifrom instanceof ist.ContextualCell) {
							entries.push({
								key: undefined,
								value: ifrom,
								inherited_from: cifrom
							});
						}
					}
				}
			} else if(this.is_inherited()) {
				return [];
			} else {
				values = stateful_prop.get_direct_values();
				entries = values.entries();

				_.each(entries, function(entry) {
					entry.inherited_from = cifrom;
				});

				var sc_parent = stateful_prop.get_statechart_parent();
				if (sc_parent === "parent") {
					sc_parent = parent;
				}
			}
			return entries;
		};

		proto.get_values = function() {
			var raw_values = this.get_raw_values(),
				parent = this.get_parent(),
				stateful_prop = this.get_object(),
				statecharts = stateful_prop.get_can_inherit() ? parent.get_statecharts() : [parent.get_statechart_for_proto(parent.get_object())],
				statecharts_len = statecharts.length;

			var rv = _.map(raw_values, function (entry) {
				var key = entry.key;
				var state, i;
				if (key) {
					for (i = 0; i < statecharts_len; i += 1) {
						var statechart = statecharts[i];
						if (key.root() === statechart.basis()) {
							if (key instanceof ist.State) {
								try {
									state = ist.find_equivalent_state(key, statechart);
								} catch(e) {
									continue;
								}
							} else if (key instanceof ist.StatechartTransition) {
								try {
									state = ist.find_equivalent_transition(key, statechart);
								} catch(e) {
									continue;
								}
							}
							break;
						}
					}
				} else {
					state = undefined;
				}
				return {
					state: state,
					value: entry.value,
					inherited_from: entry.inherited_from,
					root_sv_index: i
				};
			}, this);
			rv = _.compact(rv);

			var root_indicies = {};

			rv = rv.sort(function(a, b) {
				return a.root_sv_index - b.root_sv_index;
			});

			return rv;
		};

		proto.get_transition_times_run = function (transition) {
			var transition_id = transition.id();
			return this.transition_times_run[transition_id] || 0;
		};
		proto.set_transition_times_run = function (transition, tr) {
			var transition_id = transition.id();
			this.transition_times_run[transition_id] = tr;
		};
		var USING_AS_TRANSITION = 'transition';//{};
		var USING_AS_STATE = 'state';// {};

		
		proto.active_value_getter = function () {
			var stateful_prop = this.get_object(),
				values = this.get_values(),
				len = values.length,
				is_fallback = false,
				using_val = NO_VAL,
				fallback_value = NO_VAL,
				using_state, using_info, fallback_state,
				info, i, tr, state, val, is_start_state, using_as;

			for (i = 0; i < len; i += 1) {
				info = values[i];
				state = info.state;
				val = info.value;

				if(state instanceof ist.StartState) { // Should actually use the transition and not the state
					if (state.is_active() && (using_val === NO_VAL || using_state.order(state) < 0)) {
						using_info = info;
						using_val = val;
						using_state = state;
						using_as = USING_AS_STATE;
					} else {
						var ot = state.get_outgoing_transition();
						if(ot) { // sometimes called before initialization
							tr = ot.get_times_run();

							if (tr > this.get_transition_times_run(ot)) {
								this.set_transition_times_run(ot, tr);

								using_info = info;
								using_val = val;
								using_state = state;
								using_as = USING_AS_TRANSITION;
							}
						}
					}
				} else if (state instanceof ist.State) {
					if (state.is_active() && (using_val === NO_VAL || using_state.order(state) < 0)) {
						using_info = info;
						using_val = val;
						using_state = state;
						using_as = USING_AS_STATE;
					}
				} else if (state instanceof ist.StatechartTransition) {
					tr = state.get_times_run();

					if (tr > this.get_transition_times_run(state)) {
						this.set_transition_times_run(state, tr);

						if (!(using_state instanceof ist.StatechartTransition)) {
							using_info = info;
							using_val = val;
							using_state = state;
							using_as = USING_AS_TRANSITION;
						}
					}
				}
			}
			if (using_val === NO_VAL) {
				if (this._last_value === NO_VAL) {
					using_info = using_val = using_state = using_as = undefined;
				} else {
					is_fallback = true;
					using_state = this._from_state;
					using_val = undefined;
					using_info = undefined;
					for(i = 0; i<len; i++) {
						info = values[i];
						state = info.state;
						val = info.value;
						if(state === using_state) {
							using_val = val;
							using_info = info;
							break;
						}
					}
					if(using_state instanceof ist.State) {
						using_as = USING_AS_STATE;
					} else if(using_state instanceof ist.StatechartTransition) {
						using_as = USING_AS_TRANSITION;
					}
				}
			} else {
				this._last_info = using_info;
				this._last_value = using_val;
				this._from_state = using_state;
				this._using_as = using_as;
			}

			return {
				value: using_val,
				state: using_state,
				info: using_info,
				using_as: using_as,
				is_fallback: is_fallback
			};
		};

		proto.active_value = function() {
			return this.$active_value.get();
		};


		proto._getter = function (node, is_preemptive) {
			var last_last_value = this._last_value,
				active_value_info = this.active_value();

			if(!active_value_info) { return; }

			var	using_info = active_value_info.info,
				using_val = active_value_info.value,
				using_state = active_value_info.state,
				using_as = active_value_info.using_as,
				using_inherited_from = active_value_info.inherited_from,
				is_fallback = active_value_info.is_fallback;
			var rv;

			if(using_as === USING_AS_TRANSITION) {
				if(is_fallback) {
					return this._last_rv;
				} else {
					active_value_info.is_fallback = true; // If the value isn't nullified, we just return the same object so mark it as being a fallback
					var invalidate_value = _.bind(function () {
						if(this.$value) {
							this.$value.invalidate();
						}
					}, this);
					var invalidate_active_value = _.bind(function () {
						if(this.$active_value) {
							this.$active_value.invalidate();
						}
					}, this);
					if(ist.event_queue.end_queue_round === 2) {
						ist.event_queue.once("end_event_queue_round_3", invalidate_value);
					} else if(ist.event_queue.end_queue_round === 6) {
						ist.event_queue.once("end_event_queue_round_7", invalidate_value);
					} else {
						invalidate_active_value();
					}
					//invalidate_value = invalidate_active_value = null;
				}
			}

			var stateful_prop = this.get_object();

			if(using_val) {
				var pointer = this.get_pointer(),
					eventized_pointer;
				if(using_state instanceof ist.StartState) {
					eventized_pointer = pointer.push(using_val);
				} else {
					eventized_pointer = pointer.push(using_val, new ist.StateContext(using_state));
				}

				
				var cobj = ist.find_or_put_contextual_obj(using_val, eventized_pointer, {
					inherited_from: using_info.inherited_from
				});
				
		
				if(!is_preemptive && ist.__debug) {
					rv = cobj.val();
				} else {
					try {
						rv = cobj.val();
						if(rv instanceof ist.Error) {
							rv = undefined;
						}
						if(this._has_runtime_errors) {
							this._has_runtime_errors = false;
							this.$runtime_errors.set([]);
						}
					} catch (e1) {
						rv = undefined;
						this.$runtime_errors.set([e1.message]);
						this._has_runtime_errors = true;
					}
				}

				this._last_rv = rv;

				return rv;
			} else {
				return undefined;
			}
		};

		proto.begin_destroy = function() {
			this.$value.offChange(this.$value.get, this.$value);

			My.superclass.begin_destroy.apply(this, arguments);
		};

		proto.destroy = function (avoid_begin_destroy) {
			if(this.constructor === My && !avoid_begin_destroy) { this.begin_destroy(true); }

			this.$active_value.destroy(true);
			delete this.$active_value;
			My.superclass.destroy.apply(this, arguments);
		};
		proto.get_runtime_errors = function () {
			return this.$runtime_errors.get();
		};
		proto.pause  = function(recursive) {
			My.superclass.pause.apply(this, arguments);
			
			if(recursive) {
			}
		};
		proto.resume = function(recursive) {
			My.superclass.resume.apply(this, arguments);

			if(recursive) {
			}
		};
	}(ist.ContextualStatefulProp));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.find_equivalent_state = function (to_state, in_tree) {
		var in_tree_basis = in_tree.basis();
		var in_tree_basis_lineage = in_tree_basis.get_lineage();
		var to_state_lineage = to_state.get_lineage();

		var in_tree_basis_lineage_len = in_tree_basis_lineage.length;
		var to_state_lineage_len = to_state_lineage.length;
		
		var in_tree_basis_index = in_tree_basis_lineage_len - 1;
		var to_state_index;
		var i;

		outer_loop:
		while (in_tree_basis_index >= 0) {
			for (i = to_state_lineage_len - 1; i >= 0; i -= 1) {
				if (to_state_lineage[i] === in_tree_basis_lineage[in_tree_basis_index]) {
					to_state_index = i;
					break outer_loop;
				}
			}
			in_tree_basis_index -= 1;
		}
		var search_item = in_tree;
		var parentage_level = in_tree_basis_lineage_len - 1 - in_tree_basis_index;
		_.times(parentage_level, function () {
			search_item = search_item.parent();
		});

		for (i = to_state_index + 1; i < to_state_lineage_len; i += 1) {
			var name = to_state_lineage[i - 1].get_name_for_substate(to_state_lineage[i]);
			search_item = search_item.get_substate_with_name(name);
		}

		if (search_item.basis() !== to_state) { throw new Error("Could not find correct equivalent item"); }

		return search_item;
	};

	ist.State = function (options) {
		this._constructed = false;
		options = options || {};


		if(!this._started_construction) {
			this._started_construction = true;

			able.make_this_listenable(this);

			this._initialized = false;
			this.$initialized = cjs(false);

			this._id = options.id || uid();
			this._hash = uid.strip_prefix(this._id);

			this._running = options.running === true;
			this.$running = cjs(this._running);

			ist.register_uid(this._id, this);
		}

		//if(this.sid() === 907) debugger;
		if(options.avoid_constructor) { return; }

		this._last_run_event = cjs(false);

		this._puppet = options.puppet === true;
		this._parent = options.parent;
		this._context = options.context;

		this.$active = cjs(options.active === true || (!this._parent && !this._puppet));

		//this.set_basis(options.basis, options.set_basis_as_root);
		//if (this._basis) {
			//this.remove_basis_listeners();
		//}
		this._basis = options.basis;
		if (this._basis) {
			this.add_basis_listeners();
		}

		//if(this.sid() === 2141) debugger;
	};

	(function (my) {
		var proto = my.prototype;
		able.make_proto_listenable(proto);

		if(ist.__debug_statecharts) {
			proto.get_$running = function() {
				return this.$running.get();
			};
		}

		proto.is_constructed = function () {
			return this._constructed;
		};

		proto.initialize = function () {
			if (this._basis) { // shadow
				_.each(this.get_outgoing_transitions(), function(transition) {
					transition.initialize();
				});
			}
			this._initialized = true;
			this.$initialized.set(true);
			this._emit("initialized");
		};

		proto.is_initialized = function () {
			return this.$initialized.get();
		};

		proto.is_puppet = function () {
			return this._puppet;
		};

		proto.is_running = function () { return this._running; };

		proto.run = function () {
			if(this.is_puppet()) {
				this._running = true;
				this._emit("run", {
					target: this,
					type: "run"
				});
				//if(ist.__debug_statecharts) {
					this.$running.set(true);
				//}
			} else if (!this.is_running()) {
				ist.event_queue.wait();
				this.enable_outgoing_transitions();

				this._running = true;
				this._emit("run", {
					target: this,
					type: "run"
				});
				//if(ist.__debug_statecharts) {
					this.$running.set(true);
				//}
				ist.event_queue.signal();
			}
		};
		proto.stop = function () {
			if(this.is_puppet()) {
				this._running = false;
				this._emit("stop", {
					type: "stop",
					target: this
				});
				//if(ist.__debug_statecharts) {
					this.$running.set(false);
				//}
			} else {
				ist.event_queue.wait();
				this._running = false;
				this.disable_outgoing_transitions();
				this._emit("stop", {
					type: "stop",
					target: this
				});
				//if(ist.__debug_statecharts) {
					this.$running.set(false);
				//}
				ist.event_queue.signal();
			}
		};
		proto.reset = function () {
			if (this.is_running()) {
				ist.event_queue.wait();
				this.stop();
				this.run();
				ist.event_queue.signal();
			}
			return this;
		};

/*
		proto.set_basis = function (basis, as_root) {
			if (this._basis) {
				this.remove_basis_listeners();
			}
			this._basis = basis;
			if (this._basis) {
				if (this._basis instanceof ist.Statechart) {
					var basis_start_state = this._basis.get_start_state();
					var basis_start_state_to = basis_start_state.getTo();
					var is_running = this.is_running();
					var my_context = this.context();
					var is_concurrent = this.is_concurrent();

					_.each(basis.get_substates(true), function (substate, name) {
						var shadow = substate.create_shadow({
							context: my_context,
							parent: this,
							running: is_running && (basis_start_state_to === substate || is_concurrent),
							active: is_running && (basis_start_state_to === substate || is_concurrent),
							set_basis_as_root: false
						});
						if (shadow instanceof ist.StartState) {
							this.set_start_state(shadow);
						} else {
							this.add_substate(name, shadow);
						}
					}, this);
					_.each(this._basis._transition_listeners, function (listeners, name) {
						_.each(listeners, function (info) {
							this.on_transition(info.str, info.activation_listener, info.deactivation_listener, info.context);
						}, this);
					}, this);
				}
				if (as_root === true) { // When all of the substates have been copied
					var parent_statechart = this,
						context = this.context();

					var create_transition_shadow = _.memoize(function (transition) {
						var from = ist.find_equivalent_state(transition.from(), parent_statechart);
						var to = ist.find_equivalent_state(transition.to(), parent_statechart);
						return transition.create_shadow(from, to, parent_statechart, context);
					}, function (transition, from) {
						return transition.id();
					});

					this.do_shadow_transitions(create_transition_shadow);
				}

				this.add_basis_listeners();
			}
			return this;
		};
		*/

		proto.do_shadow_transitions = function(create_transition_shadow) {
			var basis = this.basis();
			var outgoing_transitions = basis.get_outgoing_transitions();
			var shadow_outgoing = _.map(outgoing_transitions, create_transition_shadow);

			_.each(shadow_outgoing, function (transition) {
				var from = transition.from();
				var to = transition.to();
				from._add_direct_outgoing_transition(transition);
				to._add_direct_incoming_transition(transition);
			}, this);

			var substates = this.get_substates(true);
			_.each(substates, function(substate) {
				substate.do_shadow_transitions(create_transition_shadow);
			}, this);
		};

		proto.set_active = function (to_active) {
			if(this.$active) {
				this.$active.set(to_active === true);
				if(!to_active) {
					_.each(this.get_substates(true), function(substate) {
						substate.set_active(false);
						substate.disable_outgoing_transitions();
						substate.stop();
					}, this);
				}
				var event_type = to_active ? "active" : "inactive";
				this._emit(event_type, {
					type: event_type,
					target: this
				});
			}
		};
		proto.flatten_substates = function (include_start) {
			return _.flatten(_.map(this.get_substates(include_start), function (substate) {
				return substate.flatten_substates(include_start);
			})).concat([this]);
		};
		proto.is_active = function (to_active) { return this.$active && this.$active.get(); };
		proto.get_name = function (relative_to) {
			var parent = this.parent();
			if (!relative_to) {
				relative_to = this.root();
			} else if (relative_to === 'parent') {
				relative_to = parent;
			}

			var my_name = parent ? parent.get_name_for_substate(this) : "";
			if (parent === relative_to) {
				return my_name;
			} else {
				var parent_name = parent ? parent.get_name(relative_to) : "";
				if (parent_name === "") {
					return my_name;
				} else {
					return parent_name + "." + my_name;
				}
			}
		};
		proto.id = function () { return this._id; };
		proto.hash = function () { return this._hash; };
		proto.sid = function() { return parseInt(uid.strip_prefix(this.id()), 10); };
		proto.basis = function () { return this._basis; };
		proto.parent = function () { return this._parent; };
		proto.context = function () { return this._context; };
		proto.set_parent = function (parent) { this._parent = parent; return this; };
		proto.set_context = function (context) { this._context = context; return this; };

		proto.is_based_on = function (state) {
			return this.basis() === state;
		};

		proto.is_child_of = function (node) {
			var curr_parent = this.parent();
			while (curr_parent) {
				if (curr_parent === node) {
					return true;
				}
				curr_parent = curr_parent.parent();
			}
			return false;
		};

		proto.get_lineage = function (until_state) {
			var curr_node = this;
			var parentage = [];
			var i = 0;
			do {
				parentage[i] = curr_node;
				i += 1;
				if (curr_node === until_state) { break; }
				curr_node = curr_node.parent();
			} while (curr_node);
			return parentage.reverse();
		};

		proto.root = function () {
			var parent = this.parent();
			if (parent) {
				return parent.root();
			} else {
				return this;
			}
		};

		proto.on_outgoing_transition_fire = function (transition, event) {
			var i;

			if (this.is_running() && _.indexOf(this.get_outgoing_transitions(), transition) >= 0) {
				transition._last_run_event.set(event);
				
				var my_lineage = this.get_lineage();
				/*
				for (i = 0; i < my_lineage.length - 1; i += 1) {
					if (!my_lineage[i].is(my_lineage[i + 1])) {
						return false;
					}
				}
				*/

				var to = transition.to();
				var to_lineage = to.get_lineage();
				var to_len = to_lineage.length;

				var min_len = Math.min(to_len, my_lineage.length);

				//console.log("from ", _.map(my_lineage, function(x) { return x.get_name(); }));
				//console.log("to   ", _.map(to_lineage, function(x) { return x.get_name(); }));

				for (i = 0; i < min_len; i += 1) {
					if (to_lineage[i] !== my_lineage[i]) {
						i--; //back up...
						break;
					}
				}
				if (i === to_len) { //if it is a self-transition. Just handle it on the lowest level possible
					i -= 2;
				}

				//cjs.wait();
				var active_substate, parent, min_common_i = i;
				while (i < to_len - 1) {
					parent = to_lineage[i];
					active_substate = to_lineage[i + 1];
					parent.set_active_substate(active_substate, transition, event);
					i++;
				}

				if(active_substate instanceof ist.Statechart) {
					var start_state = active_substate.get_start_state();
					active_substate.set_active_substate(start_state, transition, event);
				}


				ist.event_queue.once("end_event_queue_round_0", function () {
					this._emit("pre_transition_fire", {
						type: "pre_transition_fire",
						transition: transition,
						//target: this,
						event: event,
						state: to
					});
					transition.set_active(true);
				}, this);

				ist.event_queue.once("end_event_queue_round_2", function () {
					transition.increment_times_run();
				}, this);

				ist.event_queue.once("end_event_queue_round_4", function () {
					transition.set_active(false);
					this._emit("post_transition_fire", {
						type: "post_transition_fire",
						transition: transition,
						//target: this,
						event: event,
						state: to
					});
				}, this);

				//cjs.signal();
				return true;
			}
			return false;
		};

		proto.order = function (other_state) {
			var i;
			// return 1 if other_state is ">" me (as in should be further right)
			// return -1 if other_state is "<" me (as in should be further left)
			// return 0 if other_state is "==" me (same thing)

			var my_lineage = this.get_lineage(),
				other_lineage = other_state.get_lineage(),
				mli = my_lineage[0],
				oli = other_lineage[0];

			if(mli !== oli) { // different root
				return 0;
			}

			var len = Math.min(my_lineage.length, other_lineage.length),
				index_me, index_o;

			for (i = 1; i < len; i += 1) {
				index_me = mli.get_substate_index(my_lineage[i]);
				index_o = oli.get_substate_index(other_lineage[i]);
				if (index_me < index_o) {
					return 1;
				} else if (index_me > index_o) {
					return -1;
				}
				mli = my_lineage[i];
				oli = other_lineage[i];
			}

			if (other_lineage.length > my_lineage.length) { // It is more specific
				return -1;
			} else if (other_lineage.length < my_lineage.length) {
				return 1;
			} else { // We are exactly the same
				return 0;
			}
		};
		proto.enable_outgoing_transitions = function () {
			var outgoing_transitions = this.get_outgoing_transitions();
			_.each(outgoing_transitions, function (x) { x.enable(); });
		};
		proto.disable_outgoing_transitions = function () {
			this.disable_immediate_outgoing_transitions();
			var substates = this.get_substates();
			_.each(substates, function (x) { x.disable_outgoing_transitions(); });
		};
		proto.disable_immediate_outgoing_transitions = function() {
			var transitions = this.get_outgoing_transitions();
			_.each(transitions, function (x) { x.disable(); });
		};
		proto.disable_immediate_incoming_transitions = function() {
			var transitions = this.get_incoming_transitions();
			_.each(transitions, function (x) { x.disable(); });
		};
		proto.parent_is_concurrent = function() {
			var parent = this.parent();
			if(parent) {
				return parent.is_concurrent();
			} else {
				return false;
			}
		};

		proto.summarize = function () {
			var context = this.context();
			var summarized_context;
			if (context) {
				summarized_context = context.summarize();
			}
			var my_basis = this.basis() || this;
			return {
				basis_id: my_basis.id(),
				context: summarized_context
			};
		};
		my.desummarize = function (obj) {
			if (obj.context) {
				var state_basis = ist.find_uid(obj.basis_id);
				var context = ist.Pointer.desummarize(obj.context);
				var dict = context.points_at();
				var contextual_statechart = dict.get_statechart_for_context(context);

				var state = ist.find_equivalent_state(state_basis, contextual_statechart);
				return state;
			} else {
				return ist.find_uid(obj.basis_id);
			}
		};
		proto.add_basis_listeners = function() {
			this._basis.on("add_transition", this.onBasisAddTransition, this);
			this._basis.on("add_substate", this.onBasisAddSubstate, this);
			this._basis.on("remove_substate", this.onBasisRemoveSubstate, this);
			this._basis.on("rename_substate", this.onBasisRenameSubstate, this);
			this._basis.on("move_substate", this.onBasisMoveSubstate, this);
			this._basis.on("make_concurrent", this.onBasisMakeConcurrent, this);
			this._basis.on("on_transition", this.onBasisOnTransition, this);
			this._basis.on("off_transition", this.onBasisOffTransition, this);
			this._basis.on("destroy", this.onBasisDestroy, this);
		};
		proto.remove_basis_listeners = function() {
			this._basis.off("add_transition", this.onBasisAddTransition, this);
			this._basis.off("add_substate", this.onBasisAddSubstate, this);
			this._basis.off("remove_substate", this.onBasisRemoveSubstate, this);
			this._basis.off("rename_substate", this.onBasisRenameSubstate, this);
			this._basis.off("move_substate", this.onBasisMoveSubstate, this);
			this._basis.off("make_concurrent", this.onBasisMakeConcurrent, this);
			this._basis.off("on_transition", this.onBasisOnTransition, this);
			this._basis.off("off_transition", this.onBasisOffTransition, this);
			this._basis.off("destroy", this.onBasisDestroy, this);
		};
		proto.onBasisAddTransition = function (event) {
			var transition = event.transition;
			var new_from = ist.find_equivalent_state(event.from_state, this);
			var new_to = ist.find_equivalent_state(event.to_state, this);
			var transition_shadow = transition.create_shadow(new_from, new_to, this, this.context());
			new_from._add_direct_outgoing_transition(transition_shadow);
			new_to._add_direct_incoming_transition(transition_shadow);
			this.add_transition(transition_shadow);
		};
		proto.onBasisAddSubstate = function (event) {
			var state_name = event.state_name,
				state = event.state,
				index = event.index;
			this.add_substate(state_name, state.create_shadow({parent: this, context: this.context()}), index);
		};
		proto.onBasisRemoveSubstate = function (event) {
			this.remove_substate(event.name, undefined, false);
		};
		proto.onBasisRenameSubstate = function (event) {
			var from_name = event.from,
				to_name = event.to;
			this.rename_substate(from_name, to_name);
		};
		proto.onBasisMoveSubstate = function (event) {
			var state_name = event.state_name,
				index = event.index;
			this.move_state(state_name, index);
		};
		proto.onBasisMakeConcurrent = function (event) {
			this.make_concurrent(event.concurrent);
		};
		proto.onBasisOnTransition = function (event) {
			this.on_transition(event.str, event.activation_listener, event.deactivation_listener, event.context);
		};
		proto.onBasisOffTransition = function (event) {
			this.off_transition(event.str, event.activation_listener, event.deactivation_listener, event.context);
		};
		proto.onBasisDestroy = function (event) {
			this.destroy(true);
		};

		proto.destroy = function (silent) {
			this.destroyed = true;
			if(this.$active) {
				this.$active.destroy(silent);
				delete this.$active;
			}
			if(this.$running) {
				this.$running.destroy(silent);
				delete this.$running;
			}
			this.$initialized.destroy(silent);
			this._last_run_event.destroy(silent);
			delete this._last_run_event;
			if (this._basis) {
				this.remove_basis_listeners();
				delete this._basis;
			}
			delete this._parent;
			delete this._context;
			able.destroy_this_listenable(this);
			ist.unregister_uid(this.id());
		};

		proto.pause = function() {
			if(this.is_active()) {
				this.disable_immediate_outgoing_transitions();

				_.each(this.get_substates(true), function(substate) {
					substate.pause();
				});
			}
		};
		proto.resume = function() {
			if(this.is_active()) {
				this.enable_outgoing_transitions();

				_.each(this.get_substates(true), function(substate) {
					substate.resume();
				});
			}
		};
	}(ist.State));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.StartState = function (options) {
		options = options || {};

		ist.StartState.superclass.constructor.apply(this, arguments);

		if(options.avoid_constructor) { return; }

		this.outgoingTransition = options.outgoing_transition;

		this._constructed = true;

		//this.outgoingTransition = false;
		//if(ist.__debug_statecharts) {
			//this.$running = cjs(this._running);
		//}

		//var basis = this.basis();
		//this._transition_to_self = cjs(this.outgoingTransition && (this.outgoingTransition.to() === this));

		//if(options.outgoing_transition) {
		//}
		//var to;

		//if(!basis && !this.is_puppet()) {
		/*
			// If we have a basis, then whatever function shadowed us will create our outgoing transition too
			if (options.to) {
				to = options.to;
				this._transition_to_self.set(false);
			} else {
				to = this;
				this._transition_to_self.set(true);
			}

			debugger;
			*/
			//this.outgoingTransition = options.outgoing_transition;
			/*
			|| new ist.StatechartTransition({
				from: this,
				to: to,
				event: new ist.StatechartEvent({
					target: "me",
					spec: "run"
				})
			});

			to._add_direct_incoming_transition(this.outgoingTransition);
			*/
		//} else if(this.is_puppet()) {
			//this.outgoingTransition = options.outgoing_transition;
			//this._transition_to_self.set(this.outgoingTransition.to() === this);
		//}
	};
	(function (My) {
		_.proto_extend(My, ist.State);
		var proto = My.prototype;
		proto.initialize = function () {
			if(!this.outgoingTransition) {
				this.outgoingTransition = new ist.StatechartTransition({
					from: this,
					to: this,
					event: new ist.StatechartEvent({
						target: "me",
						spec: "run"
					})
				});
				//throw new Error("Outgoing transition not set");
			}

			My.superclass.initialize.apply(this, arguments);
		};
		proto.setTo = function (toNode) {
			var transition = this.outgoingTransition;
			var parent = this.parent();
			if (toNode.is_child_of(parent)) {
				transition.setTo(toNode);
			}
		};
		proto.set_parent = function (parent) {
			//this.outgoingTransition.event().set_statecharts(parent);
			return My.superclass.set_parent.apply(this, arguments);
		};
		proto.getTo = function () {
			var transition = this.outgoingTransition;
			return transition.to();
		};
		proto.get_substates = function () { return []; };
		proto.get_active_states = function () { return []; };
		proto.get_outgoing_transitions = function () {
			if (this.outgoingTransition) {
				return [this.outgoingTransition];
			} else {
				return [];
			}
		};
		proto.get_incoming_transitions = function () {

			if(this.outgoingTransition && (this.outgoingTransition.to() === this)) {
				return [this.outgoingTransition];
			} else {
				return [];
			}
			/*
			if (this._transition_to_self.get() && this.outgoingTransition) {
				return [this.outgoingTransition];
			} else {
				return [];
			}
			*/
		};
		proto._add_direct_incoming_transition = function (transition) {
			if (transition !== this.outgoingTransition) {
				throw new Error("Should never have a transition other than outgoing transition");
			}
			//this._transition_to_self.set(true);
		};
		proto._remove_direct_incoming_transition = function (transition) {
			if (transition !== this.outgoingTransition) {
				throw new Error("Should never have a transition other than outgoing transition");
			}
			//this._transition_to_self.set(false);
		};
		proto._add_direct_outgoing_transition = function (transition) {
			if (this.outgoingTransition) { // I already have an outgoing transition
				throw new Error("Should never have a transition other than outgoing transition");
			}
			//this._transition_to_self.set(transition.to() === this);
			this.outgoingTransition = transition;
		};
		proto._remove_direct_outgoing_transition = function (transition) {
			throw new Error("Should never remove outgoing transition from start state");
		};
		proto.is_running = function () {
			return this._running;
		};
		/*
		proto.run = function () {
			if(this.is_puppet()) {
				this._running = true;
				this._emit("run", {
					target: this,
					type: "run"
				});
				if(ist.__debug_statecharts) {
					this.$running.set(true);
				}
			} else if (!this.is_running()) {
				this._running = true;
				this.enable_outgoing_transitions();
				this._emit("run", {
					target: this,
					type: "run"
				});
				if(ist.__debug_statecharts) {
					this.$running.set(true);
				}
			}
			return this;
		};
		proto.stop = function () {
			if(this.is_puppet()) {
				this._running = false;
				this._emit("stop", {
					type: "stop",
					target: this
				});
				if(ist.__debug_statecharts) {
					return this.$running.set(false);
				}
			} else if(this.is_running()) {
				this._running = false;
				this.disable_outgoing_transitions();
				this._emit("stop", {
					type: "stop",
					target: this
				});
				if(ist.__debug_statecharts) {
					return this.$running.set(false);
				}
			}
			return this;
		};
		*/
		proto.destroy = function (silent) {
			this._emit("destroy", {
				type: "destroy",
				target: this
			});

			cjs.wait();
			if(this.outgoingTransition) {
				this.outgoingTransition.destroy(silent);
				delete this.outgoingTransition;
			}
			//this._transition_to_self.destroy(silent);
			//delete this._transition_to_self;
			My.superclass.destroy.apply(this, arguments);
			cjs.signal();
		};

		proto.get_transitions_to = function (to) {
			if (this.getTo() === to) {
				return this.get_outgoing_transitions();
			} else {
				return [];
			}
		};
		proto.get_transitions_from = function (from) {
			if (from === this && this.getTo() === this) {
				return this.get_outgoing_transitions();
			} else {
				return [];
			}
		};
		proto.get_outgoing_transition = function () {
			return this.outgoingTransition;
		};
		proto.set_outgoing_transition = function (transition) {
			this.outgoingTransition = transition;
		};

		proto.create_shadow = function (options, defer_initialization) {
			var rv = new ist.StartState(_.extend({
				basis: this
			}, options), defer_initialization);

			return rv;
		};

		ist.register_serializable_type("start_state",
			function (x) {
				return x instanceof My;
			},
			function (include_id) {
				var args = _.toArray(arguments);
				var rv = {
					outgoing_transition: ist.serialize.apply(ist, ([this.get_outgoing_transition()]).concat(args)),
					parent: ist.serialize.apply(ist, ([this.parent()]).concat(args))
				};
				if (include_id) {
					rv.id = this.id();
				}
				return rv;
			},
			function (obj) {
				var rest_args = _.rest(arguments);
				var rv;
				if (obj.id) {
					rv = ist.find_uid(obj.id);
					if (rv) {
						return rv;
					}
				}
				rv = new My({
					avoid_constructor: true
				});
				rv.initialize = function () {
					delete this.initialize;
				/*
					var options = {
					};
					this.do_initialize(options);
					*/
					My.call(this, {
						id: obj.id,
						outgoing_transition: ist.deserialize.apply(ist, ([obj.outgoing_transition]).concat(rest_args)),
						parent: ist.deserialize.apply(ist, ([obj.parent]).concat(rest_args))
					});
				};

				return rv;
			});
	}(ist.StartState));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var any_state = ist.any_state = {},
		state_descriptor_regex = /\s*(([\w\.]+((\s*,\s*[\w\.]+)*))|\*)(\s*(>(\d+)?-|-(\d+)?>|<(\d+)?-|-(\d+)?<|<-(\d+)?->|>-(\d+)?-<)\s*(([\w\.]+(\s*,\s*[\w\.]+)*)|\*))?\s*/,
		get_state_description = function (str) {
			return str === "*" ? any_state : _.map(str.split(","), function (str) { return str.trim(); });
		},
		get_state_listener_info = function (str_descriptor) {
			var matches = str_descriptor.match(state_descriptor_regex);
			if (matches) {
				var from_states = get_state_description(matches[1]);
				var transition = matches[6];
				if (transition) {
					var to_states = get_state_description(matches[13]);

					if (transition.indexOf("<") >= 0 && transition.indexOf(">") < 0) {
						transition = transition.split("").reverse().join("");
						var tmp = from_states;
						from_states = to_states;
						to_states = tmp;
					}

					var transition_no = matches[7] || matches[8] || matches[9] || matches[10] || matches[11] || matches[12] || false;
					if (_.isString(transition_no)) {
						transition_no = parseInt(transition_no, 10);
					}
					var is_bidirectional = ((transition[0] === ">") && (transition[transition.length - 1] === "<")) ||
											((transition[0] === "<") && (transition[transition.length - 1] === ">"));
					return {
						type: "transition",
						from: from_states,
						to: to_states,
						pre: transition[0] === ">",
						bidirectional: is_bidirectional,
						transition_no: transition_no
					};
				} else {
					return {
						type: "state",
						states: from_states
					};
				}
			} else {
				throw new Error(str_descriptor + " does not match format");
			}
		},
		matches_name = function (statechart, states, state) {
			var i, len;
			if (states === any_state) {
				return true;
			} else {
				var state_name = state.get_name(statechart);
				len = states.length;
				for (i = 0; i < len; i += 1) {
					var s = states[i];
					if (s === state || s === state_name) {
						return true;
					}
				}
				return false;
			}
		},
		add_transition_listener = function (str, statechart, activation_listener, deactivation_listener, context) {
			context = context || this;

			var listener_info;
			if (_.isString(str)) {
				listener_info = get_state_listener_info(str);
			} else {
				listener_info = str;
			}

			var type = listener_info.type;
			var event_type, listener;
			if (type === "state") {
				event_type = "pre_transition_fire";
				var activated = false;
				listener = function (event) {
					var listener_args = arguments,
						mname = matches_name(statechart, listener_info.states, event.state);
					if (activated === false && mname) {
						activated = true;

						ist.event_queue.once("end_event_queue_round_6", function () {
							activation_listener.apply(context, listener_args);
						}, this);
					} else if (activated === true && !mname) {
						activated = false;

						ist.event_queue.once("end_event_queue_round_2", function () {
							deactivation_listener.apply(context, listener_args);
						}, this);
					}
				};
			} else if (type === "transition") {
				event_type = listener_info.pre ? "pre_transition_fire" : "post_transition_fire";
				listener = function (event) {
					var transition = event.transition,
						from = transition.from(),
						to = transition.to();

					var desired_transition = false;
					if (_.isNumber(listener_info.transition_no)) {
						var transitions_between = from.get_transitions_to(to);
						desired_transition = transitions_between[listener_info.transition_no];
					}


					if (!desired_transition || transition === desired_transition) {
						if ((matches_name(statechart, listener_info.from, from) &&
								matches_name(statechart, listener_info.to, to)) ||
									(listener_info.bidirectional &&
											matches_name(statechart, listener_info.to, from) &&
											matches_name(statechart, listener_info.from, to))) {

							var listener_args = arguments;
							activation_listener.apply(context, listener_args);

							if (listener_info.pre) {
								ist.event_queue.once("end_event_queue_round_1", function () {
									deactivation_listener.apply(context, listener_args);
								});
							} else {
								ist.event_queue.once("end_event_queue_round_5", function () {
									deactivation_listener.apply(context, listener_args);
								});
							}
						}
					}
				};
			} else {
				throw new Error("Unexpected type " + type);
			}

			statechart.on(event_type, listener);
			return {
				str: str,
				statechart: statechart,
				activation_listener: activation_listener,
				deactivation_listener: deactivation_listener,
				context: context,
				destroy: function () { statechart.off(event_type, listener); }
			};
		};

	ist.Statechart = function (options, defer_initialization) {
		options = options || {};

		ist.Statechart.superclass.constructor.apply(this, arguments);

		if(options.avoid_constructor) { return; }

		this._transition_listeners = {};

		this.$substates = options.substates || cjs.map();
		this.$substates.setValueHash("hash");
		this.$concurrent = cjs(options.concurrent === true);
		this._parent = options.parent;
		this.$incoming_transitions = options.incoming_transitions || cjs.array();
		this.$outgoing_transitions = options.outgoing_transitions || cjs.array();

		this._start_state = options.start_state;
		var basis_start_state, basis_start_state_to;
		if (this._basis) {

			basis_start_state = this._basis.get_start_state();
			basis_start_state_to = basis_start_state.getTo();

			var is_running = this.is_running(),
				my_context = this.context(),
				is_concurrent = this.is_concurrent();

			_.each(this._basis.get_substates(true), function (substate, name) {
				var shadow = substate.create_shadow({
					context: my_context,
					parent: this,
					running: is_running && (basis_start_state_to === substate || is_concurrent),
					active: is_running && (basis_start_state_to === substate || is_concurrent),
					set_basis_as_root: false
				}, defer_initialization);
				if (shadow instanceof ist.StartState) {
					this.set_start_state(shadow);
				} else {
					this.add_substate(name, shadow);
				}
			}, this);
			_.each(this._basis._transition_listeners, function (listeners, name) {
				_.each(listeners, function (info) {
					this.on_transition(info.str, info.activation_listener, info.deactivation_listener, info.context);
				}, this);
			}, this);

			if (options.set_basis_as_root === true) { // When all of the substates have been copied
				var parent_statechart = this;

				var create_transition_shadow = _.memoize(function (transition) {
					var from = ist.find_equivalent_state(transition.from(), parent_statechart);
					var to = ist.find_equivalent_state(transition.to(), parent_statechart);
					return transition.create_shadow(from, to, parent_statechart, my_context, true);
				}, function (transition, from) {
					return transition.id();
				});

				this.do_shadow_transitions(create_transition_shadow);
			}
		}
		
		if(!this._start_state) {
			this._start_state = new ist.StartState({
				parent: this,
				to: options.start_at,
				context: options.context
			});
		}

		var my_starting_state;
		if (this._running && this._basis) {
			basis_start_state = this._basis.get_start_state();
			basis_start_state_to = basis_start_state.getTo();
			
			if (basis_start_state_to === basis_start_state) {
				my_starting_state = this._start_state;
			} else {
				//if(!this.is_puppet()) {
					//this.increment_start_state_times_run(this);
					//_.defer(this.increment_start_state_times_run, this);
				//}
				my_starting_state = ist.find_equivalent_state(basis_start_state_to, this);
			}
		} else {
			my_starting_state = this._start_state;
		}

		this.$local_state = new cjs.Constraint(my_starting_state);
		if(this.is_active()) {
			if(options.concurrent === true) {
				if(!this.is_puppet()) {
					_.each(this.get_substates(), function(substate) {
						substate.disable_immediate_outgoing_transitions();
						substate.disable_immediate_incoming_transitions();
						substate.set_active(true);
						substate.run();
					});
				}
			} else {
				if(!this.is_puppet()) {
					//my_starting_state.enable_outgoing_transitions();
					my_starting_state.set_active(true);
					my_starting_state.run();
				}
			}
		}

		this._constructed = true;

		if((!this._parent && defer_initialization !== true) || (this._parent && this._parent.is_initialized())) {
			this.initialize();
		}
	};
	(function (My) {
		_.proto_extend(My, ist.State);
		var proto = My.prototype;

		My.START_STATE_NAME = "(start)";

		proto.increment_start_state_times_run = function(self) {
			var outgoing_transition = self._start_state.get_outgoing_transition();
			if(outgoing_transition) {
				outgoing_transition.increment_times_run();
			}
		};

		proto.initialize = function () {
			_.each(this.get_substates(true), function(substate) {
				substate.initialize();
			});
			//if (this._basis) { // shadow
				//_.each(this.get_outgoing_transitions(), function(transition) {
					//transition.initialize();
				//});
			//}
			My.superclass.initialize.apply(this, arguments);
		};

		proto.is_concurrent = function () { return this.$concurrent.get(); };
		proto.make_concurrent = function (is_concurrent) {
			is_concurrent = is_concurrent === true;
			this.$concurrent.set(is_concurrent);
			this._emit("make_concurrent", {
				target: this,
				concurrent: is_concurrent
			});
			var start_state = this.get_start_state();
			if(!this.is_puppet()) {
				if(is_concurrent) {
					if(this.is_active() || this.parent() === undefined) {
						_.each(this.get_substates(), function(substate) {
							substate.disable_immediate_outgoing_transitions();
							substate.disable_immediate_incoming_transitions();
							substate.set_active(true);
							substate.run();
							var starting_state = substate.get_active_substate();
							starting_state.set_active(true);
							starting_state.run();
						});
					}
					start_state.set_active(false);
				} else {
					//var start_transition = start_state.get_outgoing_transition();
					//var starting_state = start_transition.to();
					var starting_state = this.get_active_substate();
					_.each(this.get_substates(), function(substate) {
						if(substate !== starting_state) {
							substate.set_active(false);
							substate.stop();
						}
					});
					//start_state.set_active(true);
					starting_state.set_active(true);
					starting_state.run();
					//starting_state.enable_outgoing_transitions();
				}
			}
			return this;
		};
		proto.get_substates = function (include_start) {
			if(this.$substates) {
				var rv = {};

				this.$substates.forEach(function (substate, name) {
					rv[name] = substate;
				});

				if (include_start) {
					rv[My.START_STATE_NAME] = this.get_start_state();
				}

				return rv;
			} else {
				return [];
			}
		};
		proto.run = function() {
			cjs.wait();
			var was_running = this.is_running();
			My.superclass.run.apply(this, arguments);
			if(!was_running) {
				if(this.is_concurrent()) {
					_.each(this.get_substates(), function(substate) {
						substate.run();
						substate.set_active(true);
					});
				} else {
					var local_state = this.$local_state.get();
					//local_state.enable_outgoing_transitions();
					local_state.run();
					local_state.set_active(true);
				/*
					var start_state = this.get_start_state();
					this.$local_state.set(start_state);
					start_state.enable_outgoing_transitions();
					start_state.run();
					start_state.set_active(true);
					*/
				}
			}
			cjs.signal();
		};
		proto.stop = function() {
			cjs.wait();
			var was_running = this.is_running();
			My.superclass.stop.apply(this, arguments);
			if(was_running) {
				if(this.is_concurrent()) {
					_.forEach(this.get_substates(true), function (substate) {
						substate.set_active(false);
						substate.stop();
					});
				} else {
					var local_state = this.$local_state.get();
					if(local_state) {
						local_state.set_active(false);
						//local_state.disable_outgoing_transitions();
					}
					this.$local_state.set(this._start_state);
					_.forEach(this.get_substates(true), function (substate) {
						substate.stop();
					});
				}
			}
			cjs.signal();
		};
		proto.get_start_state = function () { return this._start_state; };
		proto.set_start_state = function (state) {
			cjs.wait();
			if(this._start_state) {
				this._start_state.destroy(true);
			}
			if (this.$local_state && this.$local_state.get() === this.get_start_state()) {
				this.$local_state.set(state);
				//this.$local_state.enable_outgoing_transitions();
			}
			this._start_state = state;
			cjs.signal();
		};
		proto.get_incoming_transitions = function () {
			if(this.$incoming_transitions) {
				return this.$incoming_transitions.toArray();
			} else {
				return [];
			}
		};
		proto.get_outgoing_transitions = function () {
			if(this.$outgoing_transitions) {
				return this.$outgoing_transitions.toArray();
			} else {
				return [];
			}
		};
		proto.get_active_substate = function () { return this.$local_state.get(); };

		proto.get_state_index = function (state_name) {
			return this.$substates.indexOf(state_name);
		};

		proto.set_active_substate = function (state, transition, event) {
			if(transition) {
			/*
				if(is_my_transition) {
					ist.event_queue.once("end_event_queue_round_0", function () {
							this._emit("pre_transition_fire", {
								type: "pre_transition_fire",
								transition: transition,
								target: this,
								event: event,
								state: state
							});
							transition.set_active(true);
					}, this);

					ist.event_queue.once("end_event_queue_round_2", function () {
						if(!this.is_concurrent()) {
							transition.increment_times_run();
						}
					}, this);
				}
				*/

				ist.event_queue.once("end_event_queue_round_3", function () {
					if(this.is_concurrent()) {
						_.each(this.get_substates(true), function(substate) {
							substate.set_active(true);
							//substate.enable_outgoing_transitions();
							substate.run();
							if(substate instanceof ist.Statechart) {
								var starts_at = substate.get_active_substate();
								substate.set_active_substate(starts_at);
							}
						});
					} else {
						var local_state = this.$local_state.get();
						cjs.wait();
						if(local_state !== state) {
							if (local_state) {
								local_state.stop();
								//local_state.disable_outgoing_transitions();
								local_state.set_active(false);
							}
							local_state = state;
							this.$local_state.set(local_state);
							local_state._last_run_event.set(event);
						}
						if (local_state) {
							local_state.set_active(true);
							//local_state.enable_outgoing_transitions();
							local_state.run();
						}
						cjs.signal();
					}
				}, this);

/*
				if(is_my_transition) {
					ist.event_queue.once("end_event_queue_round_4", function () {
						transition.set_active(false);
						this._emit("post_transition_fire", {
							type: "post_transition_fire",
							transition: transition,
							target: this,
							event: event,
							state: state
						});
					}, this);
				}
				*/
			} else {
				//cjs.wait();
				if(this.is_concurrent()) {
					_.each(this.get_substates(true), function(substate) {
						substate.set_active(true);
						//substate.enable_outgoing_transitions();
						substate.run();
						if(substate instanceof ist.Statechart) {
							var starts_at = substate.get_active_substate();
							substate.set_active_substate(starts_at);
						}
					});
				} else {
					var local_state = this.$local_state.get();
					if(local_state !== state) {
						if (local_state) {
							local_state.stop();
							//local_state.disable_outgoing_transitions();
							local_state.set_active(false);
						}
						local_state = state;
						this.$local_state.set(local_state);
					}
					if (local_state) {
						local_state.set_active(true);
						//local_state.enable_outgoing_transitions();
						local_state.run();
					}
				}
				//cjs.signal();
			}
		};
		proto.get_name_for_substate = function (substate) {
			return substate === this.get_start_state() ? My.START_STATE_NAME : this.$substates.keyForValue(substate);
		};
		proto.get_active_direct_substates = function () {
			if (this.is_concurrent()) {
				return this.get_substates();
			} else {
				return [this.$local_state.get()];
			}
		};
		proto.get_active_states = function () {
			return _.chain(this.get_active_direct_substates())
				.map(function (substate) {
					return ([substate]).concat(substate.get_active_states());
				})
				.flatten(true)
				.value();
		};
		proto.get_substate_with_name = function (name) {
			if (name === My.START_STATE_NAME) {
				return this.get_start_state();
			} else {
				return this.$substates.get(name);
			}
		};
		proto.has_substate_with_name = function (name) {
			if (name === My.START_STATE_NAME) {
				return true;
			} else {
				return this.$substates.has(name);
			}
		};
		proto.find_state = function (state_name, create_superstates, state_value, index) {
			var state;
			if (state_name instanceof ist.State) {
				return state_name;
			} else if (_.isArray(state_name)) {
				if (_.isEmpty(state_name)) {
					return this;
				} else {
					var first_state_name = _.first(state_name);
					if (_.size(state_name) === 1) {
						if (!this.has_substate_with_name(first_state_name) && create_superstates === true) {
							this.add_substate(first_state_name, state_value, index);
						}
						state = this.get_substate_with_name(first_state_name);
						return state || undefined;
					} else {
						if (create_superstates === true && !this.has_substate_with_name(first_state_name)) {
							this.add_substate(first_state_name);
						}
						state = this.get_substate_with_name(first_state_name);
						if (!state) {
							return undefined;
						} else {
							return state.find_state(_.rest(state_name), create_superstates, state_value, index);
						}
					}
				}
			} else if (_.isString(state_name)) {
				return this.find_state(state_name.split("."), create_superstates, state_value, index);
			} else {
				return undefined;
			}
		};
		proto.find_transitions = function (from, to, index) {
			from = this.find_state(from);
			to = this.find_state(to);

			if (!from || !to) {
				return undefined;
			}

			var rv = from.get_transitions_to(to);

			if (_.isNumber(index)) {
				return rv[index];
			} else {
				return rv;
			}
		};
		proto.get_substate_index = function (substate) {
			var name = substate.get_name(this);
			return this.$substates.indexOf(name);
		};
		proto.add_substate = function (state_name, state, index) {
			if (state instanceof ist.Statechart) {
				state.set_parent(this);
			} else {
				state = new ist.Statechart({parent: this, context: this.context()});
			}
			state.on("pre_transition_fire", this.forward_event, this);
			state.on("post_transition_fire", this.forward_event, this);
			this.$substates.put(state_name, state, index);
			this._emit("add_substate", {
				type: "add_substate",
				state_name: state_name,
				state: state,
				index: index
			});
			if(this.is_active() && !this.is_puppet()) {
				if(this.is_concurrent()) {
					state.set_active(true);
					state.run();
					var starts_at = state.get_active_substate();
					state.set_active_substate(starts_at);
				}
			}
		};
		proto.remove_substate = function (name, state, also_destroy) {
			state = state || this.$substates.get(name);

			cjs.wait();
			state.off("pre_transition_fire", this.forward_event, this);
			state.off("post_transition_fire", this.forward_event, this);
			var incoming_transitions = state.get_incoming_transitions();
			var outgoing_transitions = state.get_outgoing_transitions();
			_.each(incoming_transitions, function(transition) {
				var from = transition.from();
				if(from instanceof ist.StartState) {
					from.setTo(from);
				} else {
					transition.remove();
				}
			});
			_.forEach(outgoing_transitions, function (transition) {
				transition.remove();
			});
			if (this.get_active_substate() === state) {
				this.set_active_substate(this.get_start_state().getTo());
			}
			this.$substates.remove(name);

			cjs.signal();

			this._emit("remove_substate", {
				type: "remove_substate",
				state: state,
				name: name,
				also_destroy: also_destroy
			});

			if (also_destroy !== false) {
				state.destroy();
			}
		};
		proto.rename_substate = function (from_name, to_name) {
			var keyIndex = this.$substates.indexOf(from_name);
			if (keyIndex >= 0) {
				var substate = this.$substates.get(from_name);
				cjs.wait();
				this.$substates	.remove(from_name)
								.put(to_name, substate, keyIndex);
				this._emit("rename_substate", {
					type: "rename_substate",
					state: substate,
					from: from_name,
					to: to_name
				});
				cjs.signal();
			}
		};
		proto.move_substate = function (state_name, index) {
			this.$substates.move(state_name, index);
			this._emit("move_substate", {
				type: "move_substate",
				state_name: state_name,
				index: index
			});
		};
		proto.add_state = function (state_name, state, index) {
			if (this.find_state(state_name)) {
				throw new Error("State with name '" + state_name + "' already exists.");
			}
			this.find_state(state_name, true, state, index);
			return this;
		};
		proto.remove_state = function (state_name, also_destroy) {
			var state = this.find_state(state_name);
			if (!_.isUndefined(state)) {
				var parent = state.parent();
				if (!_.isUndefined(parent)) {
					parent.remove_substate(state_name, state, also_destroy);
				}
			}
			return this;
		};
		proto.rename_state = function (from_name, to_name) {
			var from_state = this.find_state(from_name);
			if (from_state) {
				var from_state_parent = from_state.parent();
				if (from_state_parent) {
					var to_name_arr = to_name.split(".");
					var to_state_parent = this.find_state(_.initial(to_name_arr), true);
					var to_state_name = _.last(to_name_arr);
					if (from_state_parent === to_state_parent) {
						var from_name_arr = from_name.split(".");
						var from_state_name = _.last(from_name_arr);
						from_state_parent.rename_substate(from_state_name, to_state_name);
					} else {
						cjs.wait();
						from_state_parent.remove_state(from_state, false);
						to_state_parent.add_state(to_state_name, from_state);
						cjs.signal();
					}
				}
			}
			return this;
		};
		proto.move_state = function (state_name, index) {
			var state = this.find_state(state_name);
			if (state) {
				var parent = state.parent();
				if (parent) {
					state_name = parent.get_name_for_substate(state);
					parent.move_substate(state_name, index);
				}
			}
			return this;
		};
		proto.destroy = function (silent) {
			this._emit("destroy", {
				type: "destroy",
				target: this
			});

			cjs.wait();
			_.forEach(this.get_incoming_transitions(), function (transition) {
				var from = transition.from();
				if(from instanceof ist.StartState) {
					from.setTo(from);
				} else {
					transition.remove().destroy(silent);
				}
			});
			_.forEach(this.get_outgoing_transitions(), function (transition) {
				transition.remove().destroy(silent);
			});
			_.forEach(this.get_substates(true), function (substate) {
				substate.destroy(silent);
			});
			if(this.$substates) {
				this.$substates.destroy(silent);
				delete this.$substates;
			}
			delete this._start_state;
			if(this.$concurrent) {
				this.$concurrent.destroy(silent);
				delete this.$concurrent;
			}

			if(this.$incoming_transitions) {
				this.$incoming_transitions.destroy(silent);
				delete this.$incoming_transitions;
			}
			if(this.$outgoing_transitions) {
				this.$outgoing_transitions.destroy(silent);
				delete this.$outgoing_transitions;
			}

			if(this.$local_state) {
				this.$local_state.destroy(true);
				delete this.$local_state;
			}
			//this.get_start_state().destroy();

			My.superclass.destroy.apply(this, arguments);
			cjs.signal();
		};
		proto.get_substate_names = function () {
			return this.$substates.keys();
		};
		/*
		proto.is = function (state) {
			var i;
			state = this.find_state(state);
			if (state) {
				var to_check_lineage = state.get_lineage(this);
				if (to_check_lineage[0] !== this) { //It has a different root
					return false;
				} else {
					var len = to_check_lineage.length - 1;
					for (i = 0; i < len; i += 1) {
						var s = to_check_lineage[i];
						if (!s.is_concurrent() && (s.get_active_substate() !== to_check_lineage[i + 1])) {
							return false;
						}
					}
					return true;
				}
			} else {
				return false;
			}
		};
		proto.contains = function (state, direct) {
			direct = direct !== false;
			state = this.find_state(state);
			if (this === state) {
				return true;
			} else {
				var substates = this.get_substates(true);
				return _.any(substates, function (substate) {
					return substate.contains(state);
				});
			}
		};
		*/
		proto.add_transition = function (arg0, arg1, arg2) {
			var from_state, to_state, transition;
			if (arguments.length === 1) {
				if (arg0 instanceof ist.StatechartTransition) {
					transition = arg0;
					from_state = transition.from();
					to_state = transition.to();
				}
			} else {
				from_state = this.find_state(arg0);
				if (!from_state) { throw new Error("No state '" + arg0 + "'"); }
				to_state = this.find_state(arg1);
				if (!to_state) { throw new Error("No state '" + arg1 + "'"); }
				var event = arg2;
				transition = new ist.StatechartTransition({from: from_state, to: to_state, event: event});
				this._last_transition  = transition;

				from_state._add_direct_outgoing_transition(transition);
				to_state._add_direct_incoming_transition(transition);
			}

			if (from_state.is_active()) {
				transition.enable();
			} else {
				transition.disable();
			}

			this._emit("add_transition", {
				type: "add_transition",
				target: this,
				transition: transition,
				from_state: from_state,
				to_state: to_state
			});

			return this;
		};
		proto.get_transitions_to = function (to) {
			return this.$outgoing_transitions.filter(function (transition) {
				return transition.to() === to;
			});
		};
		proto.get_transitions_from = function (from) {
			return this.$incoming_transitions.filter(function (transition) {
				return transition.from() === from;
			});
		};
		proto._add_direct_outgoing_transition = function (transition, index) {
			if (_.isNumber(index)) {
				this.$outgoing_transitions.splice(index, 0, transition);
			} else {
				this.$outgoing_transitions.push(transition);
			}
		};
		proto._add_direct_incoming_transition = function (transition, index) {
			if (_.isNumber(index)) {
				this.$incoming_transitions.splice(index, 0, transition);
			} else {
				this.$incoming_transitions.push(transition);
			}
		};
		proto._remove_direct_outgoing_transition = function (transition) {
			var index = this.$outgoing_transitions.indexOf(transition);
			if (index >= 0) {
				this.$outgoing_transitions.splice(index, 1);
			}
		};
		proto._remove_direct_incoming_transition = function (transition) {
			var index = this.$incoming_transitions.indexOf(transition);
			if (index >= 0) {
				this.$incoming_transitions.splice(index, 1);
			}
		};
		proto.get_initial_state = function () {
			var start_state = this.get_start_state();
			return start_state.getTo();
		};
		proto.starts_at = proto.set_initial_state = function (state) {
			state = this.find_state(state, false);
			if (!state) {
				throw new Error("Could not find state " + state);
			}
			var start_state = this.get_start_state();
			start_state.setTo(state);
			return this;
		};

		proto.create_shadow = function (options, defer_initialization) {
			var rv = new ist.Statechart(_.extend({
				basis: this,
				concurrent: this.is_concurrent(),
				set_basis_as_root: true
			}, options), defer_initialization);

			return rv;
		};

		proto.get_transitions = function () {
			return (this.get_incoming_transitions()).concat(this.get_outgoing_transitions());
		};

		proto.get_substate_transitions = function () {
			var my_transitions = this.get_transitions();
			return _.uniq(
				_.flatten(
					my_transitions.concat(_.map(this.get_substates(), function (substate) {
						return substate.get_substate_transitions();
					})),
					true
				)
			);
		};

		proto.on_transition = proto.on_state = function (str, activation_listener, deactivation_listener, context) {
			var info = add_transition_listener(str, this, activation_listener, deactivation_listener, context);

			this._emit("on_transition", {
				type: "on_transition",
				target: this,
				str: str,
				activation_listener: activation_listener,
				deactivation_listener: deactivation_listener,
				context: context
			});

			var tlisteners = this._transition_listeners[str];
			if (_.isArray(tlisteners)) {
				tlisteners.push(info);
			} else {
				tlisteners = this._transition_listeners[str] = [info];
			}
			return this;
		};
		proto.off_transition = proto.on_state = function (str, activation_listener, deactivation_listener, context) {
			this._emit("off_transition", {
				type: "off_transition",
				target: this,
				str: str,
				activation_listener: activation_listener,
				deactivation_listener: deactivation_listener,
				context: context
			});
			var tlisteners = this._transition_listeners[str];
			var i;
			if (_.isArray(tlisteners)) {
				for (i = 0; i < tlisteners.length; i += 1) {
					var tlistener = tlisteners[i];
					if (tlistener.activation_listener === activation_listener &&
							tlistener.deactivation_listener === deactivation_listener) {
						tlistener.destroy();
						tlisteners.splice(i, 1);
						i -= 1;
					}
				}
				if (tlisteners.length === 0) {
					delete this._transition_listeners[str];
				}
			}
		};
		proto.print = function () {
			ist.print_statechart.apply(ist, ([this]).concat(_.toArray(arguments)));
		};

		ist.register_serializable_type("statechart",
			function (x) {
				return x instanceof My;
			},
			function (include_id) {
				var arg_array = _.toArray(arguments);
				var rv = {
					substates: ist.serialize.apply(ist, ([this.$substates]).concat(arg_array)),
					concurrent: this.is_concurrent(),
					start_state: ist.serialize.apply(ist, ([this.get_start_state()]).concat(arg_array)),
					outgoing_transitions: ist.serialize.apply(ist,
															([this.$outgoing_transitions]).concat(arg_array)),
					incoming_transitions: ist.serialize.apply(ist,
															([this.$incoming_transitions]).concat(arg_array)),
					parent: ist.serialize.apply(ist, ([this.parent()]).concat(arg_array))
				};
				if (include_id) {
					rv.id = this.id();
				}
				return rv;
			},
			function (obj) {
				var rest_args = _.rest(arguments);
				var rv;
				if (obj.id) {
					rv = ist.find_uid(obj.id);
					if (rv) {
						return rv;
					}
				}
				rv = new My({
					avoid_constructor: true
				});
				var initialization_func = function () {
					delete this.initialize;
					var substates = ist.deserialize.apply(ist, ([obj.substates]).concat(rest_args));
					substates.forEach(function(state) {
						state.do_initialize_substate();
						delete state.do_initialize_substate;
					});
					My.call(this, {
						id: obj.id,
						concurrent: obj.concurrent,
						substates: substates,
						//ist.deserialize.apply(ist, ([obj.substates]).concat(rest_args)),
						start_state: ist.deserialize.apply(ist, ([obj.start_state]).concat(rest_args)),
						outgoing_transitions: ist.deserialize.apply(ist,
															([obj.outgoing_transitions]).concat(rest_args)),
						incoming_transitions: ist.deserialize.apply(ist,
															([obj.incoming_transitions]).concat(rest_args)),
						parent: ist.deserialize.apply(ist, ([obj.parent]).concat(rest_args))
					});
				};

				if(obj.parent) {
					rv.do_initialize_substate = initialization_func;
				} else {
					// it's the root
					rv.initialize = initialization_func;
				}

				return rv;
			});
	}(ist.Statechart));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.find_equivalent_transition = function (to_transition, in_tree) {
		var from = to_transition.from();
		var to = to_transition.to();
		var in_tree_from = ist.find_equivalent_state(from, in_tree);
		var in_tree_from_outgoing = in_tree_from.get_outgoing_transitions();
		var len = in_tree_from_outgoing.length;
		var i;
		for (i = 0; i < len; i += 1) {
			var t = in_tree_from_outgoing[i];
			if (t.basis() === to_transition) {
				return t;
			}
		}
		throw new Error("Could not find equivalent transition");
	};

	ist.StatechartTransition = function (options, defer_initialization) {
		options = options || {};

		if(!this._started_construction) {
			this._started_construction = true;

			this._initialized = cjs(false);
			able.make_this_listenable(this);

			this._id = options.id || uid();
			ist.register_uid(this._id, this);
		}

		if(options.avoid_constructor) { return; }

		this._last_run_event = cjs(false);
		this._enabled = options.enabled === true;
		if(ist.__debug_statecharts) {
			this.$enabled = cjs(this._enabled);
		}

		this._puppet = options.puppet === true;
		this.$active = cjs(false);
		this.is_start_transition = options.from instanceof ist.StartState;
		this._times_run = options.times_run || (this.is_start_transition ? 1 : 0);
		this.$times_run = cjs(this._times_run);
		this._from_state = new cjs.Constraint(options.from);
		this._to_state = new cjs.Constraint(options.to);
		this._context = options.context;
		this.set_basis(options.basis);
		this.set_event(options.event);

		if (defer_initialization !== true) {
			this.initialize(options);
		}
	};
	(function (My) {
		var proto = My.prototype;
		able.make_proto_listenable(proto);
		proto.initialize = function (options) {
			if (this._event) {
				this._event.initialize();
			}
			this._initialized.set(true);
			this._emit("initialized");
		};
		proto.updateTo = function(event) {
			var state = event.state;
			var old_to = this.to();
			var new_to = ist.find_equivalent_state(state, old_to);
			this.setTo(new_to);
		};
		proto.updateFrom = function(event) {
			var state = event.state;
			var old_from = this.from();
			var new_from = ist.find_equivalent_state(state, old_from);
			this.setFrom(new_from);
		};
		proto.is_puppet = function () {
			return this._puppet;
		};
		proto.is_initialized = function () {
			return this._initialized.get();
		};
		proto.increment_times_run = function () {
			this.$times_run.set(++this._times_run);
		};
		proto.get_times_run = function () {
			return this.$times_run.get();
		};
		proto.context = function () {
			return this._context;
		};
		proto.set_active = function (to_active) {
			to_active = to_active === true;
			this.$active.set(to_active);
		};
		proto.is_active = function (to_active) { return this.$active.get(); };
		proto.basis = function () { return this._basis; };
		proto.set_basis = function (basis) {
			if (this._basis) {
				this._basis.off("setTo", this.updateTo, this);
				this._basis.off("setFrom", this.updateFrom, this);
				this._basis.off("remove", this.remove, this);
				this._basis.off("destroy", this.destroy, this);
			}
			this._basis = basis;
			if (this._basis) {
				this._basis.on("setTo", this.updateTo, this);
				this._basis.on("setFrom", this.updateFrom, this);
				this._basis.on("remove", this.remove, this);
				this._basis.on("destroy", this.destroy, this);
			}
			return this;
		};
		proto.id = proto.hash = function () { return this._id; };
		proto.sid = function() { return parseInt(uid.strip_prefix(this.id()), 10); };
		proto.from = function () { return this._from_state.get(); };
		proto.to = function () { return this._to_state.get(); };
		proto.setFrom = function (state) {
			var from = this.from();
			if (from) {
				from._remove_direct_outgoing_transition(this);
			}
			this._from_state.set(state);
			var do_set_from = function() {
				state._add_direct_outgoing_transition(this);
				if(state.is_active()) {
					this.enable();
				} else {
					this.disable();
				}
			};
			if(state.is_initialized()) {
				do_set_from.call(this);
			} else {
				state.once("initialized", do_set_from, this);
			}
			this._emit("setFrom", {type: "setFrom", target: this, state: state});
			return this;
		};
		proto.setTo = function (state) {
			var to = this.to();
			if (to) {
				to._remove_direct_incoming_transition(this);
			}
			this._to_state.set(state);
			var do_set_to = function() {
				state._add_direct_incoming_transition(this);
				if(this.is_start_transition) {
					var from = this.from();
					if(from.is_active() && from.is_running()) {
						ist.event_queue.wait();
						this.fire({});
						ist.event_queue.signal();
					}
				}
			};
			if(state.is_initialized()) {
				do_set_to.call(this);
			} else {
				state.once("initialized", do_set_to, this);
			}
			this._emit("setTo", {type: "setTo", target: this, state: state});
			return this;
		};
		proto.set_event = function (event) {
			if (this._event) {
				this._event.off_fire(this.fire, this);
				this._event.destroy();
			}
			this._event = event;
			if (this._event) {
				this._event.set_transition(this);
				this._event.on_fire(this.fire, this);
			}
		};
		proto.order = function(order_to) {
			if(order_to instanceof ist.State) {
				return 1;
			} else {
				return 0;
			}
		};
		proto.event = function () { return this._event; };
		proto.involves = function (state) { return this.from() === state || this.to() === state; };
		proto.destroy = function (silent) {
			this.destroyed = true;
			this._emit("destroy", {type: "destroy", target: this});
			cjs.wait();
			if(this.$active) {
				this.$active.destroy(silent);
			}

			this._from_state.destroy(silent);
			delete this._from_state;

			this._to_state.destroy(silent);
			delete this._to_state;

			this.set_basis(undefined);
			
			this._event.off_fire(this.fire, this);
			this._event.destroy(silent);
			delete this._event;

			this._initialized.destroy(silent);
			delete this._initialized;

			this._last_run_event.destroy(silent);
			delete this._last_run_event;

			this.$active.destroy(silent);
			delete this.$active;
			
			this.$times_run.destroy(silent);
			delete this.$times_run;

			delete this._context;

			if(ist.__debug_statecharts) {
				this.$enabled.destroy(silent);
				delete this.$enabled;
			}

			cjs.signal();
			able.destroy_this_listenable(this);
			ist.unregister_uid(this.id());
		};

		proto.fire = function (event) {
			if (this.is_puppet()) {
				this._emit("fire", {type: "fire", target: this});
			} else if (this.from().on_outgoing_transition_fire(this, event)) {
				this._emit("fire", {type: "fire", target: this});
			}
		};
		proto.create_shadow = function (from_state, to_state, parent_statechart, context, defer_initialization) {
			var my_event = this.event(),
				shadow_event = my_event.create_shadow(parent_statechart, context, from_state.is_running());
			var shadow_transition = new ist.StatechartTransition({
					from: from_state,
					to: to_state,
					event: shadow_event,
					basis: this,
					context: context
				}, defer_initialization);
			return shadow_transition;
		};
		proto.stringify = function () {
			var event = this.event();
			var stringified_event = event ? event.stringify() : "";
			return stringified_event.toString();
		};
		proto.remove = function () {
			var from = this.from();
			var to = this.to();
			this.disable();
			cjs.wait();
			from._remove_direct_outgoing_transition(this);
			to._remove_direct_incoming_transition(this);
			cjs.signal();
			this._emit("remove", {type: "remove", transition: this});
			return this;
		};
		proto.root = function () {
			return this.from().root();
		};

		proto.enable = function () {
			if(!this._enabled) {
				this._enabled = true;
				var event = this.event();
				event.enable();
				if(ist.__debug_statecharts) {
					this.$enabled.set(true);
				}
			}
		};

		proto.disable = function () {
			if(this._enabled) {
				this._enabled = false;
				var event = this.event();
				event.disable();
				if(ist.__debug_statecharts) {
					this.$enabled.set(false);
				}
			}
		};

		proto.is_enabled = function () {
			return this._enabled;
		};

		if(ist.__debug_statecharts) {
			proto.get_$enabled = function() {
				return this.$enabled.get();
			};
		}

		proto.summarize = function () {
			var context = this.context();
			var summarized_context;
			if (context) {
				summarized_context = context.summarize();
			}
			var my_basis = this.basis() || this;
			return {
				basis_id: my_basis.id(),
				context: summarized_context
			};
		};
		My.desummarize = function (obj) {
			if (obj.context) {
				var state_basis = ist.find_uid(obj.basis_id);
				var context = ist.Pointer.desummarize(obj.context);
				var dict = context.points_at();
				var contextual_statechart = dict.get_statechart_for_context(context);

				var state = ist.find_equivalent_transition(state_basis, contextual_statechart);
				return state;
			} else {
				return ist.find_uid(obj.basis_id);
			}
		};


		ist.register_serializable_type("statechart_transition",
			function (x) {
				return x instanceof My;
			},
			function (include_id) {
				var args = _.toArray(arguments);
				var rv = {
					from: ist.serialize.apply(ist, ([this.from()]).concat(args)),
					to: ist.serialize.apply(ist, ([this.to()]).concat(args)),
					event: ist.serialize.apply(ist, ([this.event()]).concat(args))
				};
				if (include_id) {
					rv.id = this.id();
				}
				return rv;
			},
			function (obj, deserialize_options) {
				var rest_args = _.rest(arguments),
					rv = new My({
						avoid_constructor: true
					});
				rv.initialize = function() {
					delete this.initialize;
					My.call(this, {
						id: obj.id,
						from: ist.deserialize.apply(ist, ([obj.from]).concat(rest_args)),
						to: ist.deserialize.apply(ist, ([obj.to]).concat(rest_args)),
						event: ist.deserialize.apply(ist, ([obj.event]).concat(rest_args))
					});
				};
				return rv;
			});
	}(ist.StatechartTransition));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,window,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var EventQueue = function () {
		able.make_this_listenable(this);

		this.end_queue_round = false;
		this.queue = [];
		this.running_event_queue = false;

		var semaphore = 0;
		this.wait = function () {
			semaphore--;
		};
		this.signal = function () {
			semaphore++;
			if (semaphore >= 0) {
				this.run_event_queue();
			}
		};
		this.is_ready = function () {
			return semaphore >= 0;
		};
		this.num_post_event_queue_rounds = 7;
		this.destroyed = false;
	};
	(function (my) {
		var proto = my.prototype;
		able.make_proto_listenable(proto);

		proto.is_running = function () {
			return this.running_event_queue === false;
		};
		proto.clear = function() {
			this.queue.splice(0, this.queue.length);
		};

		proto.run_event_queue = function () {
			var i;
			if (this.running_event_queue === false) {
				this.running_event_queue = true;
				this._emit("begin_event_queue", {
					type: "begin_event_queue",
					target: this
				});
				this.do_run_event_queue();
				for (i = 0; i <= this.num_post_event_queue_rounds; i += 1) {
					this.end_queue_round = i;
					var event_type = "end_event_queue_round_" + i;
					this._emit(event_type, {
						type: event_type,
						target: this,
						round: i
					});
				}
				this.end_queue_round = false;
				this.running_event_queue = false;

				if(this.deferred_req) {
					this.deferred_req = false;
					this.run_event_queue();
				}
			} else {
				this.deferred_req = true;
			}
		};

		proto.push = function (context, args) {
			this.queue.push({
				context: context,
				args: args
			});
		};

		proto.do_run_event_queue = function () {
			var fire = ist.Event.prototype._fire;
			while (this.queue.length > 0) {
				var event_info = this.queue.shift();
				fire.apply(event_info.context, event_info.args);
			}
		};
	}(EventQueue));

	ist.event_queue = new EventQueue();

	var id = 0;
	ist.Event = function () {
		able.make_this_listenable(this);
		//this._initialize();
		this.actual_firetime_listeners = [];
		this.requested_firetime_listeners = [];
		this._transition = undefined;
		this._enabled = false;
		this._id = id++;
		this.on_create.apply(this, arguments);
		this._initialized = false;
		//if(this._id === 342) debugger;
	};

	(function (my) {
		var proto = my.prototype;
		able.make_proto_listenable(proto);
		proto.id = function() {
			return this._id;
		};
		proto.initialize = function () {
			this._initialized = true;
			/*
			if(this.is_active()) {
				this.enable_outgoing_transitions();
			}
				/*

				if(from.is_active()) {
					transition.enable();
				} else {
					transition.disable();
				}
				*/
		};
		proto.id = function () { return this._id; };
		proto.sid = function() { return parseInt(uid.strip_prefix(this.id()), 10); };
		proto.on_create = function (options) {
			this._enabled = options && options.enabled;
		};
		proto.on_ready = function() {};
		proto.fire = function () {
			var args = _.toArray(arguments);

			ist.event_queue.push(this, args);
			_.forEach(this.requested_firetime_listeners, function (listener) {
				listener.callback.apply(listener.context || this, listener.args.concat(args));
			}, this);
			
			if (ist.event_queue.is_ready()) {
				ist.event_queue.run_event_queue();
			}
		};
		proto.on_fire_request = function(callback, context) {
			var args = _.rest(arguments, 2);
			this.requested_firetime_listeners.push({callback: callback, context: context, args: args});
		};
		proto.off_fire_request = function (callback, context) {
			for(var i = 0; i<this.requested_firetime_listeners.length; i++) {
				var listener = this.requested_firetime_listeners[i];
				if(listener.callback === callback && (!context || listener.context === context)) {
					this.requested_firetime_listeners.splice(i, 1);
					i--;
				}
			}
		};
		proto.on_fire = proto.add_listener = function (callback, context) {
			var args = _.rest(arguments, 2);
			this.actual_firetime_listeners.push({callback: callback, context: context, args: args});
		};
		proto.off_fire = proto.remove_listener = function (callback, context) {
			for(var i = 0; i<this.actual_firetime_listeners.length; i++) {
				var listener = this.actual_firetime_listeners[i];
				if(listener.callback === callback && (!context || listener.context === context)) {
					this.actual_firetime_listeners.splice(i, 1);
					i--;
				}
			}
		};
		proto.set_transition = function (transition) { this._transition = transition; };
		proto.get_transition = function () { return this._transition; };
		proto._fire = function () {
			var args = _.toArray(arguments);
			_.forEach(this.actual_firetime_listeners, function (listener) {
				listener.callback.apply(listener.context || this, listener.args.concat(args));
			}, this);
		};
		proto.guard = proto.when = function (func) {
			var new_event = new ist.Event();
			this.on_fire(function () {
				if (func.apply(this, arguments)) {
					new_event.fire.apply(new_event, arguments);
				}
			});
			return new_event;
		};
		proto.when_eq = function (prop, val) {
			return this.guard(function (event) {
				return event && event[prop] === val;
			});
		};
		proto.throttle = function(limit) {
			if(!_.isNumber(limit) || limit < 0) {
				limit = 50;
			}
			var timeout = false;
			var last_args;
			var new_event = new ist.Event();
			this.on_fire(function () {
				last_args = arguments;
				if(!timeout) {
					timeout = true;
					window.setTimeout(function() {
						timeout = false;
						new_event.fire.apply(new_event, _.toArray(last_args));
					}, limit);
				}
			});
			var old_enable = new_event.enable,
				old_disable = new_event.disable,
				old_destroy = new_event.destroy;

			new_event.enable = _.bind(function() {
				old_enable.apply(new_event, arguments);
				this.enable();
			}, this);
			new_event.disable = _.bind(function() {
				old_disable.apply(new_event, arguments);
				this.disable();
			}, this);
			new_event.destroy = _.bind(function() {
				old_destroy.apply(new_event, arguments);
				this.destroy();
				delete new_event.enable;
				delete new_event.disable;
				delete new_event.destroy;
			}, this);
			return new_event;
		};
		proto.preventDefault = function() {
			this.on_fire_request(function(event) {
				if(event.preventDefault) {
					event.preventDefault();
				}
			});
			return this;
		};
		proto.stopPropagation = function() {
			this.on_fire_request(function(event) {
				if(event.stopPropagation) {
					event.stopPropagation();
				}
			});
			return this;
		};
		proto.destroy = function () {
			this.destroyed = true;
			this._emit("destroy");
			delete this.actual_firetime_listeners;
			delete this.requested_firetime_listeners;
			delete this._transition;
			delete this._enabled;
			able.destroy_this_listenable(this);
		};
		proto.create_shadow = function () { return new ist.Event(); };
		proto.stringify = function () {
			return "";
		};
		proto.type = function () {
			return this._type;
		};
		proto.enable = function () {
			this._enabled = true;
		};
		proto.disable = function () {
			this._enabled = false;
		};
		proto.is_enabled = function () {
			return this._enabled;
		};
	}(ist.Event));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,window,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var requestAnimFrame = (function(){
		return	window.requestAnimationFrame		||
				window.webkitRequestAnimationFrame	||
				window.mozRequestAnimationFrame		||
		function(callback) {
			window.setTimeout(callback, 1000/60);
		};
	})();

	ist.requestAnimationFrame = requestAnimFrame;

	ist.FrameEvent = function () {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "frame_event";
	};
	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.on_create = function () {
			this.created_at = (new Date()).getTime();
		};
		proto.set_transition = function (transition) {
			this._transition = transition;
			if (transition) {
				var from = transition.from();
				from.on("active", this.enter_listener, this);
				from.on("inactive", this.leave_listener, this);

				//_.defer(function (self) {
				if (from.is_active()) {
					this.enter_listener();
				}
				//}, this);
			}
		};
		proto.notify = function () {
			//ist.event_queue.wait();
			this.fire({
				type: "frame",
				current_time: (new Date()).getTime(),
				created_at: this.created_at
			});
			//ist.event_queue.signal();
		};

		proto.enter_listener = function() {
			if (this.req) {
				window.cancelAnimationFrame(this.req);
				this.req = undefined;
			}
			this.req = requestAnimFrame(_.bind(this.notify, this));
		};

		proto.leave_listener = function() {
			if (this.req) {
				window.cancelAnimationFrame(this.req);
				this.req = undefined;
			}
		};

		proto.destroy = function () {
			My.superclass.destroy.apply(this, arguments);
		};
		proto.enable = function () {
			My.superclass.enable.apply(this, arguments);
			this.enter_listener();
		};
		proto.disable = function () {
			My.superclass.disable.apply(this, arguments);
			if (this.req) {
				window.cancelAnimationFrame(this.req);
				this.req = undefined;
			}
		};
	}(ist.FrameEvent));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,window */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;


	ist.CollisionEvent = function (targa, targb) {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "collision";
	};

	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.on_create = function (targa, targb) {
			var old_targa = [],
				old_targb = [],
				$notify = _.bind(this.notify, this);

			this.live_fn = cjs.liven(function () {
				var new_targa, new_targb;

				if(targa instanceof ist.ContextualDict && targb instanceof ist.ContextualDict) {
					if(targa.is_template()) {
						new_targa = targa.instances();
					} else {
						new_targa = [targa];
					}

					if(targb.is_template()) {
						new_targb = targb.instances();
					} else {
						new_targb = [targb];
					}
				} else {
					new_targa = new_targb = [];
				}

				_.each(old_targa, function(ta) {
					var clisteners = ist.contact_listeners.get(ta),
						len = clisteners.length,
						cli, i;
					_.each(old_targb, function(tb) {
						for(i = 0; i<len; i++) {
							cli = clisteners[i];
							if(cli.target === tb) {
								if(len === 1) {
									ist.contact_listeners.remove(targa);
								} else {
									clisteners.splice(i, 1);
								}
								len--;
								break;
							}
						}
					}, this);
				}, this);

				_.each(new_targa, function(ta) {
					var clisteners = ist.contact_listeners.get_or_put(ta, function() {
						return [];
					});

					clisteners.push.apply(clisteners, _.map(new_targb, function(tb) {
						return {target: tb, callback: $notify};
					}, this));

				}, this);

				old_targa = new_targa;
				old_targb = new_targb;
			}, {
				context: this,
				//run_on_create: false
			});
		};
		proto.set_transition = function (transition) {
			this._transition = transition;
			if (transition) {
				var from = transition.from();

				from.on("active", this.enter_listener, this);
				from.on("inactive", this.leave_listener, this);
			}
		};
		proto.enter_listener = function() {
		};
		proto.leave_listener = function() {
		};
		proto.notify = function (contact) {
			//ist.event_queue.wait();
			this.fire({
				type: "collision"
			});
			//ist.event_queue.signal();
		};
		proto.destroy = function () {
			if(this._transition) {
			}
			My.superclass.destroy.apply(this, arguments);
		};

		proto.enable = function () {
			My.superclass.enable.apply(this, arguments);
		};
		proto.disable = function () {
			My.superclass.disable.apply(this, arguments);
		};
	}(ist.CollisionEvent));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,RedMap,window */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;
		
	var listener_map = new RedMap({
		equals: ist.check_contextual_object_equality,
		hash: function(obj) {
			if(obj.hash) {
				return obj.hash();
			} else {
				return obj.toString();
			}
		}
	});

	ist.emit = function (type, target) {
		target = target || window;
		var target_listeners = listener_map.get(target);
		if (target_listeners) {
			var listeners = target_listeners[type];
			if(listeners && listeners.length > 0) {
				var args = _.rest(arguments, 2);
				if(args.length === 0) { // no event object
					args = [{
						target: target,
						timestamp: (new Date()).getTime()
					}];
				}
				ist.event_queue.wait();
				_.each(listeners, function (listener) {
					listener.fire.apply(listener, args);
				});
				ist.event_queue.signal();
			}
		}
	};
	ist.register_serializable_type("ist_emit_func",
		function (x) {
			return x === ist.emit;
		},
		function () {
			return {};
		},
		function (obj) {
			return ist.emit;
		});

	ist.IstObjEvent = function() {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "ist_obj_event";
	};

	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.on_create = function (specified_type, specified_targets) {
			this.specified_type = specified_type;
			this.specified_targets = specified_targets;
			this.targets = [];

			this.live_fn = cjs.liven(function () {
				var type = cjs.get(this.specified_type);
				var st = cjs.get(this.specified_targets);
				if(!_.isArray(st)) {
					st = [st];
				}
				
				var targets = _	.chain(st)
								.map(function(target) {
									if(target instanceof ist.Query) {
										return target.value();
									} else {
										return target;
									}
								})
								.flatten(true)
								.map(function(cobj) {
									if(cobj instanceof ist.ContextualDict) {
										if(cobj.is_template()) {
											return cobj.instances();
										} else {
											return cobj;
										}
									} else if(cobj === window) {
										return cobj;
									} else {
										return false;
									}
								})
								.flatten(true)
								.compact()
								.map(function(target) {
									return {
										cobj: target,
										type: type
									};
								})
								.value();

				var diff = _.diff(this.targets, targets, function(a, b) {
					return a.cobj === b.cobj && a.type === b.type;
				});

				_.each(diff.removed, function(x) { this.remove_listener(x.from_item); }, this);
				_.each(diff.added, function(x) { this.add_listener(x.item); }, this);

				this.targets = targets;
			}, {
				context: this,
				run_on_create: false
			});

			if(this.is_enabled()) {
				this.live_fn.run(false);
			} else {
				this.live_fn.pause();
			}
			/*
			if (!_.isArray(targets)) {
				targets = [targets];
			}
			this.targets = _.chain(targets)
			this.add_listeners();
			*/
		};

		proto.add_listeners = function () {
			_.each(this.targets, this.add_listener, this);
		};
		proto.add_listener = function(target_info) {
			var target = target_info.cobj,
				type = target_info.type;

			if(target instanceof ist.ContextualObject) {
				target.on("begin_destroy", this.remove_listener, this, target_info);
			}
			var must_add = true;
			var target_listeners = listener_map.get_or_put(target, function () {
				must_add = false;
				var event_types = {};
				event_types[type] = [this];
				return event_types;
			}, this);

			if (must_add) {
				var type_listeners = target_listeners[type];
				if (type_listeners) {
					type_listeners.push(this);
				} else {
					target_listeners[type] = [this];
				}
			}
		};
		proto.remove_listener = function(target_info) {
			var target = target_info.cobj,
				type = target_info.type;

			var target_listeners = listener_map.get(target);
			if(target_listeners) {
				var listeners = target_listeners[type];
				if (_.isArray(listeners)) {
					var listener_index = _.indexOf(listeners, this);
					if(listener_index >= 0) {
						listeners.splice(listener_index, 1);
						if(target instanceof ist.ContextualObject) {
							target.off("begin_destroy", this.remove_listener, this);
						}
						var len = listeners.length;
						if (len === 0) {
							delete target_listeners[type];
							if (_.size(target_listeners) === 0) {
								listener_map.remove(target);
							}
						}
					}
				}
			}
		};

		proto.remove_listeners = function () {
			_.each(this.targets, this.remove_listener, this);
			this.targets = [];
		};

		proto.create_shadow = function (parent_statechart, context) {
			var shadow = new My();
			this.on_fire(function () {
				//ist.event_queue.wait();
				shadow.fire();
				//ist.event_queue.signal();
			});
			return shadow;
		};
		proto.destroy = function () {
			//listener_map.clear();
			this.live_fn.destroy(true);
			this.remove_listeners();
			delete this.targets;
			My.superclass.destroy.apply(this, arguments);
		};

		proto.enable = function () {
			if(!this.is_enabled()) {
				//this.add_listeners();
				if(this.live_fn.resume()) {
					this.live_fn.run();
				}
			}

			My.superclass.enable.apply(this, arguments);
		};
		proto.disable = function () {
			if(this.is_enabled()) {
				this.live_fn.pause();
				this.live_fn.invalidate();
				this.remove_listeners();
			}

			My.superclass.disable.apply(this, arguments);
		};
	}(ist.IstObjEvent));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.ManualEvent = function () {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "manual_event";
	};

	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.create_shadow = function (parent_statechart, context) {
			var shadow = new My();
			this.on_fire(function () {
				//ist.event_queue.wait();
				shadow.fire();
				//ist.event_queue.signal();
			});
			return shadow;
		};
		proto.destroy = function () {
			My.superclass.destroy.apply(this, arguments);
		};
	}(ist.ManualEvent));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,window */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.DOMEvent = function () {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "dom_event";
	};

	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.on_create = function (specified_type, specified_targets) {
			this.get_target_listener = cjs.memoize(function (specified_target) {
				var self = this;
				var id = this._id;
				var listener = function (event) {
					ist.event_queue.wait();
				
					var new_event = _.extend({}, event, {
						ist_target: specified_target,
						preventDefault: event.preventDefault ? _.bind(event.preventDefault, event) : function(){},
						stopPropagation: event.stopPropagation ? _.bind(event.stopPropagation, event) : function(){},
						stopImmediatePropagation: event.stopImmediatePropagation ? _.bind(event.stopImmediatePropagation, event) : function(){}
					});

					self.fire(new_event);

					_.defer(function () {
						ist.event_queue.signal();
					});
				};
				listener.destroy = function() {
					self = null;
					delete listener.destroy;
				};
				return listener;
			}, {
				context: this,
				hash: function(args) {
					return _.map(args, function(x) {
						if(x instanceof ist.ContextualObject) {
							return x.hash();
						} else {
							return x+"";
						}
					}).join("");
				}
			});

			this.specified_targets = specified_targets;
			this.specified_type = specified_type;
			this.targets = [];

			this.live_fn = cjs.liven(function () {
				var type = cjs.get(this.specified_type);
				var targets = get_targets(cjs.get(this.specified_targets));
				_.each(targets, function(target) { target.type = type; });

				var diff = _.diff(this.targets, targets, function(a, b) {
					return a.dom_obj === b.dom_obj && a.type === b.type;
				});

				//if(this.is_enabled()) {
				_.each(diff.removed, function(x) { this.remove_listener(x.from_item); }, this);
				_.each(diff.added, function(x) { this.add_listener(x.item); }, this);
				//}

				this.targets = targets;
			}, {
				context: this,
				run_on_create: false
			});
			//this.live_fn.run(false);
			//console.log(this.is_enabled());
			//debugger;
			if(this.is_enabled()) {
				this.run_live_fn_and_check_for_uninitialized_cobjs(false);
			} else {
				this.live_fn.pause();
			}
		};
		proto.run_live_fn_and_check_for_uninitialized_cobjs = function(add_deps) {
			var target_cobjs = get_target_cobjs(cjs.get(this.specified_targets)),
				uninitialized_target_cobjs = _.filter(target_cobjs, function(cobj) {
					return (cobj instanceof ist.ContextualDict) && !cobj.is_initialized();
				});

			if(uninitialized_target_cobjs.length > 0) {
				var on_initialized = _.bind(function(cobj) {
					if(uninitialized_target_cobjs.length === 0) {
						this.live_fn.run(add_deps);
						on_initialized = false;
					} else {
						var index = uninitialized_target_cobjs.indexOf(cobj);
						uninitialized_target_cobjs.splice(index, 1);
					}
				}, this);
				_.each(uninitialized_target_cobjs, function(cobj) {
					cobj.once("initialized", on_initialized);
				});
			} else {
				this.live_fn.run(add_deps);
			}
		};
		proto.clone = function () {
			return new My(this.type, this.targets);
		};
		proto.add_listeners = function () {
			_.each(this.targets, this.add_listener, this);
		};
		proto.add_listener = function(target_info) {
			var dom_obj = target_info.dom_obj,
				cobj = target_info.cobj;
			if(_.isString(target_info.type)) {
				_.each(target_info.type.split(","), function(type) {
					//if(_.has(dom_obj, 'addEventListener')) {
						dom_obj.addEventListener(type, this.get_target_listener(cobj), false); // Bubble
					//}
				}, this);
			}
		};
		proto.remove_listeners = function () {
			_.each(this.targets, this.remove_listener, this);
		};
		proto.remove_listener = function(target_info) {
			var dom_obj = target_info.dom_obj,
				cobj = target_info.cobj;
			if(_.isString(target_info.type)) {
				_.each(target_info.type.split(","), function(type) {
					//if(_.has(dom_obj, 'removeEventListener')) {
						dom_obj.removeEventListener(type, this.get_target_listener(cobj), false); // Bubble
					//}
				}, this);
			}
		};
		proto.destroy = function () {
			this.live_fn.destroy(true);
			delete this.live_fn;
			this.remove_listeners();
			var self = this;
			this.get_target_listener.each(function(target_listener) {
				target_listener.get().destroy();
			});
			this.get_target_listener.destroy(true);

			delete this.get_target_listener;
			delete this.targets;
			delete this.specified_targets;
			delete this.specified_type;
			My.superclass.destroy.apply(this, arguments);
		};

		proto.enable = function () {
			if(!this.is_enabled()) {
				this.add_listeners();
				if(this.live_fn.resume()) {
					this.run_live_fn_and_check_for_uninitialized_cobjs();
				}
			}
			My.superclass.enable.apply(this, arguments);
		};
		proto.disable = function () {
			if(this.is_enabled()) {
				this.live_fn.pause();
				this.remove_listeners();
			}
			My.superclass.disable.apply(this, arguments);
		};

		ist.get_instance_targs = function(instance) {
			var dom_objs = instance.get_dom_obj();
			if(dom_objs) {
				if(_.isArray(dom_objs)) {
					return _.map(dom_objs, function(dom_obj) {
						return {dom_obj: dom_obj, cobj: instance};
					});
				} else {
					return {dom_obj: dom_objs, cobj: instance};
				}
			} else {
				return false;
			}
		};

		function get_target_cobjs(targs) {
			if (!_.isArray(targs)) {
				targs = [targs];
			}

			var rv = _	.chain(targs)
						.map(function(targ) {
							if(targ instanceof ist.Query) {
								return targ.value();
							} else {
								return targ;
							}
						})
						.flatten(true)
						.value();
			return rv;
		}

		function get_dom_targets(target_cobjs) {
			var rv = _	.chain(target_cobjs)
						.map(function (target_cobj) {
							if (_.isElement(target_cobj) || target_cobj === window) {
								return {dom_obj: target_cobj, cobj: target_cobj};
							} else if (target_cobj instanceof ist.ContextualDict) {
								if (target_cobj.is_template()) {
									return _.chain(target_cobj.instances())
											.map(ist.get_instance_targs)
											.flatten(true)
											.value();
								} else {
									return ist.get_instance_targs(target_cobj);
								}
							}
							return false;
						})
						.flatten(true)
						.compact()
						.value();
			return rv;
		}

		function get_targets(targs) {
			return get_dom_targets(get_target_cobjs(targs));
		}
		/*

		ist.get_targets = function(targs) {
			if (!_.isArray(targs)) {
				targs = [targs];
			}

			var rv = _	.chain(targs)
						.map(function(targ) {
							if(targ instanceof ist.Query) {
								return targ.value();
							} else {
								return targ;
							}
						})
						.flatten(true)
						.map(function (target_cobj) {
							if (_.isElement(target_cobj) || target_cobj === window) {
								return {dom_obj: target_cobj, cobj: target_cobj};
							} else if (target_cobj instanceof ist.ContextualDict) {
								if(target_cobj.is_initialized()) {
									if (target_cobj.is_template()) {
										return _.chain(target_cobj.instances())
												.map(ist.get_instance_targs)
												.flatten(true)
												.value();
									} else {
										return ist.get_instance_targs(target_cobj);
									}
								} else {
									target_cobj.once("initialized", function() {
										this.live_fn.run();
									});
								}
							}
							return false;
						})
						.flatten(true)
						.compact()
						.value();
			return rv;
		};
		*/

	}(ist.DOMEvent));
	//var keyCodeToChar = {8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause/Break",20:"Caps Lock",27:"Esc",32:"Space",33:"Page Up",34:"Page Down",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",45:"Insert",46:"Delete",48:"0",49:"1",50:"2",51:"3",52:"4",53:"5",54:"6",55:"7",56:"8",57:"9",65:"A",66:"B",67:"C",68:"D",69:"E",70:"F",71:"G",72:"H",73:"I",74:"J",75:"K",76:"L",77:"M",78:"N",79:"O",80:"P",81:"Q",82:"R",83:"S",84:"T",85:"U",86:"V",87:"W",88:"X",89:"Y",90:"Z",91:"Windows",93:"Right Click",96:"Numpad 0",97:"Numpad 1",98:"Numpad 2",99:"Numpad 3",100:"Numpad 4",101:"Numpad 5",102:"Numpad 6",103:"Numpad 7",104:"Numpad 8",105:"Numpad 9",106:"Numpad *",107:"Numpad +",109:"Numpad -",110:"Numpad .",111:"Numpad /",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"Num Lock",145:"Scroll Lock",182:"My Computer",183:"My Calculator",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"};
	//var keyCharToCode = {"Backspace":8,"Tab":9,"Enter":13,"Shift":16,"Ctrl":17,"Alt":18,"Pause/Break":19,"Caps Lock":20,"Esc":27,"Space":32,"Page Up":33,"Page Down":34,"End":35,"Home":36,"Left":37,"Up":38,"Right":39,"Down":40,"Insert":45,"Delete":46,"0":48,"1":49,"2":50,"3":51,"4":52,"5":53,"6":54,"7":55,"8":56,"9":57,"A":65,"B":66,"C":67,"D":68,"E":69,"F":70,"G":71,"H":72,"I":73,"J":74,"K":75,"L":76,"M":77,"N":78,"O":79,"P":80,"Q":81,"R":82,"S":83,"T":84,"U":85,"V":86,"W":87,"X":88,"Y":89,"Z":90,"Windows":91,"Right Click":93,"Numpad 0":96,"Numpad 1":97,"Numpad 2":98,"Numpad 3":99,"Numpad 4":100,"Numpad 5":101,"Numpad 6":102,"Numpad 7":103,"Numpad 8":104,"Numpad 9":105,"Numpad *":106,"Numpad +":107,"Numpad -":109,"Numpad .":110,"Numpad /":111,"F1":112,"F2":113,"F3":114,"F4":115,"F5":116,"F6":117,"F7":118,"F8":119,"F9":120,"F10":121,"F11":122,"F12":123,"Num Lock":144,"Scroll Lock":145,"My Computer":182,"My Calculator":183,";":186,"=":187,",":188,"-":189,".":190,"/":191,"`":192,"[":219,"\\":220,"]":221,"'":222};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,window */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.TimeEvent = function () {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "time";
	};

	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.on_create = function (time) {
			this.time = time;
			var creation_time = (new Date()).getTime();
			var time_diff = this.time - creation_time;
			var self = this;
			window.setTimeout(function () {
				self.fire({
					type: "time",
					time: time,
					current_time: (new Date()).getTime(),
					created_at: creation_time
				});
			}, time_diff);
		};
		proto.destroy = function () {
			My.superclass.destroy.apply(this, arguments);
		};
	}(ist.TimeEvent));

	ist.TimeoutEvent = function () {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "timeout";
		this.timeout = undefined;
	};

	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.on_create = function (delay) {
			this.delay = delay;
			this.created_at = (new Date()).getTime();
		};
		proto.set_transition = function (transition) {
			this._transition = transition;
			if (transition) {
				var from = transition.from();

				from.on("active", this.enter_listener, this);
				from.on("inactive", this.leave_listener, this);

				//_.defer(function (self) {
				if (from.is_active()) {
					this.enter_listener();
				}
				//}, this);
			}
		};
		proto.enter_listener = function() {
			if (this.timeout) {
				window.clearTimeout(this.timeout);
				this.timeout = undefined;
			}
			this.timeout = _.delay(function(self) { self.notify(); }, this.delay, this);
		};
		proto.leave_listener = function() {
			if (this.timeout) {
				window.clearTimeout(this.timeout);
				this.timeout = undefined;
			}
		};
		proto.notify = function () {
			//ist.event_queue.wait();
			this.fire({
				type: "timeout",
				delay: this.delay,
				current_time: (new Date()).getTime(),
				created_at: this.created_at
			});
			//ist.event_queue.signal();
		};
		proto.destroy = function () {
			if(this._transition) {
			/*
				var from = this._transition.from();
				from.off("active", this.enter_listener, this);
				from.off("inactive", this.leave_listener, this);
				*/
			}
			My.superclass.destroy.apply(this, arguments);
		};

		proto.enable = function () {
			My.superclass.enable.apply(this, arguments);
		};
		proto.disable = function () {
			My.superclass.disable.apply(this, arguments);
		};
	}(ist.TimeoutEvent));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.TransitionEvent = function () {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "statechart_event";
	};

	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.on_create = function (targets, spec) {
			this.targets = targets;
			this.spec = spec;
			this.get_activation_listener = cjs.memoize(function (specified_target) {
				var listener = function (event) {
					//ist.event_queue.wait();
					this.fire(event);
					//ist.event_queue.signal();
				};
				return listener;
			});
			this.get_deactivation_listener = cjs.memoize(function (specified_target) {
				var listener = function (event) { };
				return listener;
			});

			this.live_fn = cjs.liven(function () {
				this.remove_listeners();
				var old_spec;
				this.spec = cjs.get(this.spec);
				if(old_spec && old_spec.destroy) {
					old_spec.destroy();
				}
				var targs = cjs.get(this.targets);
				if (!_.isArray(targs)) {
					targs = [targs];
				}

				if(_.isString(this.spec)) {
					this.processed_targets = _.chain(targs)
						.map(function (target_pointer) {
							var statecharts;
							if (target_pointer instanceof ist.ContextualStatefulObj) {
								if (target_pointer.is_template()) {
									var instances = target_pointer.instances();
									statecharts = _.map(instances, function (instance) {
										var scs = instance.get_statecharts();
										return scs;
									});
									return _.flatten(statecharts, true);
								} else {
									statecharts = target_pointer.get_statecharts();
									return statecharts;
								}
							}
							return false;
						})
						.flatten(true)
						.compact()
						.value();
				} else {
					this.processed_targets = [];
				}
				if (this.is_enabled()) {
					this.add_listeners();
				}
			}, {
				context: this
			});
		};
		proto.destroy = function () {
			this.live_fn.destroy(true);
			delete this.live_fn;
			this.remove_listeners();
			if(this.spec && this.spec.destroy) {
				this.spec.destroy(true);
			}
			delete this.spec;
			if(this.targets && this.targets.destroy) {
				this.targets.destroy(true);
			}
			delete this.target;
			this.get_activation_listener.destroy(true);
			this.get_deactivation_listener.destroy(true);
			delete this.get_activation_listener;
			delete this.get_deactivation_listener;
			My.superclass.destroy.apply(this, arguments);
		};
		proto.add_listeners = function () {
			_.each(this.processed_targets, function (target) {
				target.on_transition(this.spec, this.get_activation_listener(target), this.get_deactivation_listener(target), this);
			}, this);
		};
		proto.remove_listeners = function () {
			_.each(this.processed_targets, function (target) {
				if(!target.destroyed) {
					target.off_transition(this.spec, this.get_activation_listener(target), this.get_deactivation_listener(target), this);
				}
			}, this);
		};
		proto.stringify = function () { return this.statecharts[0].id() + ":" + this._spec; };
		ist.register_serializable_type("transition_event",
			function (x) {
				return x instanceof My;
			},
			function () {
				var args = _.toArray(arguments);
				return {
					targets: ist.serialize.apply(ist, ([this.targets]).concat(args)),
					spec: this.spec
				};
			},
			function (obj) {
				var rest_args = _.rest(arguments);
				return new My(ist.deserialize.apply(ist, ([obj.targets]).concat(rest_args)), obj.spec);
			});
		proto.enable = function () {
			My.superclass.enable.apply(this, arguments);
			this.add_listeners();
		};
		proto.disable = function () {
			My.superclass.disable.apply(this, arguments);
			this.remove_listeners();
		};
	}(ist.TransitionEvent));

	ist.StatechartEvent = function () {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "statechart_event";
	};

	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.on_create = function (options) {
			this._id = uid();
			ist.register_uid(this._id, this);

			this.options = options;

			this.specified_target = options.target;
			this.spec = options.spec;
			if (!_.isString(this.specified_target)) {
				this.set_target(this.specified_target);
			}
			// will figure out when our transition is set
		};
		proto.on_spec = function() {
			//ist.event_queue.wait();
			this.fire.apply(this, arguments);
			//ist.event_queue.signal();
		};

		proto.set_transition = function (transition) {
			var from;
			My.superclass.set_transition.apply(this, arguments);
			if (_.isString(this.specified_target)) {
				if (this.specified_target === "parent") {
					transition = this.get_transition();
					if (transition) {
						from = transition.from();
						this.set_target(from.parent());
					}
				} else if (this.specified_target === "me") {
					transition = this.get_transition();
					if (transition) {
						from = transition.from();
						this.set_target(from);
					}
				} else {
					console.error("Unknown target " + this.specified_target);
				}
			}
		};
		proto.id = function () { return this._id; };
		proto.set_target = function (target) {
			if (this.target) {
				this.target.off(this.spec, this.on_spec, this);
			}
			this.target = target;
			if (this.options.inert !== true && this.is_enabled()) {
				this.target.on(this.spec, this.on_spec, this);
			}
		};
		proto.destroy = function () {
			My.superclass.destroy.apply(this, arguments);
			ist.unregister_uid(this.id());
			if (this.target) {
				this.target.off(this.spec, this.on_spec, this);
				delete this.target;
			}
		};
		proto.create_shadow = function (parent_statechart, context) {
			return new My({
				target: this.specified_target,
				spec: this.spec,
				inert: this.options.inert_shadows,
				inert_shadows: this.options.inert_shadows
			});
		};

		proto.enable = function () {
			if(!this.is_enabled()) {
				My.superclass.enable.apply(this, arguments);
				if (this.options.inert !== true) {
					if (this.target) {
						this.target.on(this.spec, this.on_spec, this);
					}
				}
			}
		};

		proto.disable = function () {
			if(this.is_enabled()) {
				My.superclass.disable.apply(this, arguments);
				if (this.target) {
					this.target.off(this.spec, this.on_spec, this);
				}
			}
		};

		proto.stringify = function () { return /*this.target.id() +*/ ":"/* + this.spec*/; };

		ist.register_serializable_type("statechart_event",
			function (x) {
				return x instanceof My;
			},
			function () {
				var target_summarized;
				if (_.isString(this.specified_target)) {
					target_summarized = this.specified_target;
				} else {
					target_summarized = this.specified_target.summarize();
				}

				return {
					specified_target: target_summarized,
					spec: this.spec
				};
			},
			function (obj) {
				var target;
				if (_.isString(obj.specified_target)) {
					target = obj.specified_target;
				} else {
					target = ist.State.desummarize(obj.specified_target);
				}
				var spec = obj.spec;
				return new My({
					target: target,
					spec: spec
				});
			});
	}(ist.StatechartEvent));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

var UNDEF = {};

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.ConstraintEvent = function () {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "constraint_event";
	};

	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.on_create = function (constraint, last_val) {
			this.constraint = constraint;
			//this._last_val = last_val;
			this._last_val = UNDEF;
		};

		proto.set_transition = function (transition) {
			this._transition = transition;
			if (transition) {
				var from = transition.from();

				from.on("active", this.enter_listener, this);
				from.on("inactive", this.leave_listener, this);

				//_.defer(function (self) {
				if (from.is_active()) {
					this.enter_listener();
				}
				//}, this);
			}
		};

		proto.check_constraint_val = function () {
			var val = cjs.get(this.constraint, false),
				last_val = this._last_val;

			this._last_val = val;

			if (val && (last_val !== val)) {
				//ist.event_queue.wait();
				this.fire({
					value: val,
					timestamp: (new Date()).getTime()
				});
				//ist.event_queue.signal();
			}
		};
		proto.destroy = function () {
			if(cjs.isConstraint(this.constraint)) {
				this.constraint.offChange(this.check_constraint_val, this);
				this.constraint.destroy(true);
			}
			delete this.constraint;
		};

		proto.enable = function () {
			My.superclass.enable.apply(this, arguments);
			if(cjs.isConstraint(this.constraint)) {
				this.constraint.onChange(this.check_constraint_val, this);
				//if (!this.constraint.is_valid()) {
					//this.check_constraint_val();
				//}
			}
			//} else {
				//this.check_constraint_val();
			//}
			this.check_constraint_val();
		};
		proto.disable = function () {
			My.superclass.disable.apply(this, arguments);
			if(cjs.isConstraint(this.constraint)) {
				this.constraint.offChange(this.check_constraint_val, this);
			}
		};
		proto.enter_listener = function() {
			this._last_val = UNDEF;
		};
		proto.leave_listener = function() {
		};
	}(ist.ConstraintEvent));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var get_event = function (tree, options, live_event_creator) {
		//debugger;
		var event_constraint = ist.get_parsed_$(tree, options);
		var got_event, actions;
		if(event_constraint instanceof ist.MultiExpression) {
			actions = event_constraint.rest();
			event_constraint = event_constraint.first();
		} else {
			actions = [];
		}
		//console.log("A");
		//debugger;
		got_event = cjs.get(event_constraint);
		//console.log("B");
		//var got_value = cjs.get(event_constraint, false);
		//console.log(got_value);
		if (got_event instanceof ist.Event) {
			//event_constraint.destroy(true);
			return {event: got_event, actions: actions};
		} else {
			if(cjs.isConstraint(event_constraint)) {
				cjs.removeDependency(event_constraint, live_event_creator._constraint);
			}
			var event = new ist.ConstraintEvent(event_constraint, got_event);
			return {event: event/*.throttle(10)*/, actions: actions};
		}
	};

	ist.ParsedEvent = function () {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "parsed_event";
		this._has_errors = false;
	};
	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.set_transition = function (transition) {
			My.superclass.set_transition.apply(this, arguments);
			if (this._old_event) {
				this._old_event.set_transition(this.get_transition());
			}
		};
		proto.initialize = function (options) {
			My.superclass.initialize.apply(this, arguments);

			if(this._live_event_creator) {
				if(this.is_enabled()) {
					this._live_event_creator.run(false);
				} else {
					this._live_event_creator.pause();
				}
			}
		};

		proto.on_create = function (options) {
			My.superclass.on_create.apply(this, arguments);
			this.$errors = new cjs.Constraint([]);
			this._id = uid();
			ist.register_uid(this._id, this);
			this.options = options;
			this._str = cjs.isConstraint(options.str) ? options.str : cjs(options.str);

			if (options.inert !== true) {
				var SOandC = ist.find_stateful_obj_and_context(options.context);

				var context;
				var parent;

				if (SOandC) {
					context = SOandC.context;
					parent = SOandC.stateful_obj;
				} else {
					context = options.context;
					parent = options.context.points_at();
				}

				this._tree = cjs(function () {
					return esprima.parse(this.get_str());
				}, {
					context: this
				});
				this._old_event = null;
				//cjs.wait(); // ensure our live event creator isn't immediately run
				this._live_event_creator = cjs.liven(function () {
					if (this._old_event) {
						this._old_event.off_fire(this.child_fired, this);
						this._old_event.destroy(true); //destroy silently (without nullifying)
					}

					var tree, event_info = false, event = false;
					cjs.wait();
					if(ist.__debug) {
						tree = this._tree.get();
						if(tree instanceof ist.Error) {
							//console.log("no event");
							event = null;
						} else {
							event_info = get_event(tree, {
								parent: parent,
								context: context,
								only_parse_first: true
							}, this._live_event_creator);
							event = event_info.event;
						}
						cjs.signal();
					} else {
						try {
							tree = this._tree.get();
							if(tree instanceof ist.Error) {
								//console.log("no event");
								event = null;
							} else {
								event_info = get_event(tree, {
									parent: parent,
									context: context,
									only_parse_first: true
								}, this._live_event_creator);
								event = event_info.event;
								if(this._has_errors) {
									this.$errors.set([]);
									this._has_errors = false;
								}
							}
						} catch(e) {
							var message = e.hasOwnProperty("message") ? e.message : e.description;
							this.$errors.set([message]);
							this._has_errors = true;
						} finally {
							cjs.signal();
						}
					}

					if (event) {

						event.set_transition(this.get_transition());
						event.on_fire(this.child_fired, this, event_info.actions, parent, context);
						if (this.is_enabled()) {
							event.enable();
						}
					}

					this._old_event = event;
				}, {
					context: this,
					run_on_create: false
				});
				/*
				//cjs.signal();
				_.delay(_.bind(function () {
					//Delay it because parsed events can run up the dictionary tree and create all sorts of contextual objects that they shouldn't
					//Delay it because if an event relies on an object's inherited property while the object is still being created, we're all fucked
					this.on_ready();
				}, this));
				*/
					//console.log(this);
			}
		};
		/*
		proto.on_ready = function() {
			if(this._live_event_creator && this.is_enabled()) {
				this._live_event_creator.run(false);
			}
		};
		*/
		proto.get_errors = function() {
			return this.$errors.get();
		};
		proto.child_fired = function (actions, parent, context, event) {
			this.fire.apply(this, _.rest(arguments, 3));
			
			if(actions.length > 0) {
				var eventified_context = context.push(new ist.ProvisionalContext(), new ist.EventContext(event));
				//console.log(eventified_context);
				_.each(actions, function(expression_tree) {
					if(ist.__debug) {
						ist.get_parsed_$(expression_tree, {
							parent: parent,
							context: eventified_context,
							get_constraint: false,
							auto_add_dependency: false
						});
					} else {
						try {
							//ist.dbg = true;
							ist.get_parsed_$(expression_tree, {
								parent: parent,
								context: eventified_context,
								get_constraint: false,
								auto_add_dependency: false
							});
							//ist.dbg = false;
						} catch(e) {
							console.error(e);
						}
					}
				/*
					if(expression.invalidate) {
						expression.invalidate();
					}
					cjs.get(expression, false);
					*/
				});
			}
		};
		proto.get_str = function () { return this._str.get(); };
		proto.set_str = function (str) {
			this._str.set(str);
			this._emit("setString", {
				to: str
			});
		};
		proto.create_shadow = function (parent_statechart, context, enabled) {
			var rv = new My({
				str: this.get_str(),
				context: context,
				inert_shadows: this.options.inert_shadows,
				inert: this.options.inert_shadows,
				enabled: enabled
			});
			this.on("setString", function (e) {
				rv.set_str(e.to);
			});
			return rv;
		};
		proto.destroy = function () {
			if (this._old_event) {
				this._old_event.off_fire(this.$child_fired);
				this._old_event.destroy();
				delete this._old_event;
			}
			if (this._live_event_creator) {
				this._live_event_creator.destroy(true);
				delete this._live_event_creator;
			}
			if(this._str) {
				this._str.destroy();
				delete this._str;
			}
			this.$errors.destroy(true);
			delete this.$errors;
			ist.unregister_uid(this.id());
			My.superclass.destroy.apply(this, arguments);
		};
		proto.clone = function () {
		};
		proto.stringify = function () {
			return this._str.get();
		};
		ist.register_serializable_type("parsed_event",
			function (x) {
				return x instanceof My;
			},
			function () {
				return {
					str: this.get_str(),
					inert: this.options.inert
				};
			},
			function (obj) {
				return new My({
					str: obj.str,
					inert: obj.inert
				});
			});
		proto.enable = function () {
			My.superclass.enable.apply(this, arguments);
			if (this._old_event) {
				this._old_event.enable();
			}
			if(this._live_event_creator && this._live_event_creator.resume()) {
				this._live_event_creator.run();
			}
		};
		proto.disable = function () {
			My.superclass.disable.apply(this, arguments);
			if (this._old_event) {
				this._old_event.disable();
			}
			if(this._live_event_creator) {
				this._live_event_creator.pause();
			}
		};
	}(ist.ParsedEvent));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.CombinationEvent = function () {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "combination_event";
	};

	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.on_create = function (events) {
			this.events = events;
			_.each(this.events, function (event) {
				event.parent = this;
				event.on_fire_request(_.bind(function () {
					this.fire.apply(this, arguments);
				}, this));
			}, this);
			My.superclass.on_create.apply(this, arguments);
		};

		proto.destroy = function () {
			var args = arguments;
			_.each(this.events, function (event) {
				event.destroy.apply(event, args);
			});
			delete this.events;
			My.superclass.destroy.apply(this, arguments);
		};

		proto.enable = function () {
			My.superclass.enable.apply(this, arguments);
			_.each(this.events, function (event) {
				event.enable();
			});
		};
		proto.disable = function () {
			My.superclass.disable.apply(this, arguments);
			_.each(this.events, function (event) {
				event.disable();
			});
		};
	}(ist.CombinationEvent));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,window,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.CrossEvent = function () {
		ist.Event.apply(this, arguments);
		//this._initialize();
		this._type = "cross";
	};

	(function (My) {
		_.proto_extend(My, ist.Event);
		var proto = My.prototype;
		proto.on_create = function (path, min_velocity) {
			this.path = path;
			this.min_velocity = min_velocity;

			this._curr_path = null;
			this._crossing_path_listener_id = false;

			this.live_fn = cjs.liven(function () {
				this.remove_listener();
				var min_velocity = cjs.get(this.min_velocity);
				if(!_.isNumber(min_velocity)) { min_velocity = 0; }
				this._min_velocity = min_velocity;
				this._curr_path = cjs.get(this.path);
				this.add_listener();
			}, {
				context: this,
				run_on_create: false
			});
			this.live_fn.run(false);
		};
		proto.remove_listener = function() {
			if(this._crossing_path_listener_id) {
				removeCrossingPathListener(this._crossing_path_listener_id);
				this._crossing_path_listener_id = false;
			}
		};
		proto.add_listener = function() {
			this._crossing_path_listener_id = addCrossingPathListener(this._curr_path, function(velocity) {
				if(velocity >= this._min_velocity) {
					ist.event_queue.wait();
					this.fire();
					_.defer(function() {
						ist.event_queue.signal();
					});
				}
			}, this);
		};
		proto.enable = function () {
			if(!this.is_enabled()) {
				if(this.live_fn.resume()) {
					this.add_listener();
					this.live_fn.run();
				}
			}
			My.superclass.enable.apply(this, arguments);
		};
		proto.disable = function () {
			if(this.is_enabled()) {
				this.live_fn.pause();
				this.remove_listener();
			}
			My.superclass.disable.apply(this, arguments);
		};
		proto.destroy = function () {
			My.superclass.destroy.apply(this, arguments);
			if(this._crossing_path_listener_id) {
				removeCrossingPathListener(this._crossing_path_listener_id);
			}
		};
	}(ist.CrossEvent));


	var lowerCase = String.prototype.toLowerCase,
		upperCase = String.prototype.toUpperCase,
		isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
		pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
		pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
		l2c = function (x1, y1, x2, y2) {
			return [x1, y1, x2, y2, x2, y2];
		},
		q2c = function (x1, y1, ax, ay, x2, y2) {
			var _13 = 1 / 3,
				_23 = 2 / 3;
			return [
					_13 * x1 + _23 * ax,
					_13 * y1 + _23 * ay,
					_13 * x2 + _23 * ax,
					_13 * y2 + _23 * ay,
					x2,
					y2
				];
		},
		base3 = function(t, p1, p2, p3, p4) {
			var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
				t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
			return t * t2 - 3 * p1 + 3 * p2;
		},
		bezlen = function(x1, y1, x2, y2, x3, y3, x4, y4, z) {
			if (z === undefined) {
				z = 1;
			}
			z = z > 1 ? 1 : z < 0 ? 0 : z;
			var z2 = z / 2,
				n = 12,
				Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],
				Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
				sum = 0;
			for (var i = 0; i < n; i++) {
				var ct = z2 * Tvalues[i] + z2,
					xbase = base3(ct, x1, x2, x3, x4),
					ybase = base3(ct, y1, y2, y3, y4),
					comb = xbase * xbase + ybase * ybase;
				sum += Cvalues[i] * Math.sqrt(comb);
			}
			return z2 * sum;
		},
		a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
			// for more information of where this math came from visit:
			// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
			var _120 = Math.PI * 120 / 180,
				rad = Math.PI / 180 * (+angle || 0),
				res = [],
				xy,
				rotate = cacher(function (x, y, rad) {
					var X = x * Math.cos(rad) - y * Math.sin(rad),
						Y = x * Math.sin(rad) + y * Math.cos(rad);
					return {x: X, y: Y};
				}), f1, f2, cx, cy;
			if (!recursive) {
				xy = rotate(x1, y1, -rad);
				x1 = xy.x;
				y1 = xy.y;
				xy = rotate(x2, y2, -rad);
				x2 = xy.x;
				y2 = xy.y;
				var cos = Math.cos(Math.PI / 180 * angle),
					sin = Math.sin(Math.PI / 180 * angle),
					x = (x1 - x2) / 2,
					y = (y1 - y2) / 2;
				var h = (x * x) / (rx * rx) +
							(y * y) / (ry * ry);
				if (h > 1) {
					h = Math.sqrt(h);
					rx = h * rx;
					ry = h * ry;
				}
				var rx2 = rx * rx,
					ry2 = ry * ry,
					k = (large_arc_flag == sweep_flag ? -1 : 1) *
						Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
				cx = k * rx * y/ry + 0.5*(x1 + x2);
				cy = k * -ry * x/rx + 0.5*(y1 + y2);
				f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
				f2 = Math.asin(((y2 - cy) / ry).toFixed(9));

				f1 = x1 < cx ? Math.PI - f1 : f1;
				f2 = x2 < cx ? Math.PI - f2 : f2;
				if(f1<0) {
					(f1 = Math.PI * 2 + f1);
				}
				if(f2<0) {
					(f2 = Math.PI * 2 + f2);
				}

				if (sweep_flag && f1 > f2) {
					f1 = f1 - Math.PI * 2;
				}
				if (!sweep_flag && f2 > f1) {
					f2 = f2 - Math.PI * 2;
				}
			} else {
				f1 = recursive[0];
				f2 = recursive[1];
				cx = recursive[2];
				cy = recursive[3];
			}
			var df = f2 - f1;
			if (Math.abs(df) > _120) {
				var f2old = f2,
					x2old = x2,
					y2old = y2;
				f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
				x2 = cx + rx * Math.cos(f2);
				y2 = cy + ry * Math.sin(f2);
				res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
			}
			df = f2 - f1;
			var c1 = Math.cos(f1),
				s1 = Math.sin(f1),
				c2 = Math.cos(f2),
				s2 = Math.sin(f2),
				t = Math.tan(df / 4),
				hx = 4 / 3 * rx * t,
				hy = 4 / 3 * ry * t,
				m1 = [x1, y1],
				m2 = [x1 + hx * s1, y1 - hy * c1],
				m3 = [x2 + hx * s2, y2 - hy * c2],
				m4 = [x2, y2];
			m2[0] = 2 * m1[0] - m2[0];
			m2[1] = 2 * m1[1] - m2[1];
			if (recursive) {
				return ([m2, m3, m4]).concat(res);
			} else {
				res = ([m2, m3, m4]).concat(res).join().split(",");
				var newres = [];
				for (var i = 0, ii = res.length; i < ii; i++) {
					newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
				}
				return newres;
			}
		},
		bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
			if (!r_is(p1x, "array")) {
				p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
			}
			var bbox = curveDim.apply(null, p1x);
			return {
				x: bbox.min.x,
				y: bbox.min.y,
				x2: bbox.max.x,
				y2: bbox.max.y,
				width: bbox.max.x - bbox.min.x,
				height: bbox.max.y - bbox.min.y
			};
		},
		isPointInsideBBox = function (bbox, x, y) {
			return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
		},
		isBBoxIntersect = function (bbox1, bbox2) {
			var i = isPointInsideBBox;
			return i(bbox2, bbox1.x, bbox1.y) ||
					i(bbox2, bbox1.x2, bbox1.y) ||
					i(bbox2, bbox1.x, bbox1.y2) ||
					i(bbox2, bbox1.x2, bbox1.y2) ||
					i(bbox1, bbox2.x, bbox2.y) ||
					i(bbox1, bbox2.x2, bbox2.y) ||
					i(bbox1, bbox2.x, bbox2.y2) ||
					i(bbox1, bbox2.x2, bbox2.y2) ||
					(bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) &&
					(bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
		},
		findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
			var t1 = 1 - t,
				t13 = Math.pow(t1, 3),
				t12 = Math.pow(t1, 2),
				t2 = t * t,
				t3 = t2 * t,
				x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
				y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
				mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
				my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
				nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
				ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
				ax = t1 * p1x + t * c1x,
				ay = t1 * p1y + t * c1y,
				cx = t1 * c2x + t * p2x,
				cy = t1 * c2y + t * p2y,
				alpha = (90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI);
			if(mx > nx || my < ny) { alpha += 180; }
			return {
				x: x,
				y: y,
				m: {x: mx, y: my},
				n: {x: nx, y: ny},
				start: {x: ax, y: ay},
				end: {x: cx, y: cy},
				alpha: alpha
			};
		},
		findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
			var t1 = 1 - t;
			return {
				x: Math.pow(t1, 3) * p1x + Math.pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + Math.pow(t, 3) * p2x,
				y: Math.pow(t1, 3) * p1y + Math.pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + Math.pow(t, 3) * p2y
			};
		},
		repush = function(array, item) {
			for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
				return array.push(array.splice(i, 1)[0]);
			}
		},
		cacher = function(f, scope, postprocessor) {
			function newf() {
				var arg = Array.prototype.slice.call(arguments, 0),
				args = arg.join("\u2400"),
				cache = newf.cache = newf.cache || {},
				count = newf.count = newf.count || [];
				if (cache.hasOwnProperty(args)) {
					repush(count, args);
					return postprocessor ? postprocessor(cache[args]) : cache[args];
				}
				if(count.length >= 1e3) { delete cache[count.shift()]; }
				count.push(args);
				cache[args] = f.apply(scope, arg);
				return postprocessor ? postprocessor(cache[args]) : cache[args];
			}
			return newf;
		},
		curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
			var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
				b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
				c = p1x - c1x,
				t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / 2 / a,
				t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / 2 / a,
				y = [p1y, p2y],
				x = [p1x, p2x],
				dot;
			if(Math.abs(t1) > "1e12") { t1 = 0.5; }
			if(Math.abs(t2) > "1e12") { t2 = 0.5; }
			if (t1 > 0 && t1 < 1) {
				dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
				x.push(dot.x);
				y.push(dot.y);
			}
			if (t2 > 0 && t2 < 1) {
				dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
				x.push(dot.x);
				y.push(dot.y);
			}
			a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
			b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
			c = p1y - c1y;
			t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / 2 / a;
			t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / 2 / a;
			if(Math.abs(t1) > "1e12") { t1 = 0.5; }
			if(Math.abs(t2) > "1e12") { t2 = 0.5; }
			if (t1 > 0 && t1 < 1) {
				dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
				x.push(dot.x);
				y.push(dot.y);
			}
			if (t2 > 0 && t2 < 1) {
				dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
				x.push(dot.x);
				y.push(dot.y);
			}
			return {
				min: {x: Math.min.apply(0, x), y: Math.min.apply(0, y)},
				max: {x: Math.max.apply(0, x), y: Math.max.apply(0, y)}
			};
		}),
		intersect = function(x1, y1, x2, y2, x3, y3, x4, y4) {
			if ( Math.max(x1, x2) < Math.min(x3, x4) ||
					Math.min(x1, x2) > Math.max(x3, x4) ||
					Math.max(y1, y2) < Math.min(y3, y4) ||
					Math.min(y1, y2) > Math.max(y3, y4)
					) {
				return;
			}
			var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
				ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
				denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

			if (!denominator) {
				return;
			}
			var px = nx / denominator,
			py = ny / denominator,
			px2 = +px.toFixed(2),
			py2 = +py.toFixed(2);
			if ( px2 < +Math.min(x1, x2).toFixed(2) ||
					px2 > +Math.max(x1, x2).toFixed(2) ||
					px2 < +Math.min(x3, x4).toFixed(2) ||
					px2 > +Math.max(x3, x4).toFixed(2) ||
					py2 < +Math.min(y1, y2).toFixed(2) ||
					py2 > +Math.max(y1, y2).toFixed(2) ||
					py2 < +Math.min(y3, y4).toFixed(2) ||
					py2 > +Math.max(y3, y4).toFixed(2)
					) {
				return;
			}
			return {x: px, y: py};
		},
		interHelper = function(bez1, bez2, justBool) {
			var bbox1 = bezierBBox(bez1),
				bbox2 = bezierBBox(bez2);
			if (!isBBoxIntersect(bbox1, bbox2)) {
				return justBool ? false : [];
			}
			var l1 = bezlen.apply(0, bez1),
				l2 = bezlen.apply(0, bez2),
				n1 = Math.max(~~(l1 / 5), 1),
				n2 = Math.max(~~(l2 / 5), 1),
				dots1 = [],
				dots2 = [],
				xy = {},
				res = justBool ? false : [],
				p;
			for (var i = 0; i < n1 + 1; i++) {
				p = findDotsAtSegment.apply(this, bez1.concat(i / n1));
				dots1.push({x: p.x, y: p.y, t: i / n1});
			}
			for (i = 0; i < n2 + 1; i++) {
				p = findDotsAtSegment.apply(this, bez2.concat(i / n2));
				dots2.push({x: p.x, y: p.y, t: i / n2});
			}
			for (i = 0; i < n1; i++) {
				for (var j = 0; j < n2; j++) {
					var di = dots1[i],
						di1 = dots1[i + 1],
						dj = dots2[j],
						dj1 = dots2[j + 1],
						ci = Math.abs(di1.x - di.x) < 0.001 ? "y" : "x",
						cj = Math.abs(dj1.x - dj.x) < 0.001 ? "y" : "x",
						is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
					if (is) {
						if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
							continue;
						}
						xy[is.x.toFixed(4)] = is.y.toFixed(4);
						var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
							t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
						if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
							if (justBool) {
								return true;
							} else {
								res.push({
									x: is.x,
									y: is.y,
									t1: Math.min(t1, 1),
									t2: Math.min(t2, 1)
								});
							}
						}
					}
				}
			}
			return res;
		},
		_path2string = function () {
			return this.join(",").replace(p2s, "$1");
		},
		clone = function(obj) {
			if (typeof obj == "function" || Object(obj) !== obj) {
				return obj;
			}
			var res = new obj.constructor();
			for (var key in obj) if (obj.hasOwnProperty(key)) {
				res[key] = clone(obj[key]);
			}
			return res;
		},
		pathClone = function (pathArray) {
			var res = clone(pathArray);
			res.toString = _path2string;
			return res;
		},
		paths = function (ps) {
			var p = paths.ps = paths.ps || {};
			if (p[ps]) {
				p[ps].sleep = 100;
			} else {
				p[ps] = {
					sleep: 100
				};
			}
			setTimeout(function () {
				for (var key in p) if (p.hasOwnProperty(key) && key != ps) {
					p[key].sleep--;
					if(!p[key].sleep) { delete p[key]; }
				}
			});
			return p[ps];
		},
		parsePathString = function (pathString) {
			if (!pathString) {
				return null;
			}
			var pth = paths(pathString);
			if (pth.arr) {
				return pathClone(pth.arr);
			}

			var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
				data = [];
			if (r_is(pathString, "array") && r_is(pathString[0], "array")) { // rough assumption
				data = pathClone(pathString);
			}
			if (!data.length) {
				String(pathString).replace(pathCommand, function (a, b, c) {
					var params = [],
						name = b.toLowerCase();
					c.replace(pathValues, function (a, b) {
						if(b) { params.push(+b); }
					});
					if (name == "m" && params.length > 2) {
						data.push(([b]).concat(params.splice(0, 2)));
						name = "l";
						b = b == "m" ? "l" : "L";
					}
					if (name == "r") {
						data.push(([b]).concat(params));
					} else while (params.length >= paramCounts[name]) {
						data.push(([b]).concat(params.splice(0, paramCounts[name])));
						if (!paramCounts[name]) {
							break;
						}
					}
				});
			}
			data.toString = _path2string;
			pth.arr = pathClone(data);
			return data;
		},
		r_is = function (o, type) {
			type = lowerCase.call(type);
			if (type == "finite") {
				return !isnan[has](+o);
			}
			if (type == "array") {
				return o instanceof Array;
			}
			return  (type == "null" && o === null) ||
					(type == typeof o && o !== null) ||
					(type == "object" && o === Object(o)) ||
					(type == "array" && Array.isArray && Array.isArray(o)) ||
					objectToString.call(o).slice(8, -1).toLowerCase() == type;
		},
		catmullRom2bezier = function(crp, z) {
			var d = [];
			for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
				var p = [
							{x: +crp[i - 2], y: +crp[i - 1]},
							{x: +crp[i],     y: +crp[i + 1]},
							{x: +crp[i + 2], y: +crp[i + 3]},
							{x: +crp[i + 4], y: +crp[i + 5]}
						];
				if (z) {
					if (!i) {
						p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
					} else if (iLen - 4 == i) {
						p[3] = {x: +crp[0], y: +crp[1]};
					} else if (iLen - 2 == i) {
						p[2] = {x: +crp[0], y: +crp[1]};
						p[3] = {x: +crp[2], y: +crp[3]};
					}
				} else {
					if (iLen - 4 == i) {
						p[3] = p[2];
					} else if (!i) {
						p[0] = {x: +crp[i], y: +crp[i + 1]};
					}
				}
				d.push(["C",
					(-p[0].x + 6 * p[1].x + p[2].x) / 6,
					(-p[0].y + 6 * p[1].y + p[2].y) / 6,
					(p[1].x + 6 * p[2].x - p[3].x) / 6,
					(p[1].y + 6*p[2].y - p[3].y) / 6,
					p[2].x,
					p[2].y
				]);
			}

			return d;
		},
		pathToAbsolute = function (pathArray) {
			var pth = paths(pathArray);
			if (pth.abs) {
				return pathClone(pth.abs);
			}
			if (!r_is(pathArray, "array") || !r_is(pathArray && pathArray[0], "array")) { // rough assumption
				pathArray = parsePathString(pathArray);
			}
			if (!pathArray || !pathArray.length) {
				return [["M", 0, 0]];
			}
			var res = [],
				x = 0,
				y = 0,
				mx = 0,
				my = 0,
				start = 0, dots;
			if (pathArray[0][0] == "M") {
				x = +pathArray[0][1];
				y = +pathArray[0][2];
				mx = x;
				my = y;
				start++;
				res[0] = ["M", x, y];
			}
			var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
			for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
				res.push(r = []);
				pa = pathArray[i];
				if (pa[0] != upperCase.call(pa[0])) {
					/* jshint -W086 */
					r[0] = upperCase.call(pa[0]);
					switch (r[0]) {
						case "A":
							r[1] = pa[1];
							r[2] = pa[2];
							r[3] = pa[3];
							r[4] = pa[4];
							r[5] = pa[5];
							r[6] = +(pa[6] + x);
							r[7] = +(pa[7] + y);
							break;
						case "V":
							r[1] = +pa[1] + y;
							break;
						case "H":
							r[1] = +pa[1] + x;
							break;
						case "R":
							dots = ([x, y]).concat(pa.slice(1));
							for (var j = 2, jj = dots.length; j < jj; j++) {
								dots[j] = +dots[j] + x;
								dots[++j] = +dots[j] + y;
							}
							res.pop();
							res = res.concat(catmullRom2bezier(dots, crz));
							break;
						case "M":
							mx = +pa[1] + x;
							my = +pa[2] + y;
						default:
							for (j = 1, jj = pa.length; j < jj; j++) {
								r[j] = +pa[j] + ((j % 2) ? x : y);
							}
					}
					/* jshint +W086 */
				} else if (pa[0] == "R") {
					dots = ([x, y]).concat(pa.slice(1));
					res.pop();
					res = res.concat(catmullRom2bezier(dots, crz));
					r = (["R"]).concat(pa.slice(-2));
				} else {
					for (var k = 0, kk = pa.length; k < kk; k++) {
						r[k] = pa[k];
					}
				}
				/* jshint -W086 */
				switch (r[0]) {
					case "Z":
						x = mx;
						y = my;
						break;
					case "H":
						x = r[1];
						break;
					case "V":
						y = r[1];
						break;
					case "M":
						mx = r[r.length - 2];
						my = r[r.length - 1];
					default:
						x = r[r.length - 2];
						y = r[r.length - 1];
				}
				/* jshint +W086 */
			}
			res.toString = _path2string;
			pth.abs = pathClone(res);
			return res;
		},
		_path2curve = cacher(function (path, path2) {
			var pth = !path2 && paths(path);
			if (!path2 && pth.curve) {
				return pathClone(pth.curve);
			}
			var p = pathToAbsolute(path),
				p2 = path2 && pathToAbsolute(path2),
				attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
				attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
				processPath = function (path, d, pcom) {
					var nx, ny;
					if (!path) {
						return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
					}
					if(!(path[0] in {T:1, Q:1})) {
						d.qx = d.qy = null;
					}
					switch (path[0]) {
						case "M":
							d.X = path[1];
							d.Y = path[2];
							break;
						case "A":
							path = (["C"]).concat(a2c.apply(0, ([d.x, d.y]).concat(path.slice(1))));
							break;
						case "S":
							if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
								nx = d.x * 2 - d.bx;          // And reflect the previous
								ny = d.y * 2 - d.by;          // command's control point relative to the current point.
							}
							else {                            // or some else or nothing
								nx = d.x;
								ny = d.y;
							}
							path = (["C", nx, ny]).concat(path.slice(1));
							break;
						case "T":
							if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
								d.qx = d.x * 2 - d.qx;        // And make a reflection similar
								d.qy = d.y * 2 - d.qy;        // to case "S".
							}
							else {                            // or something else or nothing
								d.qx = d.x;
								d.qy = d.y;
							}
							path = (["C"]).concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
							break;
						case "Q":
							d.qx = path[1];
							d.qy = path[2];
							path = (["C"]).concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
							break;
						case "L":
							path = (["C"]).concat(l2c(d.x, d.y, path[1], path[2]));
							break;
						case "H":
							path = (["C"]).concat(l2c(d.x, d.y, path[1], d.y));
							break;
						case "V":
							path = (["C"]).concat(l2c(d.x, d.y, d.x, path[1]));
							break;
						case "Z":
							path = (["C"]).concat(l2c(d.x, d.y, d.X, d.Y));
							break;
					}
					return path;
				},
				fixArc = function (pp, i) {
					if (pp[i].length > 7) {
						pp[i].shift();
						var pi = pp[i];
						while (pi.length) {
							pp.splice(i++, 0, (["C"]).concat(pi.splice(0, 6)));
						}
						pp.splice(i, 1);
						ii = Math.max(p.length, p2 && p2.length || 0);
					}
				},
				fixM = function (path1, path2, a1, a2, i) {
					if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
						path2.splice(i, 0, ["M", a2.x, a2.y]);
						a1.bx = 0;
						a1.by = 0;
						a1.x = path1[i][1];
						a1.y = path1[i][2];
						ii = Math.max(p.length, p2 && p2.length || 0);
					}
				};
			for (var i = 0, ii = Math.max(p.length, p2 && p2.length || 0); i < ii; i++) {
				p[i] = processPath(p[i], attrs);
				fixArc(p, i);
				if(p2) {
					p2[i] = processPath(p2[i], attrs2);
					fixArc(p2, i);
				}
				fixM(p, p2, attrs, attrs2, i);
				fixM(p2, p, attrs2, attrs, i);
				var seg = p[i],
					seg2 = p2 && p2[i],
					seglen = seg.length,
					seg2len = p2 && seg2.length;
				attrs.x = seg[seglen - 2];
				attrs.y = seg[seglen - 1];
				attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
				attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
				attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
				attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
				attrs2.x = p2 && seg2[seg2len - 2];
				attrs2.y = p2 && seg2[seg2len - 1];
			}
			if (!p2) {
				pth.curve = pathClone(p);
			}
			return p2 ? [p, p2] : p;
		}, null, pathClone),
		interPathHelper = function(path1, path2, justBool) {
			path1 = _path2curve(path1);
			//path2 = _path2curve(path2);
			var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
				res = justBool ? false : [];
			for (var i = 0, ii = path1.length; i < ii; i++) {
				var pi = path1[i];
				if (pi[0] == "M") {
					x1 = x1m = pi[1];
					y1 = y1m = pi[2];
				} else {
					if (pi[0] == "C") {
						bez1 = [x1, y1].concat(pi.slice(1));
						x1 = bez1[6];
						y1 = bez1[7];
					} else {
						bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
						x1 = x1m;
						y1 = y1m;
					}
					for (var j = 0, jj = path2.length; j < jj; j++) {
						var pj = path2[j];
						if (pj[0] == "M") {
							x2 = x2m = pj[1];
							y2 = y2m = pj[2];
						} else {
							if (pj[0] == "C") {
								bez2 = [x2, y2].concat(pj.slice(1));
								x2 = bez2[6];
								y2 = bez2[7];
							} else {
								bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
								x2 = x2m;
								y2 = y2m;
							}
							var intr = interHelper(bez1, bez2, justBool);
							if (justBool) {
								if(intr) {
									return true;
								}
							} else {
								for (var k = 0, kk = intr.length; k < kk; k++) {
									intr[k].segment1 = i;
									intr[k].segment2 = j;
									intr[k].bez1 = bez1;
									intr[k].bez2 = bez2;
								}
								res = res.concat(intr);
							}
						}
					}
				}
			}
			return res;
		};

	var touches, latest_touches, last_time,
		crossingPaths = [],
		pathCallbacks = [],
		set_touches = function(to_touches, type) {
			var fingerPath, x, y, tx, ty, j, cpLen = crossingPaths.length, i = 0,
				len = to_touches.length,
				time = (new Date()).getTime(),
				dt = time - last_time;
			last_time = time;
			if(touches && touches.length === to_touches.length) {
				outer: for(i; i<len; i++) {
					x = to_touches[i].x;
					y = to_touches[i].y;
					tx = touches[i].x;
					ty = touches[i].y;
					fingerPath = [["M", tx, ty],
									["C", tx, ty, x, y, x, y]];
					for(j = 0; j < cpLen; j++) {
						var inter = interPathHelper(crossingPaths[j], fingerPath, true);
						if(inter) {
							var dx = x - tx,
								dy = y - ty,
								d = Math.sqrt(Math.pow(dx, 2), Math.pow(dy, 2)),
								v = d / dt;
							var callback_info = pathCallbacks[j];
							callback_info.callback.call(callback_info.context || this, v);
							break outer;
						}
					}
				}
			}
			touches = clone(to_touches);
		},
		timeout_id = false,
		interval_listener = function() {
			timeout_id = false;
			var new_touches = _.map(latest_touches, function(t) {
				return {x: t.pageX, y: t.pageY};
			});
			set_touches(new_touches);
		},
		touchstart_listener = function(event) {
			latest_touches = event.touches;
			if(latest_touches.length === 1) {
				timeout_id = window.setTimeout(interval_listener, 30);
			}
			event.preventDefault();
		},
		touchmove_listener = function(event) {
			if(timeout_id === false) {
				timeout_id = window.setTimeout(interval_listener, 30);
			}
			latest_touches = event.touches;
			event.preventDefault();
		},
		touchend_listener = function(event) {
			latest_touches = event.touches;
			if(latest_touches.length === 0) {
				if(timeout_id) {
					window.clearTimeout(timeout_id);
					timeout_id = false;
				}
				latest_touches = event.touches;
				interval_listener();
			} else {
				latest_touches = event.touches;
				if(timeout_id === false) {
					timeout_id = window.setTimeout(interval_listener, 30);
				}
			}
			event.preventDefault();
		},
		addTouchListeners = function() {
			window.addEventListener("touchstart", touchstart_listener);
			window.addEventListener("touchmove", touchmove_listener);
			window.addEventListener("touchend", touchend_listener);
		},
		removeTouchListeners = function() {
			window.removeEventListener("touchstart", touchstart_listener);
			window.removeEventListener("touchmove", touchmove_listener);
			window.removeEventListener("touchend", touchend_listener);
		},
		crossing_path_listener_id = 1,
		addCrossingPathListener = function(path, callback, context) {
			var cpl_id = crossing_path_listener_id;
			crossing_path_listener_id+=1;
			crossingPaths.push(path);
			pathCallbacks.push({
				callback: callback,
				context: context,
				id: cpl_id
			});
			if(crossingPaths.length === 1) {
				addTouchListeners();
			}
			return cpl_id;
		},
		removeCrossingPathListener = function(path) {
			var i = 0, len = crossingPaths.length, cp, linfo;
			for(i; i<len; i++) {
				cp = crossingPaths[i];
				linfo = pathCallbacks[i];

				if(cp === path || linfo.id === path) {
					crossingPaths.splice(i, 1);
					pathCallbacks.splice(i, 1);
					len -= 1;
					if(len === 0) {
						removeTouchListeners();
					}
				}
			}
		};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;

    ist.AttachmentInstance = function (options) {
        this.options = options || {};
        this.contextual_object = this.options.contextual_object;
		this.creator = this.options.creator;
        this.type = "(generic)";
    };
    
    (function (My) {
        var proto = My.prototype;
        proto.destroy = function () {
			delete this.options;
			delete this.contextual_object;
			delete this.creator;
			delete this.type;
		};
        proto.get_type = function () {
            return this.type;
        };
        proto.get_contextual_object = function () {
            return this.contextual_object;
        };
		proto.get_creator = function() {
			return this.creator;
		};
        proto.hash = function () {
            return this._context.hash();
        };
    }(ist.AttachmentInstance));
    
    ist.Attachment = function (options) {
        options = options || {};
        if (options.multiple_allowed === true) {
            this._multiple_allowed = true;
        } else { this._multiple_allowed = false; }
        this._InstanceClass = options.instance_class || ist.AttachmentInstance;
        this.type = "(generic)";
        this.instance_options = options.instance_options || {};
    };
    (function (My) {
        var proto = My.prototype;
        proto.create_instance = function (contextual_object, owner) {
            var options = _.extend({
                contextual_object: contextual_object,
				owner: owner,
				creator: this
            }, this.instance_options);
            var instance = new this._InstanceClass(options);
            return instance;
        };
        proto.destroy_instance = function (instance) {
            instance.destroy();
        };
        proto.set_instance_context = function (instance, context) {
            instance.set_context(context);
        };
        proto.get_type = function () {
            return this.type;
        };
        proto.multiple_allowed = function () { return this._multiple_allowed; };
        proto.hash = function () {
            return this.type;
        };
		proto.do_destroy = function() {};
		proto.destroy = function() {
			delete this.type;
			delete this._multiple_allowed;
			delete this._InstanceClass;
			delete this.instance_options;
			this.do_destroy();
		};
    }(ist.Attachment));
	/*
    
    ist.define("attachment", function (options) {
        var attachment = new ist.Attachment(options);
        return attachment;
    });

*/
	ist.register_attachments = function(object_types) {
		var attachment_suffix = "_attachment";
		_.each(object_types, function(attachment_specs, attachment_name) {
			var AttachmentType = ist.register_attachment(attachment_name, attachment_specs);

			ist.define(attachment_name + attachment_suffix, function (options) {
				return new AttachmentType(options);
			});
		});
	};
	ist.register_attachment = function(attachment_name, attachment_specs) {
		var attachment_suffix = "_attachment";
		var id = 0;
		var InstanceType = function(options) {
			InstanceType.superclass.constructor.apply(this, arguments);

			this.type = attachment_name;
			//this.on_ready();
			this.id = id++;
		};
		(function(My) {
			_.proto_extend(My, ist.AttachmentInstance);
			var proto = My.prototype;
			proto.on_ready = function() {
				attachment_specs.ready.call(this);
				this._listeners = {};
				var contextual_object = this.get_contextual_object();
				_.each(attachment_specs.parameters, function(parameter_spec, parameter_name) {
					if(_.isFunction(parameter_spec)) {
						this._listeners[parameter_name] = cjs.liven(function() {
							parameter_spec.call(this, contextual_object);
						}, {
							context: this
						});
					} else if(parameter_spec.type === "list") {
						var add_fn = parameter_spec.add,
							remove_fn = parameter_spec.remove,
							move_fn = parameter_spec.move;
						var getter = parameter_spec.getter;
						var curr_val = [];

						this._listeners[parameter_name] = cjs.liven(function() {
							var desired_val = getter.call(this, contextual_object);
							var diff = _.diff(curr_val, desired_val);

							_.forEach(diff.removed, function (info) {
								var index = info.from, child = info.from_item;
								remove_fn.call(this, child, index);
							}, this);
							_.forEach(diff.added, function (info) {
								var index = info.to, child = info.item;
								add_fn.call(this, child, index);
							}, this);
							_.forEach(diff.moved, function (info) {
								var from_index = info.from, to_index = info.to, child = info.item;
								move_fn.call(this, child, from_index, to_index);
							}, this);

							curr_val = desired_val;
						}, {
							context: this
						});
					}
				}, this);
			};
			proto.on_pause = function() {
				_.each(this._listeners, function(listener) {
					listener.pause();
				});
			};
			proto.on_resume = function() {
				_.each(this._listeners, function(listener) {
					listener.resume();
				});
			};
			proto.destroy = function(silent) {
				_.each(attachment_specs.parameters, function(parameter_spec, parameter_name) {
					this._listeners[parameter_name].destroy(true);
				}, this);
				delete this._listeners;
				My.superclass.destroy.apply(this, arguments);

				if(attachment_specs.destroy) {
					attachment_specs.destroy.call(this, silent);
				}
			};
			_.each(attachment_specs.proto_props, function(proto_prop, proto_prop_name) {
				proto[proto_prop_name] = proto_prop;
			});
		}(InstanceType));

		var AttachmentType = function(options) {
			options = _.extend({
				instance_class: InstanceType
			}, options);
			AttachmentType.superclass.constructor.call(this, options);
			this.type = attachment_name;
		};
		(function(My) {
			_.proto_extend(My, ist.Attachment);
			var proto = My.prototype;
			if(attachment_specs.attachment_destroy) {
				proto.do_destroy = attachment_specs.attachment_destroy;
			}
			ist.register_serializable_type(attachment_name + attachment_suffix,
				function (x) {
					return x instanceof My;
				},
				function () {
					return {
						instance_options: ist.serialize(this.instance_options)
					};
				},
				function (obj) {
					return new My({
						instance_options: ist.deserialize(obj.instance_options)
					});
				});
		}(AttachmentType));

		return AttachmentType;
	};

	ist.get_attachment = function(obj, attachment_name) {
		var attachment = obj.get_attachment_instance(attachment_name);
		return attachment;
	};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,able,uid,console,jQuery,window */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	function isInDOMTree (node) {
		// If the farthest-back ancestor of our node has a "body"
		// property (that node would be the document itself), 
		// we assume it is in the page's DOM tree.
		return !!(findUltimateAncestor(node).body);
	}
	function findUltimateAncestor (node) {
		// Walk up the DOM tree until we are at the top (parentNode 
		// will return null at that point).
		// NOTE: this will return the same node that was passed in 
		// if it has no ancestors.
		var ancestor = node;
		while (ancestor.parentNode) {
			ancestor = ancestor.parentNode;
		}
		return ancestor;
	}

	var insert_at = function (child_node, parent_node, index) {
		var children = parent_node.childNodes;
		if (children.length <= index) {
		try{
			parent_node.appendChild(child_node);
			}catch(e){}
		} else {
			var before_child = children[index];
			parent_node.insertBefore(child_node, before_child);
		}
	};
	var remove = function (child_node) {
		var parent_node = child_node.parentNode;
		if (parent_node) {
			parent_node.removeChild(child_node);
		}
	};
	var move = function (child_node, from_index, to_index) {
		var parent_node = child_node.parentNode;
		if (parent_node) {
			if (from_index < to_index) { //If it's less than the index we're inserting at...
				to_index += 1; //Increase the index by 1, to make up for the fact that we're removing me at the beginning
			}
			insert_at(child_node, parent_node, to_index);
		}
	};

	ist.DomAttachmentInstance = function (options) {
		ist.DomAttachmentInstance.superclass.constructor.apply(this, arguments);

		this.type = "dom";
		this.id = _.uniqueId();
		if (options.tag) {
			this._dom_obj = window.document.createElement(options.tag);
			this._dom_obj.__ist_contextual_object__ = this.contextual_object;
		} else {
			this._dom_obj = cjs();
			this._tag_change_listener = this.add_tag_change_listener();
		}

		this._style_change_listener = this.add_style_change_listeners();
		this._attr_change_listener = this.add_attribute_change_listeners();

		this._children_change_listener = this.add_children_change_listener();
		this.current_children_srcs = [];

		//this.pause();
		//this.on_ready();
	};
	(function (my) {
		_.proto_extend(my, ist.AttachmentInstance);
		var proto = my.prototype;
		proto.on_ready = function() {};
		proto.get_owner = function () {
			return this._owner;
		};
		proto.destroy = function () {
			if (_.has(this, "_tag_change_listener")) { this._tag_change_listener.destroy(); delete this._tag_change_listener; }
			if (_.has(this, "_style_change_listener")) { this._style_change_listener.destroy(); delete this._style_change_listener; }
			if (_.has(this, "_attr_change_listener")) { this._attr_change_listener.destroy(); delete this._attr_change_listener; }
			if (_.has(this, "_style_change_listeners")) {
				_.each(this._style_change_listeners, function (x) {
					x.destroy();
				});
			}
			if (_.has(this, "_attr_change_listeners")) {
				_.each(this._attr_change_listeners, function (x) {
					x.destroy();
				});
			}
			//console.log("destroy");
			if (_.has(this, "_children_change_listener")) { this._children_change_listener.destroy(); delete this._children_change_listener; }

			if(this._dom_obj.destroy) {
				var val = this._dom_obj.get();
				if(val) {
					delete val.__ist_contextual_object__;
				}
				this._dom_obj.destroy();
			} else {
				delete this._dom_obj.__ist_contextual_object__;
			}
		};
		proto.get_dom_obj = function () {
			if (_.has(this, "_tag_change_listener")) { this._tag_change_listener.run(); }
			var rv = cjs.get(this._dom_obj);
			return rv;
		};

		proto.add_tag_change_listener = function () {
			//console.log("add tag change listener");
			var contextual_object = this.get_contextual_object();

			var old_tag;
			return cjs.liven(function () {
				var tag = contextual_object.prop_val("tag");
				if (!_.isString(tag)) {
					tag=tag+"";
				}
				tag=tag.replace(/[^a-zA-Z0-9]/g, "");

				if (tag !== old_tag) {
					old_tag = tag;
					var dom_obj = window.document.createElement(tag);
					dom_obj.__ist_contextual_object__ = contextual_object;
					this._dom_obj.set(dom_obj);
				}
			}, {
				context: this,
				pause_while_running: true
			});
		};

		proto.add_style_change_listeners = function () {
			var contextual_object = this.get_contextual_object(),
				current_listener_prop_names = [],
				current_listeners = {},
				desired_listener_prop_names;
			this._style_change_listeners = current_listeners;

			return cjs.liven(function () {
				var children;
				var style = contextual_object.prop("style");
				var child_vals = {};
				if (style instanceof ist.ContextualDict) {
					children = style.children(true);
					var prop_names = _.pluck(children, "name");
					_.each(children, function (child) {
						child_vals[child.name] = child.value;
					});
					desired_listener_prop_names = prop_names;
				} else {
					children = [];
					desired_listener_prop_names = [];
				}

				var diff = _.diff(current_listener_prop_names, desired_listener_prop_names);
				current_listener_prop_names = desired_listener_prop_names;

				var dom_obj;
				if (diff.removed.length > 0) {
					dom_obj = this.get_dom_obj();
				}

				_.each(diff.removed, function (info) {
					var name = info.from_item;
					var listener = current_listeners[name];
					listener.destroy();
					delete diff.removed[name];
					if (dom_obj) {
						dom_obj.style[name] = "";
						delete dom_obj.style[name];
					}
				}, this);
				_.each(diff.added, function (info) {
					var name = info.item;
					current_listeners[name] = this.add_style_change_listener(name, child_vals[name]);
				}, this);
			}, {
				context: this,
				pause_while_running: true
			});
		};
		proto.add_style_change_listener = function (name, child_val) {
			var contextual_object = this.get_contextual_object();

			return cjs.liven(function () {
				var dom_obj = this.get_dom_obj();
				if (dom_obj) {
					var val = child_val.val();
					if (val) {
						dom_obj.style[name] = val.toString();
					} else {
						dom_obj.style[name] = "";
						delete dom_obj.style[name];
					}
				}
			}, {
				context: this,
				pause_while_running: true
			});
		};
		proto.add_attribute_change_listeners = function () {
			var contextual_object = this.get_contextual_object(),
				current_listener_prop_names = [],
				current_listeners = {},
				desired_listener_prop_names;

			this._attr_change_listeners = current_listeners;

			return cjs.liven(function () {
				var css = contextual_object.prop("attr");
				var child_vals = {};
				var children;
				if (css instanceof ist.ContextualDict) {
					children = css.children(true);
					var prop_names = _.pluck(children, "name");
					_.each(children, function (child) {
						child_vals[child.name] = child.value;
					});
					desired_listener_prop_names = prop_names;
				} else {
					children = [];
					desired_listener_prop_names = [];
				}

				var diff = _.diff(current_listener_prop_names, desired_listener_prop_names);
				current_listener_prop_names = desired_listener_prop_names;

				var dom_obj;
				if (diff.removed.length > 0) {
					dom_obj = this.get_dom_obj();
				}

				_.each(diff.removed, function (info) {
					var name = info.from_item;
					var listener = current_listeners[name];
					listener.destroy();
					delete diff.removed[name];
					if (dom_obj) {
						dom_obj.style[name] = "";
						delete dom_obj.style[name];
					}
				}, this);
				_.each(diff.added, function (info) {
					var name = info.item;
					current_listeners[name] = this.add_attribute_change_listener(name, child_vals[name]);
				}, this);
			}, {
				context: this,
				pause_while_running: true
			});
		};
		proto.add_attribute_change_listener = function (name, child_val) {
			var contextual_object = this.get_contextual_object();

			return cjs.liven(function () {
				var dom_obj = this.get_dom_obj();
				if (dom_obj) {
					var val = child_val.val();
					if (val) {
						dom_obj.setAttribute(name, val);
					} else {
						dom_obj.removeAttribute(name);
					}
				}
			}, {
				context: this,
				pause_while_running: true
			});
		};

		var get_dom_obj_and_src = function (contextual_dict) {
			return contextual_dict.get_dom_obj_and_src();
			/*
			var dom_obj,
				dom_attachment = contextual_dict.get_attachment_instance("dom"),
				show;

			if (dom_attachment) {
				show = contextual_dict.prop_val("show");
				show = show===undefined ? true : !!show;

				if(show) {
					dom_obj = dom_attachment.get_dom_obj();
					if(dom_obj) {
						return [dom_attachment, dom_obj];
					}
				}
			} else {
				var raphael_attachment = contextual_dict.get_attachment_instance("paper");
				show = contextual_dict.prop_val("show");
				show = show===undefined ? true : !!show;

				if(show) {
					if(raphael_attachment) {
						dom_obj = raphael_attachment.get_dom_obj();

						if(dom_obj) {
							return [raphael_attachment, dom_obj];
						}
					}
				}
			}
			return false;
			*/
		},
		get_dom_children = function(c) {
			if (c instanceof ist.ContextualDict) {
				return c.get_dom_children();
			} else {
				return false;
			}
		};

		proto.is_paused = function() {
			return this._paused;
		};

		proto.pause = function () {
			//console.log("PAUSE");
			this._paused = true;
			if (_.has(this, "_tag_change_listener")) { this._tag_change_listener.pause(); }
			if (_.has(this, "_style_change_listener")) { this._style_change_listener.pause(); }
			if (_.has(this, "_attr_change_listener")) { this._attr_change_listener.pause(); }
			if (_.has(this, "_style_change_listeners")) {
				_.each(this._style_change_listeners, function (x) {
					x.pause();
				});
			}
			if (_.has(this, "_attr_change_listeners")) {
				_.each(this._attr_change_listeners, function (x) {
					x.pause();
				});
			}
			if (_.has(this, "_children_change_listener")) { this._children_change_listener.pause(); }

			var children_srcs = this.current_children_srcs;
			_.each(children_srcs, function(child_src) {
				if (child_src instanceof ist.DomAttachmentInstance) {
					child_src.pause();
				} else if(_.isElement(child_src)) {
					var pause_fn = $(child_src).data("pause");
					if(pause_fn) {
						pause_fn();
					}
				}
			});
		};

		proto.resume = function () {
			//console.log("RESUME");
			this._paused = false;
			if (_.has(this, "_tag_change_listener")) { this._tag_change_listener.resume(); }
			if (_.has(this, "_style_change_listener")) { this._style_change_listener.resume(); }
			if (_.has(this, "_attr_change_listener")) { this._attr_change_listener.resume(); }
			if (_.has(this, "_style_change_listeners")) {
				_.each(this._style_change_listeners, function (x) {
					x.resume();
					x.run();
				});
			}
			if (_.has(this, "_attr_change_listeners")) {
				_.each(this._attr_change_listeners, function (x) {
					x.resume();
					x.run();
				});
			}
			if (_.has(this, "_children_change_listener")) { this._children_change_listener.resume(); }

			if (_.has(this, "_tag_change_listener")) { this._tag_change_listener.run(); }
			if (_.has(this, "_style_change_listener")) { this._style_change_listener.run(); }
			if (_.has(this, "_attr_change_listener")) { this._attr_change_listener.run(); }

			if (_.has(this, "_children_change_listener")) { this._children_change_listener.run(); }
			var children_srcs = this.current_children_srcs;
			_.each(children_srcs, function(child_src) {
				if (child_src instanceof ist.DomAttachmentInstance) {
					child_src.resume();
				} else if(_.isElement(child_src)) {
					var resume_fn = $(child_src).data("resume");
					if(resume_fn) {
						resume_fn();
					}
				}
			});
		};

		proto.on_remove = function() {
			var dom_obj = this.get_dom_obj();
			//console.log("REMOVE");
			if (!dom_obj || !isInDOMTree(dom_obj)) {
				this.pause();
			}
		};

		proto.on_add = function() {
			var dom_obj = this.get_dom_obj();

			//console.log("ADD");
			if (dom_obj && isInDOMTree(dom_obj)) {
				this.resume();
			}
		};

		proto.add_children_change_listener = function () {
			//console.log("Add children change listener");
			var contextual_object = this.get_contextual_object();

			var cc = cjs.liven(function () {
				var dom_obj = this.get_dom_obj();
				//console.log(dom_obj);
				if (!_.isElement(dom_obj)) {
					return;
				}

				if (contextual_object.has("innerHTML")) {
					dom_obj.innerHTML = contextual_object.prop_val("innerHTML");
					return;
				} else {
					var	children, 
						current_children = _.toArray(dom_obj.childNodes),
						desired_children_srcs = [],
						desired_children = [],
						show = contextual_object.prop_val("showChildren"),
						textContent = contextual_object.prop_val("textContent");
					
					if(textContent) {
						desired_children.push(document.createTextNode(textContent));
						desired_children_srcs.push(false);
					}

					if(show === undefined) { show = true; }

					if(_.isArray(show)) { // put in order
						children = contextual_object.children();
						_.each(show, function(show_child) {
							var child_index = _.index_where(children, function(child) {
								return child.value === show_child || child.name === show_child;
							});

							if(child_index >= 0) {
								var cdc = get_dom_children(children[child_index].value);
								if(cdc) {
									desired_children_srcs.push.apply(desired_children_srcs, cdc.srcs);
									desired_children.push.apply(desired_children, cdc.children);
								}

								children.splice(child_index, 1);
							}
						}, this);
					} else if(show !== false) {
						children = contextual_object.children();
						_.each(children, function (child) {
							if(show===true || show === child.name || show === child.value) {
								//if(!child.value._destroyed) {
									var cdc = get_dom_children(child.value);
									if(cdc) {
										desired_children_srcs.push.apply(desired_children_srcs, cdc.srcs);
										desired_children.push.apply(desired_children, cdc.children);
									}
								//}
							}
						}, this);
					}

					var len = current_children.length, i, nothing_changed = false;
					if(len === desired_children.length) {
						var found_change = false;
						for(i = 0; i<len; i++){ 
							if(current_children[i] !== desired_children[i]) {
								found_change = true;
								break;
							}
						}
						if(!found_change) {
							nothing_changed = true;
						}
					}

					if(nothing_changed) {
						this.current_children_srcs = desired_children_srcs;
						return;
					}

					var diff = _.diff(current_children, desired_children);
					_.forEach(diff.removed, function (info) {
						var index = info.from, child = info.from_item;
						var src = this.current_children_srcs[index];

						remove(child);
						if(src instanceof ist.DomAttachmentInstance) {
							src.on_remove();
						} else if(_.isElement(src)) {
							var pause_fn = $(src).data("pause");
							if(pause_fn) {
								pause_fn();
							}
						}
					}, this);
					_.forEach(diff.added, function (info) {
						var index = info.to, child = info.item;
						var src = desired_children_srcs[index];

						insert_at(child, dom_obj, index);

						if(src instanceof ist.DomAttachmentInstance) {
							src.on_add();
						} else if(_.isElement(src)) {
							var resume_fn = $(src).data("resume");
							if(resume_fn) {
								resume_fn();
							}
						}
					}, this);
					_.forEach(diff.moved, function (info) {
						var from_index = info.from, to_index = info.to, child = info.item;
						move(child, from_index, to_index);
					}, this);
					this.current_children_srcs = desired_children_srcs;
				}
			}, {
				context: this,
				pause_while_running: true
			});
			return cc;
		};
	}(ist.DomAttachmentInstance));

	ist.DomAttachment = function (options) {
		options = _.extend({
			instance_class: ist.DomAttachmentInstance
		}, options);
		ist.DomAttachment.superclass.constructor.call(this, options);
		this.type = "dom";
	};
	(function (My) {
		_.proto_extend(My, ist.Attachment);
		var proto = My.prototype;

		ist.register_serializable_type("dom_attachment",
			function (x) {
				return x instanceof My;
			},
			function () {
				return {
					instance_options: ist.serialize(this.instance_options)
				};
			},
			function (obj) {
				return new My({
					instance_options: ist.deserialize(obj.instance_options)
				});
			});
	}(ist.DomAttachment));

}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,able,uid,console,jQuery,Raphael,window */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var is_paper = function(obj) { return obj instanceof Raphael._Paper; };

	var get_children = function(child_nodes) {
		var children = [];
		_.each(child_nodes, function(child) {
			if(child instanceof ist.ContextualDict) {
				if(child.is_template()) {
					var copies = child.instances();
					children.push.apply(children, get_children(copies));
				} else {
					var shape_attachment_instance = child.get_attachment_instance("shape");
					if(shape_attachment_instance) {
						var to_show = child.prop_val("show");
						if(to_show) {
							children.push(shape_attachment_instance);
						}
						children.push.apply(children, shape_attachment_instance.get_children());
					}
					var group_attachment_instance = child.get_attachment_instance("group");
					if(group_attachment_instance) {
						//console.log(group_attachment_instance);
						children.push.apply(children, group_attachment_instance.get_children());
					}
				}
			}
		}, this);
		return children;
	},
	get_cobj_children = function(contextual_object) {
		var children, cobj_children, values;
		var show = contextual_object.prop_val("showChildren");

		if(_.isArray(show)) { // put in order
			cobj_children = contextual_object.children();
			children = [];
			_.each(show, function(show_child) {
				var child_index = _.index_where(cobj_children, function(child) {
					return child.value === show_child || child.name === show_child;
				});

				if(child_index >= 0) {
					children.push.apply(children, get_children([cobj_children[child_index].value]));
					cobj_children.splice(child_index, 1);
				}
			});
		} else if(show !== false) {
			cobj_children = contextual_object.children();
			children = get_children(_.pluck(cobj_children, "value"));
		} else {
			children = [];
		}

		return children;
	};

	ist.PaperAttachment = ist.register_attachment("paper", {
			ready: function() {
				this.dom_obj = window.document.createElement("span");
				this.paper = new Raphael(this.dom_obj, 0, 0);
			},
			destroy: function(silent) {
				this.paper.clear();
				this.paper.remove();
				delete this.paper;
				delete this.dom_obj;
			},
			parameters: {
				width_height: function(contextual_object) {
					var width = contextual_object.prop_val("width"),
						height = contextual_object.prop_val("height");
					this.paper.setSize(width, height);
				},
				fill: function(contextual_object) {
					var fill = contextual_object.prop_val("fill"),
						dom_obj = this.get_dom_obj();
					$("svg", dom_obj).css("background-color", fill);
				},
				screen: {
					type: "list",
					add: function(shape_attachment_instance, to_index) {
						var shape = shape_attachment_instance.create_robj(this.paper);
						var itemi, len;
						var index = 0;
						var item;
						this.paper.forEach(function(elem) {
							if(index === to_index) {
								itemi = elem;
							}
							len = index;
							index++;
						});
						if(itemi !== shape) {
							if(to_index >= len) {
								shape.toBack();
							} else {
								shape.insertBefore(itemi);
							}
						}
					},
					remove: function(shape_attachment_instance) {
						shape_attachment_instance.remove();
					},
					move: function(item, from_index, to_index) {
						var shape = item.get_robj();
						var index = 0;
						if (from_index < to_index) { //If it's less than the index we're inserting at...
							to_index += 1; //Increase the index by 1, to make up for the fact that we're removing me at the beginning
						}
						var itemi, len;
						this.paper.forEach(function(elem) {
							if(index === to_index) {
								itemi = elem;
							}
							len = index;
							index++;
						});
						if(to_index >= len) {
							shape.toBack();
						} else {
							shape.insertBefore(itemi);
						}
					},
					getter: function(contextual_object) {
						return get_cobj_children(contextual_object);
					}
				}
			},
			proto_props: {
				get_dom_obj: function() {
					return this.dom_obj;
				}
			}
		});
	var can_animate_parameters = ["r", "cx", "cy", "x", "y", "width", "height", "path", "fill", "stroke", "opacity", "fill_opacity", "stroke_opacity", "transform"];
	var can_animate_dict = {};
	_.each(can_animate_parameters, function(name) {
		can_animate_dict[name] = true;
	});
	ist.ShapeAttachment = ist.register_attachment("shape", {
			ready: function() {
				this.shape_type = this.options.shape_type;
				if(this.shape_type === "rectangle") {
					this.shape_type = "rect";
				}
				this.constructor_params = this.options.constructor_params;
				this.$robj = cjs(false);
				this.$children = cjs(this.child_getter, {context: this});
			},
			destroy: function(silent) {
				this.remove();
				this.$robj.destroy(silent);
				this.$children.destroy(silent);
				delete this.constructor_params;
				delete this.$robj;
				delete this.$children;
			},
			parameters: (function(infos) {
				var parameters = {};
				_.each(infos, function(euc_name, raph_name) {
					parameters[euc_name] = function(contextual_object) {
						if(contextual_object.has(euc_name)) {
							var prop_val = contextual_object.prop_val(euc_name);
							var robj = this.get_robj();
							if(robj) {
								var animated_properties;
								if(can_animate_dict[euc_name] === true && (animated_properties = contextual_object.prop_val("animated_properties")) &&
										(	animated_properties === true ||
											animated_properties === "*") ||
											(_.isArray(animated_properties) && _.indexOf(animated_properties, euc_name) >= 0)) {
									var duration = contextual_object.prop_val("animation_duration");
									if(!_.isNumber(duration)) {
										duration = 300;
									}
									
									var easing = contextual_object.prop_val("animation_easing");
									if(!_.isString(easing)) {
										easing = "linear";
									}

									var anim_options = { };
									anim_options[raph_name] = cjs.get(prop_val);
									try {
										robj.animate(anim_options, duration, easing);
									} catch(e) {
										if(ist.__log_errors) {
											console.error(e);
										}
									}
								} else {
									try {
										robj.attr(raph_name, cjs.get(prop_val));
									} catch(e) {
										if(ist.__log_errors) {
											console.error(e);
										}
									}
								}
							}
						}
					};
				}, this);
				return parameters;
			}({
				opacity: "opacity", // put opacity first because fill-opacity should be set after opacity (?)
				"arrow-end": "arrow_end",
				"arrow-start": "arrow_start",
				blur: "blur",
				"clip-rect": "clip_rect",
				cursor: "cursor",
				cx: "cx",
				cy: "cy",
				fill: "fill",
				"fill-opacity": "fill_opacity",
				font: "font",
				"font-family": "font_family",
				"font-size": "font_size",
				"font-style": "font_style",
				"font-weight": "font_weight",
				height: "height",
				href: "href",
				"letter-spacing": "letter_spacing",
				path: "path",
				r: "r",
				rx: "rx",
				ry: "ry",
				src: "src",
				stroke: "stroke",
				"stroke-dasharray": "stroke_dasharray",
				"stroke-linecap": "stroke_linecap",
				"stroke-linejoin": "stroke_linejoin",
				"stroke-miterlimit": "stroke_miterlimit",
				"stroke-opacity": "stroke_opacity",
				"stroke-width": "stroke_width",
				target: "target",
				"text-anchor": "text_anchor",
				text: "text",
				title: "title",
				transform: "transform",
				width: "width",
				x: "x",
				y: "y"
			})),
			proto_props: {
				create_robj: function(paper) {
					var robj = this.get_robj();
					if(robj) {
						return robj;
					} else {
						robj = paper[this.shape_type].apply(paper, this.constructor_params);
						robj[0].__ist_contextual_object__ = this.get_contextual_object();
						this.$robj.set(robj);
						return robj;
					}
				},
				get_robj: function() {
					return cjs.get(this.$robj);
				},
				remove: function() {
					var robj = this.get_robj();
					if(robj) {
						robj.remove();
						this.$robj.set(false);
					}
				},
				child_getter: function() {
					var contextual_object = this.get_contextual_object();
					var children, cobj_children, values;
					var to_show = contextual_object.prop_val("show");

					if(_.isArray(to_show) || _.isString(to_show)) {
						if(_.isString(to_show)) {
							to_show = [to_show];
						}
						cobj_children = _.filter(contextual_object.children(), function(child_info) {
							return _.contains(to_show, child_info.name);
						});
						values = _.pluck(cobj_children, "value");
						values.reverse();
						children = get_children(values);
					} else if(to_show) {
						cobj_children = contextual_object.children();
						values = _.pluck(cobj_children, "value");
						values.reverse();
						children = get_children(values);
					} else {
						children = [];
					}
					return children;
				},
				get_children: function() {
					return this.$children.get();
				}
			},
			attachment_destroy: function() { }
		});
	ist.GroupAttachment = ist.register_attachment("group", {
			ready: function() {
				this.$children = cjs(this.child_getter, {context: this});
			},
			destroy: function(silent) {
				this.$children.destroy(silent);
				delete this.$children;
			},
			parameters: {
				children: function(contextual_object) {
				}
			},
			proto_props: {
				child_getter: function() {
					var contextual_object = this.get_contextual_object();
					return get_cobj_children(contextual_object);
				},
				get_children: function() {
					return this.$children.get();
				}
			}
		});
}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,able,uid,console,jQuery,window,Box2D */

(function (ist, $) {
	"use strict";

	if(!window.Box2D) { return; }

	var cjs = ist.cjs,
		_ = ist._;

	var PIXELS_PER_METER = 30;

	var B2Vec2 = Box2D.Common.Math.b2Vec2,
		B2AABB = Box2D.Collision.b2AABB,
		B2BodyDef = Box2D.Dynamics.b2BodyDef,
		b2Body = Box2D.Dynamics.b2Body,
		B2FixtureDef = Box2D.Dynamics.b2FixtureDef,
		B2Fixture = Box2D.Dynamics.b2Fixture,
		B2World = Box2D.Dynamics.b2World,
		B2MassData = Box2D.Collision.Shapes.b2MassData,
		B2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
		B2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
		B2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef,
		b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
		b2ContactListener = Box2D.Dynamics.b2ContactListener;

	var fixDef = new B2FixtureDef();
	fixDef.density = 1.0;
	fixDef.friction = 0.5;
	fixDef.restitution = 0.2;

	var bodyDef = new B2BodyDef();
	bodyDef.type = b2Body.b2_dynamicBody;

	ist.contact_listeners = new RedMap({
		equals: ist.check_contextual_object_equality,
		hash: function(obj) {
			if(obj.hash) {
				return obj.hash();
			} else {
				return obj.toString();
			}
		}
	});
	
	ist.WorldAttachment = ist.register_attachment("box2d_world", {
			ready: function() {
				this.world = new B2World(new B2Vec2(0, 0), true);
				this.world.SetContactListener({
					BeginContact: function() { },
					EndContact: function(contact) {
						var cobj_a = contact.m_fixtureA.cobj,
							cobj_b = contact.m_fixtureB.cobj;

						var contact_listeners = _.filter(ist.contact_listeners.get(cobj_a), function(x) {
							return ist.check_contextual_object_equality(x.target, cobj_b);
						}).concat(_.filter(ist.contact_listeners.get(cobj_b), function(x) {
							return ist.check_contextual_object_equality(x.target, cobj_a);
						}));
						window.setTimeout(function() {
							_.each(contact_listeners, function(x) {
								x.callback(contact);
							});
						}, 0);
					},
					PreSolve: function() { },
					PostSolve: function() { }
				});

				var update_world = _.bind(function() {
					this.world.Step(1 / 60, 10, 10);
					ist.requestAnimationFrame.call(window, update_world);
					/*
					if(this.world.m_gravity.y < 5) {
						this.world.DrawDebugData();
					}
					*/
				}, this);
				ist.requestAnimationFrame.call(window, update_world);

/*
				var world = this.world;
				if(world.m_gravity.y < 5) {
					var debugDraw = new b2DebugDraw();
					debugDraw.SetSprite(document.getElementById("canvas").getContext("2d"));
					debugDraw.SetDrawScale(PIXELS_PER_METER);
					debugDraw.SetFillAlpha(0.3);
					debugDraw.SetLineThickness(1.0);
					debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
					world.SetDebugDraw(debugDraw);
				}
				*/
			},
			parameters: {
				gravity: function(contextual_object) {
					var gravity_x = contextual_object.prop_val("gx"),
						gravity_y = contextual_object.prop_val("gy");

					var gravity_vector = new B2Vec2(gravity_x, gravity_y);
					this.world.SetGravity(gravity_vector);
					var body_list = this.world.GetBodyList();
					var body_len = this.world.GetBodyCount();
					for(var i = 0; i<body_len; i++) {
						body_list.SetAwake(true);
						body_list = body_list.GetNext();
					}
				}
			},
			proto_props: {
				get_world: function() {
					return this.world;
				}
			}
		});
	ist.FixtureAttachment = ist.register_attachment("box2d_fixture", {
			ready: function() {
				var contextual_object = this.get_contextual_object();

				this.b2x = cjs.constraint(function() {
					var shape_type = contextual_object.prop_val("shape");
					if(shape_type === "circle") {
						return contextual_object.prop_val("cx");
					} else if(shape_type === "rectangle") {
						var x = contextual_object.prop_val("x"),
							width = contextual_object.prop_val("width");
						return x+width/2;
					} else {
						return -1;
					}
				});
				this.b2y = cjs.constraint(function() {
					var shape_type = contextual_object.prop_val("shape");
					if(shape_type === "circle") {
						return contextual_object.prop_val("cy");
					} else if(shape_type === "rectangle") {
						var y = contextual_object.prop_val("y"),
							height = contextual_object.prop_val("height");
						return y+height/2;
					} else {
						return -1;
					}
				});
				this.b2vx = cjs.constraint(0);
				this.b2vy= cjs.constraint(0);
				this.b2t = cjs.constraint(0);
				this.b2vt = cjs.constraint(0);
				this.body = cjs.constraint();
				this.shape = cjs.constraint();
				this.fixture = cjs.constraint();

				this._update_interval = window.setInterval(_.bind(function() {
					var body = this.get_body();
					if(body) {
						var position = body.GetPosition();
						var angle = body.GetAngle();
						var linearVelocity = body.GetLinearVelocity();
						var angularVelocity = body.GetAngularVelocity();

						cjs.wait();
						var shape = this.shape.get();
						if(shape instanceof B2CircleShape) {
							this.b2x.set(position.x * PIXELS_PER_METER);
							this.b2y.set(position.y * PIXELS_PER_METER);
						} else if(shape instanceof B2PolygonShape) {
							var v0 = shape.m_vertices[0],
								v1 = shape.m_vertices[2],
								width = Math.abs(v0.x-v1.x),
								height = Math.abs(v0.y-v1.y);
							this.b2x.set((position.x-width/2) * PIXELS_PER_METER);
							this.b2y.set((position.y-height/2) * PIXELS_PER_METER);
						}

						this.b2vx.set(linearVelocity.x);
						this.b2vy.set(linearVelocity.y);

						this.b2t.set(angle);

						this.b2vt.set(angularVelocity);

						cjs.signal();
					}
					/**/
				}, this), 1000 / 60);
			},
			destroy: function(silent) {
				window.clearInterval(this._update_interval);

				var body = this.get_body();
				if(body) {
					var world = body.m_world;
					world.DestroyBody(body);
				}
			},
			parameters: {
				radius: function(contextual_object) {
					var shape = this.shape.get();
					if(shape instanceof B2CircleShape) {
						var radius = contextual_object.prop_val("r");
						shape.SetRadius(radius/PIXELS_PER_METER);
					}
				}, 
				fixture_attributes: function(contextual_object) {
					var fixture = this.get_fixture();
					if(fixture) {
						var density = contextual_object.prop_val("density"),
							friction = contextual_object.prop_val("friction"),
							restitution = contextual_object.prop_val("restitution");

						fixture.density = density;
						fixture.friction = friction;
						fixture.restition = restitution;
					}
				},
				path: function(contextual_object) {
					var shape = this.shape.get();
					if(shape instanceof B2PolygonShape) {
						var width = contextual_object.prop_val("width"),
							height = contextual_object.prop_val("height");
						shape.SetAsBox(width/(2*PIXELS_PER_METER),
										height/(2*PIXELS_PER_METER));
					}
				},
				fixed: function(contextual_object) {
					var fixed = contextual_object.prop_val("fixed");
					var body = this.body.get();

					if(body) {
						if(fixed) {
							var shape = this.shape.get(), x, y;
							if(shape instanceof B2CircleShape) {
								var radius = contextual_object.prop_val("r");
								x = (contextual_object.prop_val("cx")) / PIXELS_PER_METER;
								y = (contextual_object.prop_val("cy")) / PIXELS_PER_METER;
							} else if(shape instanceof B2PolygonShape) {
								var half_width = contextual_object.prop_val("width")/2;
								var half_height = contextual_object.prop_val("height")/2;
								x = (contextual_object.prop_val("x")+half_width) / PIXELS_PER_METER;
								y = (contextual_object.prop_val("y")+half_height) / PIXELS_PER_METER;
							}
							body.SetType(b2Body.b2_staticBody);
							body.SetPosition(new B2Vec2(x, y));
						} else {
							body.SetType(b2Body.b2_dynamicBody);
							body.SetAwake(true);
						}
					}
				}, world: function(contextual_object) {
					var world_val = contextual_object.prop_val("world");

					if(world_val) {
						var world_attachment = world_val.get_attachment_instance("box2d_world");
						var world = world_attachment.get_world();
						if(this.world !== world) {
							var shape_type = contextual_object.prop_val("shape");
							if(shape_type === "circle" || shape_type === "rectangle") {
								var density = contextual_object.prop_val("density"),
									friction = contextual_object.prop_val("friction"),
									restitution = contextual_object.prop_val("restitution"),
									fixed = contextual_object.prop_val("fixed"),
									fixture;

								fixDef.density = density;
								fixDef.friction = friction;
								fixDef.restitution = restitution;

								bodyDef.type = fixed ? b2Body.b2_staticBody : b2Body.b2_dynamicBody;

								if(shape_type === "circle") {
									var cx = contextual_object.prop_val("cx"),
										cy = contextual_object.prop_val("cy"),
										radius = contextual_object.prop_val("r");

									bodyDef.position.x = (cx) / PIXELS_PER_METER;
									bodyDef.position.y = (cy) / PIXELS_PER_METER;
									fixDef.shape = new B2CircleShape(radius/PIXELS_PER_METER);
								} else if(shape_type === "rectangle") {
									var x = contextual_object.prop_val("x"),
										y = contextual_object.prop_val("y"),
										half_width = contextual_object.prop_val("width")/2,
										half_height = contextual_object.prop_val("height")/2;

									bodyDef.position.x = (x+half_width) / PIXELS_PER_METER;
									bodyDef.position.y = (y+half_height) / PIXELS_PER_METER;
									fixDef.shape = new B2PolygonShape();
									fixDef.shape.SetAsBox(half_width/PIXELS_PER_METER,
															half_height/PIXELS_PER_METER);

								}
								fixture = world.CreateBody(bodyDef).CreateFixture(fixDef);
								fixture.cobj = contextual_object;

								this.fixture.set(fixture);

								var body = fixture.GetBody();

								this.body.set(body);
								this.shape.set(fixture.GetShape());

								var position = body.GetPosition();
								var angle = body.GetAngle();
								var linearVelocity = body.GetLinearVelocity();
								var angularVelocity = body.GetAngularVelocity();

								this.b2x.set(position.x * PIXELS_PER_METER);
								this.b2y.set(position.y * PIXELS_PER_METER);

								this.b2vx.set(linearVelocity.x);
								this.b2vy.set(linearVelocity.y);

								this.b2t.set(angle);

								this.b2vt.set(angularVelocity);

								this.world = world;
							}
						}
					}
				}
			},
			proto_props: {
				get_fixture: function() {
					return this.fixture.get();
				},
				get_body: function() {
					return this.body.get();
				},
				get_shape: function() {
					return this.shape.get();
				},
				getComputedX: function() {
					return this.b2x.get();
				},
				getComputedY: function() {
					return this.b2y.get();
				},
				getComputedTheta: function() {
					return this.b2t.get();
				},
				applyForce: function(x, y) {
					var body = this.get_body();
					if(body) {
						setTimeout(function() {
							body.ApplyForce(new B2Vec2(x, y), body.GetWorldCenter());
						});
					}
				},
				applyImpulse: function(x, y) {
					var body = this.get_body();
					if(body) {
						setTimeout(function() {
							body.ApplyImpulse(new B2Vec2(x, y), body.GetWorldCenter());
						});
					}
				}
			}
		});
}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,jQuery,window */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;
	
	var rc_id = 0,
		CONSTRAINT_SERVER = "constraint_server",
		CONSTRAINT_CLIENT = "constraint_client",
		CHANGED_TYPE = "changed",
		GET_TYPE = "get",
		VALUE_TYPE = "value",
		DESTROY_SERVER_TYPE = "destroy_server",
		DESTROY_CLIENT_TYPE = "destroy_client";

	var RemoteConstraintServer = function(value) {
		this.comm_mechanism = false;
		this._id = rc_id++;
		this.message_signature = "rc_" + this._id;
		this.value = cjs(function() {
			return ist.summarize_value_for_comm_wrapper(cjs.get(value));
		});

		this.$onChange = _.bind(this.onChange, this);
		this.$onMessage = _.bind(this.onMessage, this);

		this.value.onChange(this.$onChange);
	};
	(function(my) {
		var proto = my.prototype;
		proto.id = function() { return this._id; };
		proto.onChange = function() {
			this.comm_mechanism.post({
				type: this.message_signature,
				subtype: CHANGED_TYPE
			});
		};
		proto.onMessage = function(message) {
			if(message.subtype === GET_TYPE) {
				this.comm_mechanism.post({
					type: this.message_signature,
					subtype: VALUE_TYPE,
					value: this.value.get(),
					client_id: message.client_id
				});
			}
		};
		proto.destroy = function() {
			this.comm_mechanism.post({
				type: this.message_signature,
				subtype: DESTROY_SERVER_TYPE
			});
			this.comm_mechanism.off(this.message_signature, this.$on_message);
			this.value.offChange(this.$onChange);
			this.value.destroy(true);
			delete this.$onChange;
			delete this.$onMessage;
			delete this.comm_mechanism;
		};
		proto.set_communication_mechanism = function(comm_mechanism) {
			if(this.comm_mechanism) {
				this.comm_mechanism.off(this.message_signature, this.$on_message);
			}
			this.comm_mechanism = comm_mechanism;
			this.comm_mechanism.on(this.message_signature, this.$onMessage);
		};
	}(RemoteConstraintServer));

	var client_id = 0;
	var RemoteConstraintClient = function(server_id) {
		this.comm_mechanism = false;
		this._id = client_id++;
		this.server_id = server_id;
		this.message_signature = "rc_" + this.server_id;

		this.$onMessage = _.bind(this.onMessage, this);
		this.$value = cjs();
	};
	(function(my) {
		var proto = my.prototype;

		proto.requestUpdate = function() {
			this.comm_mechanism.post({
				type: this.message_signature,
				subtype: GET_TYPE,
				client_id: this._id
			});
		};

		proto.get = function() {
			if(!this.$value.isValid()) {
				this.requestUpdate();
			}
			return this.$value.get();
		};
		proto.onMessage = function(message) {
			switch(message.subtype) {
				case VALUE_TYPE:
					this.$value.set(message.value);
					break;
				case CHANGED_TYPE:
					this.$value.invalidate();
					break;
			}
		};
		proto.destroy = function() {
			this.comm_mechanism.post({
				type: this.message_signature,
				subtype: DESTROY_CLIENT_TYPE
			});
			this.$value.destroy(true);
			this.comm_mechanism.off(this.message_signature, this.$on_message);
			delete this.$onMessage;
			delete this.comm_mechanism;
		};

		proto.set_communication_mechanism = function(comm_mechanism) {
			if(this.comm_mechanism) {
				this.comm_mechanism.off(this.message_signature, this.$on_message);
			}
			this.comm_mechanism = comm_mechanism;
			this.comm_mechanism.on(this.message_signature, this.$onMessage);
			this.requestUpdate();
		};
	}(RemoteConstraintClient));

	ist.RemoteConstraintServer = RemoteConstraintServer;
	ist.RemoteConstraintClient = RemoteConstraintClient;

	var summarize_value = ist.summarize_value_for_comm_wrapper = function (value, avoid_dict_followup) {
		var rv;
		if (value instanceof ist.ContextualObject) {
			var id = value.id();
			var type = value.type();
			var object_summary = {
				type: type,
				id: id,
				obj_id: value.get_object().id(),
				colloquial_name: value.get_colloquial_name(),
				name: value.get_name()
			};

			if((type === "dict" || type === "stateful") && avoid_dict_followup !== true) {
				var is_template = value.is_template();
				var is_instance;
				var template, index, instances;

				if(is_template) {
					is_instance = index = template = false;
					instances = value.instances();
				} else {
					instances = false;
					is_instance = value.is_instance();
					if(is_instance) {
						var template_info = value.get_template_info();
						template = template_info.cobj;
						index = template_info.index;
					} else {
						template = index = false;
					}
				}
				object_summary.is_template = is_template;
				object_summary.is_instance = is_instance;
				object_summary.template = summarize_value(template, true);
				object_summary.instances = instances ? _.map(instances, function(x) { return summarize_value(x, true); }) : instances;
				object_summary.index = index;
			}
			rv = {
				__type__: "summarized_obj",
				__value__: "contextual_obj",
				object_summary: object_summary
			};
		} else if (value instanceof ist.StartState) {
			rv = {
				__type__: "summarized_obj",
				__value__: "state",
				object_summary: {
					type: 'start_state',
					id: value.id()
				}
			};
		} else if (value instanceof ist.Statechart) {
			rv = {
				__type__: "summarized_obj",
				__value__: "state",
				object_summary: {
					type: 'statechart',
					id: value.id()
				}
			};
		} else if (value instanceof ist.StatechartTransition) {
			rv = {
				__type__: "summarized_obj",
				__value__: "transition",
				object_summary: {
					type: 'transition',
					id: value.id()
				}
			};
		} else if (value instanceof ist.Event) {
			rv = {
				__type__: "summarized_obj",
				__value__: "event",
				object_summary: {
					type: 'event',
					id: value.id(),
					event_type: value.type()
				}
			};
		} else if (value instanceof ist.Cell) {
			rv = {
				__type__: "summarized_obj",
				__value__: "contextual_obj",
				object_summary: {
					type: 'raw_cell',
					id: value.id()
				}
			};
		} else if (value instanceof ist.WrapperClient) {
			rv = {
				__type__: "summarized_obj",
				__value__: "client_wrapper"
			};
		} else if (cjs.isConstraint(value)) {
			rv = {
				__type__: "summarized_obj",
				__value__: "constraint"
			};
		} else if (_.isArray(value)) {
			rv = _.map(value, summarize_value);
		} else if (_.isFunction(value)) {
			rv = {
				__type__: "summarized_obj",
				__value__: "function"
			};
		} else if (_.isElement(value)) {
			rv = {
				__type__: "summarized_obj",
				__value__: "dom_elem"
			};
		} else if (window.Box2D && value instanceof Box2D.Dynamics.b2World) {
			rv = {
				__type__: "summarized_obj",
				__value__: "box2d_world"
			};
		} else if(value instanceof ist.ParsedFunction) {
			rv = {
				__type__: "summarized_obj",
				__value__: "function"
			};
		} else if (_.isObject(value)) {
			rv = {};
			_.each(value, function (v, k) { rv[k] = summarize_value(v); });
		} else {
			rv = value;
		}
		return rv;
	};
}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,window */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._,
		origin = window.location.protocol + "//" + window.location.host;
	
	ist.InterWindowCommWrapper = function(remote_window, client_id) {
		able.make_this_listenable(this);
		this.remote_window = remote_window;
		this.client_id = client_id;

		this.$on_message = _.bind(this.on_message, this);
		window.addEventListener("message", this.$on_message);
	};

	(function(My) {
		var proto = My.prototype;
		able.make_proto_listenable(proto);
		proto.on_message = function(event) {
			if(event.source === this.remote_window) {
				var data = event.data;
				if(data.client_id === this.client_id) {
					var message = data.message;
					this._emit(message.type, message);
				}
			}
		};
		proto.post = function(message, callback) {
			this.remote_window.postMessage({
				message: message,
				client_id: this.client_id
			}, origin);
			if(_.isFunction(callback)) {
				callback();
			}
		};
		proto.destroy = function() {
			window.removeEventListener("message", this.$on_messsage);
			delete this.$on_message;
		};
	}(ist.InterWindowCommWrapper));


	var same_window_comm_wrappers = [];
	ist.SameWindowCommWrapper = function(client_id, message_delay) {
		able.make_this_listenable(this);
		this.client_id = client_id;
		this.message_delay = message_delay;
		same_window_comm_wrappers.push(this);
	};

	(function(My) {
		var proto = My.prototype;
		able.make_proto_listenable(proto);

		proto.post = function(message, callback) {
			var len = same_window_comm_wrappers.length;
			var my_client_id = this.client_id;
			
			for(var i = 0; i<len; i++) {
				var same_window_comm_wrapper = same_window_comm_wrappers[i];
				if(this !== same_window_comm_wrapper &&
					same_window_comm_wrapper.client_id === my_client_id) {
					same_window_comm_wrapper.on_message(message);
				}
			}
			if(_.isFunction(callback)) {
				callback();
			}
		};

		proto.on_message = function(message) {
			if(this.message_delay || _.isNumber(this.message_delay)) {
				var message_delay = _.isNumber(this.message_delay) ? this.message_delay : 0;
				_.defer(_.bind(function() {
					this._emit(message.type, message);
				}, this), message_delay);
			} else {
				this._emit(message.type, message);
			}
		};

		proto.destroy = function() {
			for(var i = 0; i<same_window_comm_wrappers.length; i++) {
				if(same_window_comm_wrappers[i] === this) {
					same_window_comm_wrappers.splice(i, 1);
					i--;
				}
			}
		};
	}(ist.SameWindowCommWrapper));

	ist.SocketCommWrapper = function(client_id, is_server) {
		able.make_this_listenable(this);
		this.client_id = client_id;
		this.is_server = is_server;
		this.socket = io.connect(origin);
		this.socket.emit("comm_wrapper", this.client_id, this.is_server);
		this.$on_message = _.bind(this.on_message, this);
		this.socket.on("message", this.$on_message);
	};

	(function(My) {
		var proto = My.prototype;
		able.make_proto_listenable(proto);

		proto.on_message = function(data) {
			if(data.client_id === this.client_id) {
				this._emit(data.type, data.message);
			}
		};
		proto.post = function(message, callback) {
			this.socket.emit("message", {
				type: message.type,
				message: message,
				client_id: this.client_id
			});
			if(_.isFunction(callback)) {
				callback();
			}
		};
		proto.destroy = function() {
			this.socket.disconnect();
			delete this.socket;
		};
	}(ist.SocketCommWrapper));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,window,Box2D,RedMap */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;
	var id = 0;
	var ACTIVE = {},
		PAUSED = {};
	ist.WrapperServer = function (options) {
		this._id = id++;
		able.make_this_listenable(this);
		this.object = options.object;
		this.object.on("begin_destroy", this.on_begin_destroy, this);
		this.object.on("destroyed", this.destroy, this);
		this._type = "none";
		this._event_type_listeners = options.listen_to || [];

		this.client_count = 0;
		this.client_ids = {};
		_.each(options.client_ids, function(client_id) {
			this.add_client_id(client_id);
		}, this);

		this.add_emission_listeners();

		this.fn_call_constraints = new RedMap({
			hash: function (args) {
				return args[0];
			},
			equals: function (args1, args2) {
				var i;
				var len = args1.length;
				if (len !== args2.length) {
					return false;
				} else {
					for (i = 0; i < len; i += 1) {
						if (!argeq(args1[i], args2[i])) {
							return false;
						}
					}
					return true;
				}
			}
		});
	};

	(function (my) {
		var proto = my.prototype;
		able.make_proto_listenable(proto);

		proto.id = function() { return this._id; };

		proto.add_client_id = function(client_id) {
			if(!this.client_ids.hasOwnProperty(client_id)) {
				this.client_ids[client_id] = ACTIVE;
				this.client_count++;
			}
		};

		proto.remove_client_id = function(client_id) {
			if(this.client_ids.hasOwnProperty(client_id)) {
				delete this.client_ids[client_id];
				this.client_count--;
			}
		};

		proto.has_clients = function() {
			return this.client_count > 0;
		};

		proto.add_emission_listeners = function () {
			var object = this.get_object();
			_.each(this._event_type_listeners, function (event_type) {
				object.on(event_type, this.on_emit, this);
			}, this);
		};

		proto.remove_emission_listeners = function () {
			var object = this.get_object();
			_.each(this._event_type_listeners, function (event_type) {
				object.off(event_type, this.on_emit, this);
			}, this);
		};

		proto.client_paused = function(client_id) {
			if(this.client_ids.hasOwnProperty(client_id)) {
				this.client_ids[client_id] = PAUSED;
			}
		};

		proto.client_resumed = function(client_id) {
			if(this.client_ids.hasOwnProperty(client_id)) {
				this.client_ids[client_id] = ACTIVE;
			}
		};
		proto.on_begin_destroy = function() {
			this._emit("begin_destroy");
			this.object.off("begin_destroy", this.on_begin_destroy, this);
			this.remove_emission_listeners();
			this.clear_fn_call_constraints();
		};
		proto.clear_fn_call_constraints = function() {
			this.fn_call_constraints.each(function(constraint_info, getting) {
				var constraint = constraint_info.constraint;
				constraint.destroy();
				this.fn_call_constraints.remove(getting);
			}, this);
		};

		proto.destroy = function () {
			this._emit("destroy");
			if(!this.object.destroyed) {
				this.object.off("begin_destroy", this.on_begin_destroy, this);
				this.object.off("destroyed", this.destroy, this);
				this.remove_emission_listeners();
			}
			this.clear_fn_call_constraints();
			this.fn_call_constraints.destroy();
			delete this.fn_call_constraints;
			able.destroy_this_listenable(this);
		};

		proto.type = function () {
			return this._type;
		};
		proto.get_object = function () {
			return this.object;
		};

		proto.on_emit = function () {
			this.remote_emit.apply(this, arguments);
		};

		proto.remote_emit = function () {
			var event_type = _.last(arguments);
			var args = _.first(arguments, arguments.length - 1);
			args = _.map(args, ist.summarize_value_for_comm_wrapper);
			this._emit("emit", {
				event_type: event_type,
				args: args
			});
		};

		proto.client_destroyed = function(pre_processed_getting, client_id) {
			var getting = process_args(pre_processed_getting);
			var constraint_info = this.fn_call_constraints.get(getting);
			
			if(constraint_info && constraint_info.clients.hasOwnProperty(client_id)) {
				delete constraint_info.clients[client_id];
				constraint_info.client_count--;
				if(constraint_info.client_count <= 0) {
					constraint_info.constraint.destroy();
					this.fn_call_constraints.remove(getting);
				}
			}
		};

		proto.request = function (pre_processed_getting, callback, create_constraint, client_id) {
			var getting = pre_processed_getting;
			var fn_name = getting[0];
			var args = _.rest(getting);
			var object = this.get_object();

			if (create_constraint) {
				var add_to_clients = true;
				var constraint_info = this.fn_call_constraints.get_or_put(getting, function () {
					var constraint = new cjs.Constraint(function () {
						var rv = object[fn_name].apply(object, args);
						return rv;
					});
					var on_change_listener = _.bind(function () {
						this._emit("changed", getting);
					}, this);
					constraint.onChange(on_change_listener);

					var old_destroy = constraint.destroy;
					constraint.destroy = function() {
						constraint.offChange(on_change_listener);
						old_destroy.call(constraint, true); // silent in case getter is syncronous
					};

					add_to_clients = false;

					var clients = {};
					clients[client_id] = ACTIVE;
					return {
						constraint: constraint,
						client_count: 1,
						clients: clients
					};
				}, this);

				if(add_to_clients) {
					if(!constraint_info.clients.hasOwnProperty(client_id)) {
						constraint_info.clients[client_id] = ACTIVE;
						constraint_info.client_count++;
					}
				}
				var constraint = constraint_info.constraint;

				callback(ist.summarize_value_for_comm_wrapper(constraint.get()));
			} else {
				var rv = object[fn_name].apply(object, args);
				callback(ist.summarize_value_for_comm_wrapper(rv));
			}
		};
	}(ist.WrapperServer));
		
	var process_arg = function (arg) {
		return arg;
	};
	var process_args = function (args) { return _.map(args, process_arg); };

	var chop = function (args) {
		return _.first(args, args.length - 1);
	};
	var last = function (args) {
		return _.last(args);
	};

	var make_async = function (object_func_name) {
		return function () {
			var args = chop(arguments),
				callback = last(arguments);

			var value = this.object[object_func_name].apply(this.object, args);
			callback(value);
		};
	};

	var argeq = function (arg1, arg2) {
		return arg1 === arg2;
	};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,window,RedMap */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var summarize_arg = function (arg) { return arg; };
	var summarize_args = function (args) { return _.map(args, summarize_arg); };
	var chop = function (args) {
		return _.first(args, args.length - 1);
	};
	var last = function (args) {
		return _.last(args);
	};

	var argeq = function (arg1, arg2) {
		return arg1 === arg2;
	};

	var client_id = 0;
	var message_id = 0;

	ist.WrapperClient = function (options) {
		able.make_this_listenable(this);
		this.paused = false;
		this.semaphore = 0;
		this.comm_mechanism = options.comm_mechanism;
		this.cobj_id = options.cobj_id;
		this.obj_id = options.obj_id;
		this._type = options.type;
		this.object_summary = options.object_summary;
		this.colloquial_name = this.object_summary.colloquial_name;
		this.program_state_client = options.program_state_client;

		this._id = client_id;
		client_id += 1;

		this.fn_call_constraints = new RedMap({
			hash: function (args) {
				return args[0];
			},
			equals: function (args1, args2) {
				var i, len = args1.length;
				if (len !== args2.length) {
					return false;
				} else {
					for (i = 0; i < len; i += 1) {
						if (!argeq(args1[i], args2[i])) {
							return false;
						}
					}
					return true;
				}
			}
		});
		//console.log('CLIENT:'+this.cobj_id);
	};

	(function (my) {
		var proto = my.prototype;
		able.make_proto_listenable(proto);

		proto.on_ready = function() {
			this.post({
				type: "register_listener",
				cobj_id: this.cobj_id
			});
		};
		proto.signal_interest = function() {
			if(++this.semaphore > 0) {
				this.resume();
			}
		};
		proto.signal_destroy = function() {
			if(--this.semaphore <= 0) {
				this.pause();
			}
		};

		proto.pause = function() {
			if(!this.paused) {
				this.paused = true;
				this.post({
					type: "pause"
				});
			}
		};
		proto.resume = function() {
			if(this.paused) {
				this.paused = false;
				this.post({
					type: "resume"
				});
			}
		};

		proto.destroy = function () {
			this._emit("wc_destroy");
			this.post({
				type: "destroy"
			});
			this.fn_call_constraints.each(function(constraint, args) {
				this.destroy_$(constraint, args);
			}, this);
			this.fn_call_constraints.destroy();
			delete this.fn_call_constraints;
			able.destroy_this_listenable(this);

			delete this.comm_mechanism;
			delete this.program_state_client;
			delete this.object_summary;
		};

		proto.post = function (message) {
			var m_id = message_id;
			message_id += 1;
			this.comm_mechanism.post({
				type: "wrapper_client",
				client_id: this.id(),
				message: message,
				message_id: m_id,
				cobj_id: this.cobj_id
			});
			return m_id;
		};
		proto.id = function () { return this._id; };
		if(ist.__debug) {
			proto.sid = function() { return parseInt(uid.strip_prefix(this.id()), 10); };
		}
		proto.type = function () { return this._type; };

		proto.async_get = function () {
			// doesn't store the value in a constraint; uses a callback when it's ready instead

			var args, callback, context;
			if(_.isFunction(arguments[arguments.length-2]) && !_.isFunction(arguments[arguments.length-1])) {
				callback = arguments[arguments.length-2];
				context = arguments[arguments.length-1];
				args = summarize_args(_.first(arguments, arguments.length - 2));
			} else {
				callback = arguments[arguments.length-1];
				context = window;
				args = summarize_args(_.first(arguments, arguments.length - 1));
			}

			var request_id = this.post({
				type: "async_get",
				getting: args
			});
			this.program_state_client.register_response_listener(request_id, _.bind(function (value) {
				var processed_value = this.process_value(value);
				callback.call(context, processed_value);
			}, this));
		};

		proto.destroy_$ = function(constraint, args) {
			var request_ids = constraint.request_ids;
			_.each(constraint.request_ids, function(request_id) {
				this.program_state_client.deregister_response_listener(request_id);
			}, this);
			delete constraint.request_ids;
			this.fn_call_constraints.remove(args);
			this.post({
				getting: args,
				type: "destroy_$"
			});
		};

		proto.get_$ = function () {
			var args = summarize_args(arguments);
			var to_update = false;
			var self = this;
			var constraint = this.fn_call_constraints.get_or_put(args, function () {
				var rv = new cjs.Constraint();
				var id = rv._id;
				var old_destroy = rv.destroy;
				rv.destroy = function() {
					self.destroy_$(rv, args);
					old_destroy.apply(rv, arguments);
					self = rv = constraint = null;
				};
				var semaphore = 0;
				rv.signal_interest = function() { semaphore++; };
				rv.signal_destroy = function() {
					if(--semaphore <= 0) {
						rv.destroy();
					}
				};

				rv.request_ids = {};

				to_update = true;
				return rv;
			});
			constraint.signal_interest();
			if (to_update) {
				this.update(args, constraint);
			}
			return constraint;
		};


		proto.update = function (args, constraint) {
			constraint = constraint || this.fn_call_constraints.get(args);

			if(!constraint) { return false; } // bandaid for removed properties

			var request_id = this.post({
				type: "get_$",
				getting: args
			});
			constraint.request_ids[request_id] = request_id;
			this.program_state_client.register_response_listener(request_id, _.bind(function (value) {
				delete constraint.request_ids[request_id];
				constraint.set(this.process_value(value));
			}, this));
		};

		proto.on_change = function () {
			var args = summarize_args(arguments);
			//var constraint = this.fn_call_constraints.get(args);
			//if (constraint) { constraint.invalidate(); }
			// Why update now when you can update when ready?
			
			this.update(args);
		};
		proto.on_emit = function (event_type) {
			var args = _.rest(arguments);
			args = this.process_value(args);

			//console.log(event_type);
			this._emit.apply(this, ([event_type]).concat(args));
		};
		proto.process_value = function (value) {
			if (value && value.__type__ && value.__type__ === "summarized_obj") {
				var val = value.__value__;
				var object_summary, wrapper_client;
				if (val === "function") {
					return "(native function)";
				} else if (val === "cjs_object") {
					return "(native object)";
				} else if (val === "contextual_obj") {
					object_summary = value.object_summary;
					wrapper_client = this.program_state_client.get_wrapper_client(object_summary, this.comm_mechanism);
					return wrapper_client;
				} else if (val === "state") {
					object_summary = value.object_summary;
					wrapper_client = this.program_state_client.get_wrapper_client(object_summary, this.comm_mechanism);
					return wrapper_client;
				} else if (val === "transition") {
					object_summary = value.object_summary;
					wrapper_client = this.program_state_client.get_wrapper_client(object_summary, this.comm_mechanism);
					return wrapper_client;
				} else if (val === "event") {
					object_summary = value.object_summary;
					wrapper_client = this.program_state_client.get_wrapper_client(object_summary, this.comm_mechanism);
					return wrapper_client;
				} else if (val === "client_wrapper") {
					return "(communication wrapper)";
				} else if (val === "constraint") {
					return "(cjs constraint)";
				} else if(val === "dom_elem") {
					return "(dom element)";
				}

				return val;
			} else if (_.isArray(value)) {
				return _.map(value, _.bind(this.process_value, this));
			} else if (_.isObject(value)) {
				var rv = {};
				_.each(value, function (v, k) { rv[k] = this.process_value(v); }, this);
				return rv;
			} else {
				return value;
			}
		};
	}(ist.WrapperClient));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var statecharts = {};

	ist.create_remote_statechart = function (wrapper_client, statechart_parent) {
		var id = wrapper_client.cobj_id;
		var statechart = ist.find_uid(id);
		var is_active, is_active_value, is_running, is_running_value, promises, listeners;
		var destroyed = false;
		
		statechart = false;
		if (!statechart) {
			wrapper_client.signal_interest();
			if (statecharts.hasOwnProperty(id)) {
				statechart = statecharts[id];
				if (statechart_parent && statechart.parent() !== statechart_parent) {
					statechart.set_parent(statechart_parent);
				}
			} else {
				var type = wrapper_client.type();
				if (type === "statechart") {
					statechart = statecharts[id] = new ist.Statechart({
						avoid_constructor: true
					});
					statechart.puppet_master_id = id;
					var substates = _.Deferred();
					var substates_value;
					var substate_promises = [];
					wrapper_client.async_get('get_substates', function (substate_wrappers) {
						substates_value = cjs.map({ });

						_.each(substate_wrappers, function (substate_wrapper, name) {
							var substate = ist.create_remote_statechart(substate_wrapper, statechart);
							substates_value.put(name, substate);
							if (!substate.is_constructed()) {
								var substate_promise = _.Deferred();
								substate_promises.push(substate_promise.promise());
								substate.once("_constructed", function () {
									substate_promise.resolve();
								});
							}
						});
						substates.resolve();
					});

					var start_state = _.Deferred();
					var start_state_value;
					wrapper_client.async_get('get_start_state', function (substate_wrapper) {
						start_state_value = ist.create_remote_statechart(substate_wrapper, statechart);
						if(!start_state_value.is_constructed()) {
							var start_state_promise = _.Deferred();
							substate_promises.push(start_state_promise.promise());
							start_state_value.once("_constructed", function () {
								start_state_promise.resolve();
							});
						}
						start_state.resolve();
					});


					var outgoing_transitions = _.Deferred();
					var outgoing_transitions_value;
					wrapper_client.async_get('get_outgoing_transitions', function (transition_wrappers) {
						var outgoing_transitions_value_arr = _.map(transition_wrappers, function (transition_wrapper, name) {
							var transition = ist.create_remote_transition(transition_wrapper);
							return transition;
						});
						outgoing_transitions_value = cjs.array({value: outgoing_transitions_value_arr});
						outgoing_transitions.resolve();
					});

					var incoming_transitions = _.Deferred();
					var incoming_transitions_value;
					wrapper_client.async_get('get_incoming_transitions', function (transition_wrappers) {
						var incoming_transitions_value_arr = _.map(transition_wrappers, function (transition_wrapper, name) {
							var transition = ist.create_remote_transition(transition_wrapper);
							return transition;
						});
						incoming_transitions_value = cjs.array({value: incoming_transitions_value_arr});
						incoming_transitions.resolve();
					});

					var is_concurrent = _.Deferred();
					var is_concurrent_value;
					wrapper_client.async_get('is_concurrent', function (is_it) {
						is_concurrent_value = is_it;
						is_concurrent.resolve();
					});

					is_active = _.Deferred();
					wrapper_client.async_get('is_active', function (is_it) {
						is_active_value = is_it;
						is_active.resolve();
					});

					is_running = _.Deferred();
					wrapper_client.async_get('is_running', function (is_it) {
						is_running_value = is_it;
						is_running.resolve();
					});

					promises = [substates.promise(), outgoing_transitions.promise(),
									incoming_transitions.promise(), is_concurrent.promise(),
									is_active.promise(), start_state.promise(), is_running.promise()];

					listeners = {
						add_substate: function(event) {
							var state_name = event.state_name,
								index = event.index,
								state_wrapper_client = event.state;
							var substate = ist.create_remote_statechart(state_wrapper_client, statechart);
							statechart.add_substate(state_name, substate, index);
						},
						remove_substate: function (event) {
							var state_name = event.name;
							statechart.remove_substate(state_name, undefined, false);
						},
						rename_substate: function (event) {
							var from_name = event.from,
								to_name = event.to;
							statechart.rename_substate(from_name, to_name);
						},
						move_substate: function (event) {
							var state_name = event.state_name,
								index = event.index;
							statechart.move_state(state_name, index);
						},
						make_concurrent: function (event) {
							statechart.make_concurrent(event.concurrent);
						},
						destroy: function (event) {
							statechart.destroy();
						},
						add_transition: function (event) {
							var transition_wrapper_client = event.transition,
								from_state_wrapper_client = event.from_state,
								to_state_wrapper_client = event.to_state,
								from_state = ist.create_remote_statechart(from_state_wrapper_client),
								to_state = ist.create_remote_statechart(to_state_wrapper_client),
								transition = ist.create_remote_transition(transition_wrapper_client);

							from_state._add_direct_outgoing_transition(transition);
							to_state._add_direct_incoming_transition(transition);
						},
						active: function(event) {
							statechart.set_active(true);
						},
						inactive: function (event) {
							statechart.set_active(false);
						},
						run: function(event) {
							statechart.run();
						},
						stop: function(event) {
							statechart.stop();
						}
					};
					_.when(promises).done(function () {
						if(statechart.destroyed) { return; }

						_.when(substate_promises).done(function () {
							if(destroyed) { return; }
							ist.Statechart.call(statechart, {
								substates: substates_value,
								concurrent: is_concurrent_value,
								outgoing_transitions: outgoing_transitions_value,
								incoming_transitions: incoming_transitions_value,
								parent: statechart_parent,
								start_state: start_state_value,
								active: is_active_value,
								puppet: true,
								running: is_running_value
							});
							wrapper_client.on(listeners);
							if(statechart_parent) {
								statechart._emit("_constructed");
							}
						});
					});
				} else {
					statechart = statecharts[id] = new ist.StartState({
							avoid_constructor: true
						});
					statechart.puppet_master_id = id;

					var outgoing_transition = _.Deferred();
					var outgoing_transition_value;
					listeners = {
						active: function(event) {
							statechart.set_active(true);
						},
						inactive: function (event) {
							statechart.set_active(false);
						},
						run: function(event) {
							statechart.run();
						},
						stop: function(event) {
							statechart.stop();
						}

					};

					wrapper_client.async_get('get_outgoing_transition', function (transition_wrapper) {
						outgoing_transition_value = ist.create_remote_transition(transition_wrapper);

						// Wait for a resolution so that we can know if the to state is me
						if(outgoing_transition_value.is_initialized()) {
							outgoing_transition.resolve();
						} else {
							outgoing_transition_value.once("_constructed", function() {
								outgoing_transition.resolve();
							});
						}
					});

					is_active = _.Deferred();
					wrapper_client.async_get('is_active', function (is_it) {
						is_active_value = is_it;
						is_active.resolve();
					});

					is_running = _.Deferred();
					wrapper_client.async_get('is_running', function (is_it) {
						is_running_value = is_it;
						is_running.resolve();
					});

					promises = [outgoing_transition.promise(), is_active.promise(), is_running.promise()];
					_.when(promises).done(function () {
						if(statechart.destroyed) { return; }
						ist.StartState.call(statechart, {
								outgoing_transition: outgoing_transition_value,
								parent: statechart_parent,
								active: is_active_value,
								puppet: true,
								running: is_running_value
							});
						statechart._emit("_constructed");
						wrapper_client.on(listeners);
					});
				}
			}
			var on_destroy = function() {
				destroyed = true;
				statechart.off("destroy", on_destroy);
				wrapper_client.off(listeners);
				//wrapper_client.signal_destroy();
				delete statecharts[id];
			};
			statechart.on("destroy", on_destroy);
			if(!statechart_parent) {
				wrapper_client.on("wc_destroy", function() {
					if(!statechart.destroyed) {
						statechart.destroy();
					}
				});
			}
		}
		return statechart;
	};

	var transitions = {};

	ist.create_remote_transition = function (wrapper_client) {
		var id = wrapper_client.cobj_id;
		var transition = ist.find_uid(id);
		var listeners;
		transition = false;
		var destroyed = false;
		if (!transition) {
			wrapper_client.signal_interest();
			if (transitions.hasOwnProperty(id)) {
				transition = transitions[id];
			} else {
				transition = transitions[id] = new ist.StatechartTransition({
							avoid_constructor: true
						});
				transition.puppet_master_id = id;

				var from = _.Deferred();
				var from_value;
				wrapper_client.async_get('from', function (state_wrapper) {
					from_value = ist.create_remote_statechart(state_wrapper);
					from.resolve();
				});

				var to = _.Deferred();
				var to_value;
				wrapper_client.async_get('to', function (state_wrapper) {
					to_value = ist.create_remote_statechart(state_wrapper);
					to.resolve();
				});

				var event = _.Deferred();
				var event_value;
				wrapper_client.async_get('event', function (event_wrapper) {
					event_value = ist.create_remote_event(event_wrapper);
					event.resolve();
				});
				listeners = {
					setTo: function (event) {
						var state_client_wrapper = event.state,
							state = ist.create_remote_statechart(state_client_wrapper);
						transition.setTo(state);
					},
					setFrom: function (event) {
						var state_client_wrapper = event.state,
							state = ist.create_remote_statechart(state_client_wrapper);
						transition.setFrom(state);
					},
					remove: function (event) {
						transition.remove();
					},
					destroy: function (event) {
						transition.destroy();
					},
					fire: function (event) {
						var e = event.event;
						transition.fire(e);
					}
				};
				var promises = [from.promise(), to.promise(), event.promise()];
				_.when(promises).done(function () {
					if(destroyed) { return; }
					ist.StatechartTransition.call(transition, {
							from: from_value,
							to: to_value,
							event: event_value,
							puppet: true
						});
					transition._emit("_constructed");
					wrapper_client.on(listeners);
				});
			}

			var on_destroy = function() {
				wrapper_client.off(listeners);
				transition.off("destroy", on_destroy);
				wrapper_client.signal_destroy();
				delete transitions[id];
			};
			transition.on("destroy", on_destroy);
		}
		return transition;
	};

	var events = {};

	ist.create_remote_event = function (wrapper_client) {
		var id = wrapper_client.cobj_id;
		var event = ist.find_uid(id);
		var listeners;
		var destroyed = false;
		event = false;
		if (!event) {
			wrapper_client.signal_interest();
			if (events.hasOwnProperty(id)) {
				event = events[id];
				listeners = {};
			} else {
				var event_type = wrapper_client.object_summary.event_type;

				if(event_type === "statechart_event") {
					event = events[id] = new ist.StatechartEvent({inert: true});
				} else if (event_type === "parsed_event") {
					event = events[id] = new ist.ParsedEvent({inert: true});
					var str_val = "";
					wrapper_client.async_get("get_str", function (str) {
						if(destroyed) { return; }
						event.set_str(str);
					});
					var $errors = wrapper_client.get_$("get_errors");
					var live_errors = cjs.liven(function() {
						if(destroyed) { return; }
						var errors = $errors.get();
						if(errors && errors.length > 0) {
							event.$errors.set(errors);
							event._has_errors = true;
						} else {
							if(event._has_errors) {
								event.$errors.set([]);
								event._has_errors = false;
							}
						}
					}, {
						destroy: function() {
							$errors.signal_destroy();
							$errors = null;
						}
					});
					listeners = {
						setString: function (e) {
							var str = e.to;
							event.set_str(str);
						}
					};

					wrapper_client.on(listeners);
				}
			}

			var on_destroy = function() {
				destroyed = true;
				if(live_errors) {
					live_errors.destroy();
					live_errors = null;
				}
				wrapper_client.off(listeners);
				event.off("destroy", on_destroy);
				wrapper_client.signal_destroy();
				delete events[id];
			};
			event.on("destroy", on_destroy);
		}
		return event;
	};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,jQuery,window */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.ProgramStateClient = function (options) {
		able.make_this_listenable(this);
		this.comm_mechanism = options.comm_mechanism;
		this.wrapper_clients = {};
		this.clients = {};
		this.response_listeners = {};
		this.pending_responses = {};
		this.loaded = false;

		if (options.ready_func === true) {
			var old_ready = window.ready;
			window.ready = _.bind(function () {
				this.on_loaded();
				window.ready = old_ready;
			}, this);
		} else {
			if (window.document.readyState === "complete") {
				_.defer(_.bind(this.on_loaded, this), this);
			} else {
				window.addEventListener("load", _.bind(this.on_loaded, this));
			}
		}

		this.info_servers = {};
		this.comm_mechanism	.on("croot", this.on_croot, this)
							.on("response", this.on_response, this)
							.on("cobj_links", this.on_cobj_links, this)
							.on("wrapper_server", this.on_wrapper_server, this)
							.on("stringified_root", this.post_forward, this)
							.on("get_ptr_response", this.post_forward, this)
							.on("inspect", this.post_forward, this)
							.on("stringified_obj", this.post_forward, this);
	};

	(function (my) {
		var proto = my.prototype;
		able.make_proto_listenable(proto);

		proto.on_loaded = function () {
			if(!this.loaded) {
				this.loaded = true;
				this.add_message_listener();
				this.post({
					type: "ready"
				});
			}
		};

		proto.add_message_listener = function () {
			this.comm_mechanism.on("message", this.on_message, this);
		};
		proto.remove_message_listener = function () {
			this.comm_mechanism.off("message", this.on_message, this);
		};

		proto.disconnect = function() {
			this.destroy_every_client();
			this.post({type: "disconnect"});
		};

		proto.destroy_every_client = function() {
			_.each(this.clients, function(client, client_id) {
				client.destroy();
				delete this.clients[client_id];
			}, this);
		};

		proto.post_forward = function(event) {
			this._emit(event.type, event);
		};

		var DEREGISTERED = {};
		proto.on_croot = function(message) {
			if(this.root_client) {
				this._emit("root_changed", message);
			}

			var summary = message.summary,
				info_server_info = message.info_servers;

			if(summary) {
				this.root_client = this.get_wrapper_client(summary);
				_.each(message.info_servers, function(id, name) {
					this.info_servers[name] = new ist.RemoteConstraintClient(id);
					this.info_servers[name].set_communication_mechanism(this.comm_mechanism);
				}, this);
			}

			this._emit("loaded", this.root_client, this.info_servers);
			this.post({type: "loaded"});
			
			this.clist = $("<div />").appendTo(this.element).component_list({
				info_servers: this.info_servers
			});
		};
		proto.on_wrapper_server = function(message) {
			if(this.clients) { // I haven't been destroyed
				var server_message = message.server_message,
					client_id = server_message.client_id,
					smtype = server_message.type,
					client = this.clients[client_id];

				if(client) {
					if (smtype === "changed") {
						client.on_change.apply(client, server_message.getting);
					} else if (smtype === "emit") {
						client.on_emit.apply(client, ([server_message.event_type]).concat(server_message.args));
					}
				}
			}
		};
		proto.on_response = function(message) {
			var request_id = message.request_id,
				response = message.response;
			if (this.response_listeners.hasOwnProperty(request_id)) {
				var response_listener = this.response_listeners[request_id];
				if(response_listener !== DEREGISTERED) {
					response_listener(response);
				}
				delete this.response_listeners[request_id];
			} else {
				this.pending_responses[request_id] = response;
			}
		};
		proto.on_cobj_links = function(message) {
			this._emit("cobj_links", message);
		};

		proto.register_response_listener = function (id, listener) {
			if (this.pending_responses.hasOwnProperty(id)) {
				listener(this.pending_responses[id]);
				delete this.pending_responses[id];
			} else {
				this.response_listeners[id] = listener;
			}
		};
		proto.deregister_response_listener = function(id) {
			if (this.pending_responses.hasOwnProperty(id)) {
				delete this.pending_responses[id];
			}
			if (this.response_listeners.hasOwnProperty(id)) {
				this.response_listeners[id] = DEREGISTERED; // don't want it added to pending when we get a response
			}
		};

		proto.get_wrapper_client = function(object_summary) {
			var cobj_id = object_summary.id;
			var rv;
			if(this.wrapper_clients.hasOwnProperty(cobj_id)) {
				rv = this.wrapper_clients[cobj_id];
				rv.object_summary = object_summary;
				return rv;
			} else {
				var otype = object_summary.type;

				var obj_id = object_summary.obj_id;
				rv = new ist.WrapperClient({
					comm_mechanism: this.comm_mechanism,
					cobj_id: cobj_id,
					obj_id: obj_id,
					type: otype,
					object_summary: object_summary,
					program_state_client: this
				});

				var client_id = rv.id();

				this.clients[client_id] = rv;
				this.wrapper_clients[cobj_id] = rv;

				rv.on_ready();

				var on_destroy = _.bind(function() {
					rv.off("wc_destroy", on_destroy);
					this.destroy_wrapper_client(client_id, cobj_id);
				}, this);

				rv.on("wc_destroy", on_destroy);

				return rv;
			}
		};

		proto.destroy_wrapper_client = function(client_id, cobj_id) {
			delete this.clients[client_id];
			delete this.wrapper_clients[cobj_id];
		};

		proto.destroy = function (dont_destroy_comm_wrapper) {
			this.disconnect();
			able.destroy_this_listenable(this);
			this.remove_message_listener();

			this.destroy_every_client();
			delete this.wrapper_clients;
			delete this.clients;

			delete this.root_client;

			if(dont_destroy_comm_wrapper !== false && this.comm_mechanism) {
				this.comm_mechanism.destroy();
				delete this.comm_mechanism;
			}
		};

		proto.post = function (message, callback) {
			this.comm_mechanism.post(message, callback);
		};

		proto.post_command = function (command, callback) {
			var stringified_command;
			if ((["undo", "redo", "reset", "export", "upload", "store"]).indexOf(command) >= 0) {
				stringified_command = command;
			} else {
				stringified_command = ist.stringify(command);
			}
			this.post({
				type: "command",
				command: stringified_command
			}, callback);
			return stringified_command;
		};
	}(ist.ProgramStateClient));

	ist.indirectClient = function(client_constraint) {
		var client_val = cjs.get(client_constraint),
			old_client = client_val,
			prop_names = _.rest(arguments),
			client_is_valid, rv, is_arr = prop_names.length !== 1;

		if (client_val instanceof ist.WrapperClient) {
			client_val.signal_interest();
			client_is_valid = true;
		} else {
			client_is_valid = false;
		}

		if(is_arr) {
			rv = cjs.map({
				keys: _.map(prop_names, function(prop_name) {
					return _.isArray(prop_name) ? prop_name[0] : prop_name;
				}),
				values: _.map(prop_names, function(prop_name) {
					var args = _.isArray(prop_name) ? prop_name : [prop_name];
					return (client_val instanceof ist.WrapperClient) ? client_val.get_$.apply(client_val, args) : false;
				})
			});
		} else {
			var args = _.isArray(prop_names[0]) ? prop_names[0] : [prop_names[0]];
			rv = cjs.constraint((client_val instanceof ist.WrapperClient) ? client_val.get_$.apply(client_val, args) : false);
		}
		
		var on_change_fn = function() {
			old_client = client_val;
			var client_was_valid = old_client instanceof ist.WrapperClient;

			client_val = cjs.get(client_constraint);
			client_is_valid = client_val instanceof ist.WrapperClient;

			if(is_arr) {
				_.each(prop_names, function(prop_name) {
					if(client_val instanceof ist.WrapperClient) {
						var args = _.isArray(prop_name) ? prop_name : [prop_name];
						rv.put(args[0], client_val.get_$.apply(client_val, args));

						if(rv.do_debug) {
							console.log(prop_name, args);
						}
					} else {
						rv.remove(prop_name);
					}
				});
			} else {
				if(client_val instanceof ist.WrapperClient) {
					var args = _.isArray(prop_names[0]) ? prop_names[0] : [prop_names[0]];
					rv.set(client_val.get_$.apply(client_val, args));
				} else {
					rv.set(false);
				}
			}

			if(client_is_valid && !client_was_valid) {
				client_val.signal_interest();
			} else if(client_was_valid && !client_is_valid) {
				old_client.signal_destroy();
			} else if(client_was_valid && client_is_valid) {
				if(old_client !== client_val) {
					old_client.signal_destroy();
					client_val.signal_interest();
				}
			}
		};

		if(cjs.isConstraint(client_constraint)) {
			client_constraint.onChange(on_change_fn);
		}

		var old_destroy = rv.destroy;
		rv.destroy = function() {
			if(cjs.isConstraint(client_constraint)) {
				client_constraint.offChange(on_change_fn);
			}
			old_destroy.apply(rv, arguments);
			if(client_val instanceof ist.WrapperClient) {
				client_val.signal_destroy();
			}
		};

		return rv;
	};
}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,jQuery,window */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.ProgramStateServer = function (options) {
		able.make_this_listenable(this);
		this.root = options.root;
		if(this.root) {
			this.contextual_root = ist.find_or_put_contextual_obj(this.root);
		}
		this.command_stack = options.command_stack;
		this.connected = false;
		this.wrapper_servers = {};

		this.full_programs = ist.getSavedProgramMap();
		this.program_components = ist.getSavedProgramMap("component");
		this.$dirty_program = options.dirty_program;

		this.$programs = cjs(function() {
								return this.full_programs.keys();
							}, {context: this});

		this.$components = cjs(function() {
								return this.program_components.keys();
							}, {context: this});
		this.info_servers = {
			programs: new ist.RemoteConstraintServer(this.$programs),
			components: new ist.RemoteConstraintServer(this.$components),
			loaded_program: new ist.RemoteConstraintServer(ist.loaded_program_name),
			undo_description: new ist.RemoteConstraintServer(this.command_stack.$undo_description),
			redo_description: new ist.RemoteConstraintServer(this.command_stack.$redo_description),
			dirty_program: new ist.RemoteConstraintServer(this.$dirty_program)
		};
	};

	(function (my) {
		var proto = my.prototype;
		able.make_proto_listenable(proto);

		proto.add_message_listeners = function () {
			this.comm_mechanism	.on("ready", this.on_ready, this)
								.on("loaded", this.on_loaded, this)
								.on("message", this.on_message, this)
								.on("disconnect", this.on_disconnect, this)
								.on("command", this.on_command, this)
								.on("wrapper_client", this.on_wrapper_client, this)
								.on("remove_storage", this.on_remove_storage, this)
								.on("save_curr", this.post_forward, this)
								.on("save_curr_as", this.post_forward, this)
								.on("create_program", this.post_forward, this)
								.on("download_program", this.download_program, this)
								.on("upload_program", this.download_program, this)
								.on("load_program", this.load_program, this)
								.on("stringified_root", this.post_forward, this)
								.on("load_file", this.post_forward, this)
								.on("save_component", this.post_forward, this)
								.on("copy_component", this.post_forward, this)
								.on("rename_program", this.post_forward, this)
								.on("add_highlight", this.post_forward, this)
								.on("remove_highlight", this.post_forward, this)
								.on("get_ptr", this.get_ptr, this)
								;
		};
		proto.remove_message_listeners = function () {
			if(this.comm_mechanism) {
				this.comm_mechanism	.off("ready", this.on_ready, this)
									.off("loaded", this.on_loaded, this)
									.off("message", this.on_message, this)
									.off("disconnect", this.on_disconnect, this)
									.off("command", this.on_command, this)
									.off("wrapper_client", this.on_wrapper_client, this)
									.off("remove_storage", this.on_remove_storage, this)
									.off("save_curr", this.post_forward, this)
									.off("save_curr_as", this.post_forward, this)
									.off("create_program", this.post_forward, this)
									.off("download_program", this.download_program, this)
									.off("upload_program", this.download_program, this)
									.off("load_program", this.load_program, this)
									.off("stringified_root", this.post_forward, this)
									.off("load_file", this.post_forward, this)
									.off("save_component", this.post_forward, this)
									.off("copy_component", this.post_forward, this)
									.off("rename_program", this.post_forward, this)
									.off("get_ptr", this.get_ptr, this)
									;
			}
		};
		proto.post_forward = function(event) {
			this._emit(event.type, event);
		};
		proto.on_remove_storage = function(event) {
			ist.rm(event.name, event.storage_type==="component" ? "component" : "");
		};
		proto.on_save_curr = function(event) {
			ist.save(this.root, event.name, event.storage_type==="component" ? "component" : "");
		};
		proto.get_ptr = function(event) {
			var cobj_id = event.cobj_id,
				cobj = ist.find_uid(cobj_id);

			if(cobj) {
				var pointer = cobj.get_pointer();

				this.post({
					type: "get_ptr_response",
					cobj_id: cobj_id,
					cobjs: _.map(pointer.getContextualObjects(), function(x) {
						return x.summarize();
					})
				});
			}
		};
		proto.download_program = function(event) {
			this._emit("download_program", event.name, event.storage_type==="component" ? "component" : "");
		};
		proto.upload_program = function(event) {
			console.log("upload", event);
		};
		proto.load_program = function(event) {
			this._emit("load_program", event.name);
		};

		proto.set_communication_mechanism = function(comm_mechanism) {
			if(this.comm_mechanism) {
				this.remove_message_listeners();
				delete this.comm_mechanism;
			}
			this.comm_mechanism = comm_mechanism;
			this.add_message_listeners();
			_.each(this.info_servers, function(info_server) {
				info_server.set_communication_mechanism(comm_mechanism);
			});
		};

		proto.set_root = function(new_root) {
			this.destroy_every_wrapper_server();

			this.root = new_root;
			this.contextual_root = ist.find_or_put_contextual_obj(this.root);

			this.send_info();
		};

		proto.send_info = function() {
			var croot_summary = this.contextual_root ? this.contextual_root.summarize() : null,
				info_servers = {};
			_.each(this.info_servers, function(info_server, name) {
				info_servers[name] = info_server.id();
			});
			this.post({
				type: "croot",
				summary: croot_summary,
				info_servers: info_servers
			});
		};

		proto.on_ready = function() {
			this.connected = true;
			this.send_info();
		};

		proto.on_loaded = function() {
			this._emit("connected");
		};
		proto.on_disconnect = function() {
			_.each(this.wrapper_servers, function(wrapper_server, cobj_id) {
				if(!wrapper_server.has_clients()) {
					wrapper_server.destroy();
					delete this.wrapper_servers[cobj_id];
				}
			}, this);
			this.cleanup_closed_client();
			this._emit("disconnected");
		};

		proto.on_command = function(data) {
			var stringified_command = data.command;
			if ((["undo", "redo", "reset", "export", "upload", "store"]).indexOf(stringified_command) >= 0) {
				this._emit("command", stringified_command);
			} else {
				var command = ist.destringify(stringified_command);
				this._emit("command", command);
			}
		};
		proto.on_wrapper_client = function(wc_message) {
			var message = wc_message.message;
			var mtype = message.type;
			var wrapper_server, cobj_id, client_id, server, cobj;
			if (mtype === "register_listener") {
				cobj_id = message.cobj_id;
				cobj = ist.find_uid(cobj_id);
				client_id = wc_message.client_id;

				server = this.get_wrapper_server(cobj, client_id);
				server.on("emit", _.bind(function(evt) {
					var full_message = {
						type: "wrapper_server",
						server_message: _.extend({type: "emit", client_id: client_id}, evt)
					};
					this.post(full_message);
				},this)).on("changed", _.bind(function(getting) {
					var full_message = {
						type: "wrapper_server",
						server_message: {
							type: "changed",
							cobj_id: cobj_id,
							getting: getting,
							client_id: client_id
						}
					};
					this.post(full_message);
				}, this));
			} else if (mtype === "get_$" || mtype === "async_get") { // async request
				cobj_id = wc_message.cobj_id;
				cobj = ist.find_uid(cobj_id);
				client_id = wc_message.client_id;
				var request_id = wc_message.message_id;
				if(cobj) {
					server = this.get_wrapper_server(cobj, client_id);

					var create_constraint = message.type === "get_$";

					server.request(message.getting, _.bind(function (response) {
						this.post({
							type: "response",
							request_id: request_id,
							client_id: client_id,
							response: response
						});
					}, this), create_constraint, client_id);
				} else {
					this.post({
						type: "response",
						request_id: request_id,
						client_id: client_id,
						error: "cobj_destroyed"
					});
				}
			} else if(mtype === "destroy_$") {
				cobj_id = wc_message.cobj_id;
				client_id = wc_message.client_id;

				if (this.wrapper_servers.hasOwnProperty(cobj_id)) {
					wrapper_server = this.wrapper_servers[cobj_id];
					wrapper_server.client_destroyed(message.getting, client_id);
				}
			} else if(mtype === "destroy") {
				cobj_id = wc_message.cobj_id;
				client_id = wc_message.client_id;

				if (this.wrapper_servers.hasOwnProperty(cobj_id)) {
					wrapper_server = this.wrapper_servers[cobj_id];
					wrapper_server.remove_client_id(client_id);
					if(!wrapper_server.has_clients()) {
						wrapper_server.destroy();
						delete this.wrapper_servers[cobj_id];
					}
				}
			} else if(mtype === "pause") {
				cobj_id = wc_message.cobj_id;
				client_id = wc_message.client_id;

				if (this.wrapper_servers.hasOwnProperty(cobj_id)) {
					wrapper_server = this.wrapper_servers[cobj_id];
					wrapper_server.client_paused(cobj_id);
				}
			} else if(mtype === "resume") {
				if (this.wrapper_servers.hasOwnProperty(cobj_id)) {
					wrapper_server = this.wrapper_servers[cobj_id];
					wrapper_server.client_resumed(cobj_id);
				}
			}
		};

		proto.get_wrapper_server = function(object, client_id) {
			var id = object.id();
			var rv;
			if (this.wrapper_servers.hasOwnProperty(id)) {
				rv = this.wrapper_servers[id];
				rv.add_client_id(client_id);
				return rv;
			} else {
				var listen_to;
				if (object instanceof ist.State) {
					listen_to = ["add_transition", "add_substate", "remove_substate",
										"rename_substate", "move_substate", "make_concurrent",
										/*"on_transition", "off_transition",*/ "destroy",
										"active", "inactive", "run", "stop"];
				} else if (object instanceof ist.StatechartTransition) {
					listen_to = ["setTo", "setFrom", "remove", "destroy", "fire", "enable", "disable"];
				} else if (object instanceof ist.ParsedEvent) {
					listen_to = ["setString"];
				} else {
					listen_to = ['destroy', 'begin_destroy'];
				}
				
				rv = new ist.WrapperServer({
					object: object,
					listen_to: listen_to,
					client_ids: [client_id]
				});
				rv.on("destroy", this.wrapper_server_destroyed, this, rv, id);

				this.wrapper_servers[id] = rv;
				return rv;
			}
		};

		proto.wrapper_server_destroyed = function(wrapper_server, id) {
			wrapper_server.off("destroy", this.wrapper_server_destroyed);
			delete this.wrapper_servers[id];
		};

		proto.post = function (message) {
			if (this.connected) {
				//console.log(message);
				this.comm_mechanism.post(message);
			} else {
				throw new Error("Trying to send a message to a disconnected client");
			}
		};

		proto.is_connected = function () {
			return this.connected;
		};

		proto.cleanup_closed_client = function () {
			this.connected = false;
		};

		proto.destroy_every_wrapper_server = function() {
			_.each(this.wrapper_servers, function(wrapper_server, cobj_id) {
				wrapper_server.destroy();
				delete this.wrapper_servers[cobj_id];
			}, this);
		};

		proto.destroy = function (dont_destroy_comm_wrapper) {
			this.cleanup_closed_client();
			able.destroy_this_listenable(this);
			this.remove_message_listeners();

			this.destroy_every_wrapper_server();

			_.each(this.info_servers, function(info_server) {
				info_server.destroy();
			});

			this.$programs.destroy();
			this.$components.destroy();
			delete this.$programs._options;
			delete this.$components._options;
			delete this.wrapper_servers;
			delete this.root;
			delete this.contextual_root;
			delete this.command_stack;

			if(dont_destroy_comm_wrapper !== false && this.comm_mechanism) {
				this.comm_mechanism.destroy();
				delete this.comm_mechanism;
			}
		};
	}(ist.ProgramStateServer));

}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;

    ist.Command = function (options) {
        this._in_effect = options && options.in_effect === true;
		this._undoable = true;
    };
    
    (function (My) {
        var proto = My.prototype;
		proto.is_undoable = function() {
			return this._undoable;
		};
        proto._do = function () {
            this._in_effect = true;
            this._execute();
        };
        proto._undo = function () {
            this._in_effect = false;
            this._unexecute();
        };
        proto.destroy = function () {
            this._do_destroy(this.in_effect());
        };
        proto.in_effect = function () {
            return this._in_effect;
        };
    
        proto._execute = function () { };
        proto._unexecute = function () { };
        proto._do_destroy = function (in_effect) {};
        proto.to_undo_string = function () {
            return "Undo";
        };
        proto.to_redo_string = function () {
            return "Redo";
        };
    }(ist.Command));

}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;
    
    // === SET ===
    
    ist.SetPropCommand = function (options) {
        ist.SetPropCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.parent || !this._options.value) {
            throw new Error("Must select a parent object");
        }
    
    
        this._parent = this._options.parent;
        if (!this._options.name && this._parent instanceof ist.Dict) {
            var parent = this._parent;
            var prop_names = parent._get_direct_prop_names();
            var prefix = "prop";
            if (this._options.value instanceof ist.Dict) {
                prefix = "obj";
            }
            var original_new_prop_name = prefix + "_" +  prop_names.length;
            var new_prop_name = original_new_prop_name;
            var i = 0;
            while (_.indexOf(prop_names, new_prop_name) >= 0) {
                new_prop_name = original_new_prop_name + "_" + i;
                i += 1;
            }
            this._prop_name = new_prop_name;
        } else {
            this._prop_name = this._options.name;
        }
        this._prop_value = this._options.value;
        this._prop_index = this._options.index;
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            var index;
            if (_.isNumber(this._prop_index)) {
                index = this._prop_index;
            }
            this._old_prop_value = this._parent._get_direct_prop(this._prop_name);
            this._parent.set_prop(this._prop_name, this._prop_value, {index: index});
        };
        proto._unexecute = function () {
            if (!_.isUndefined(this._old_prop_value)) {
                this._parent.set_prop(this._prop_name, this._old_prop_value);
            } else {
                this._parent.unset_prop(this._prop_name);
            }
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (in_effect) {
                if (this._old_prop_value && this._old_prop_value.destroy) {
                    this._old_prop_value.destroy(true);
                }
            } else {
                if (this._prop_value && this._prop_value.destroy) {
                    this._prop_value.destroy(true);
                }
            }
			delete this._parent;
			delete this._options;
			delete this._old_prop_value;
			delete this._prop_value;
			delete this._prop_name;
        };
        ist.register_serializable_type("set_prop_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    parent_uid: this._parent.id(),
                    name: this._prop_name,
                    value: ist.serialize.apply(ist, ([this._prop_value]).concat(arg_array)),
                    index: this._prop_index
                };
            },
            function (obj) {
                return new My({
                    parent: ist.find_uid(obj.parent_uid),
                    name: obj.name,
                    value: ist.deserialize(obj.value),
                    index: obj.index
                });
            });
        proto.to_undo_string = function () {
            return "remove '" + this._prop_name + "'";
        };
        proto.to_redo_string = function () {
            return "add '" + this._prop_name + "'";
        };
    }(ist.SetPropCommand));
    
    ist.InheritPropCommand = function (options) {
        ist.InheritPropCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.cobj || !this._options.name) {
            throw new Error("Must select a parent object");
        }
    
    
        this._cobj = this._options.cobj;
		this._prop_name = this._options.name;
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
			var ptr = this._cobj.get_pointer(),
				parent_ptr = ptr.pop(),
				parent_cobj = ist.find_or_put_contextual_obj(parent_ptr.points_at(), parent_ptr),
				parent_obj = parent_cobj.get_object();
			
			if(!this._prop_value && parent_cobj instanceof ist.ContextualStatefulObj) {
				var vobj = this._cobj.get_object();

				if(vobj instanceof ist.Cell) {
					var own_statechart = parent_cobj.get_own_statechart();
					var start_state = own_statechart.get_start_state();

					this._prop_value = new ist.StatefulProp();
					this._prop_value.set(start_state, vobj.clone());
				} else if(vobj instanceof ist.StatefulProp) {
					this._prop_value = vobj.clone(this._cobj);
				} else if(vobj instanceof ist.Dict) {
					this._prop_value = vobj.clone();
				} else {
					this._prop_value = vobj;
				}
			}
           parent_obj.set_prop(this._prop_name, this._prop_value);
        };
        proto._unexecute = function () {
			var parent_obj = this._parent.get_object();
			parent_obj.unset_prop(this._prop_name);
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (in_effect) {
                if (this._old_prop_value) {
                    this._old_prop_value.destroy(true);
                }
            } else {
                if (this._prop_value && this._prop_value.destroy) {
                    this._prop_value.destroy(true);
                }
                if (this._value && this._value.destroy) {
                    this._value.destroy(true);
                }
            }
			delete this._parent;
			delete this._prop_name;
			delete this._value;
			delete this._options;
        };
        ist.register_serializable_type("inherit_prop_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
					cobj_uid: this._cobj.id(),
                    name: this._prop_name
                    //parent_uid: this._parent.id(),
                    //value_uid: this._value.id(),
                };
            },
            function (obj) {
                return new My({
                    cobj: ist.find_uid(obj.cobj_uid),
                    name: obj.name
                    //parent: ist.find_uid(obj.parent_uid),
                    //value: ist.find_uid(obj.value_uid),
                });
            });
    }(ist.InheritPropCommand));
    
    // === REMOVE ===
    
    ist.UnsetPropCommand = function (options) {
        ist.UnsetPropCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.parent) {
            throw new Error("Must select a parent object");
        }
    
        this._parent = this._options.parent;
        this._prop_name = this._options.name;
    };
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            this._prop_index = this._parent.prop_index(this._prop_name);
            
            this._has_direct_prop = this._parent._has_direct_prop(this._prop_name);
            if (this._has_direct_prop) {
                this._prop_value = this._parent._get_direct_prop(this._prop_name);
            }
    
            this._parent.unset_prop(this._prop_name);
        };
        proto._unexecute = function () {
            if (this._has_direct_prop) {
                this._parent.set_prop(this._prop_name, this._prop_value, {index: this._prop_index});
            }
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (in_effect) {
                if (this._prop_value && this._prop_value.destroy) {
                    this._prop_value.destroy(true);
                }
            }
			delete this._options;
			delete this._parent;
			delete this._prop_name;
			delete this._prop_value;
			delete this._prop_index;
			delete this._old_prop_value;
        };
        ist.register_serializable_type("unset_prop_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                return {
                    parent_uid: this._parent.id(),
                    name: this._prop_name
                };
            },
            function (obj) {
                return new My({
                    parent: ist.find_uid(obj.parent_uid),
                    name: obj.name
                });
            });
    }(ist.UnsetPropCommand));
    
    
    // === RENAME ===
    
    ist.RenamePropCommand = function (options) {
        ist.RenamePropCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
        if (!this._options.parent || !this._options.from || !this._options.to) {
            throw new Error("Must select a parent object");
        }
    
        this._parent = this._options.parent;
        this._from_name = this._options.from;
        this._to_name = this._options.to;
    };
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            this._parent.rename(this._from_name, this._to_name);
        };
        proto._unexecute = function () {
            this._parent.rename(this._to_name, this._from_name);
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
			delete this._options;
			delete this._parent;
			delete this._from_name;
			delete this._to_name;
		};
        ist.register_serializable_type("rename_prop_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                return {
                    parent_uid: this._parent.id(),
                    from_name: this._from_name,
                    to_name: this._to_name
                };
            },
            function (obj) {
                return new My({
                    parent: ist.find_uid(obj.parent_uid),
                    from: obj.from_name,
                    to: obj.to_name
                });
            });
    }(ist.RenamePropCommand));
    
    
    // === MOVE ===
    
    ist.MovePropCommand = function (options) {
        ist.MovePropCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.parent) {
            throw new Error("Must select a parent object");
        }
    
        this._parent = this._options.parent;
        this._prop_name = this._options.name;
        this._to_index = this._options.to;
    };
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            this._from_index = this._parent.prop_index(this._prop_name);
            this._parent.move_prop(this._prop_name, this._to_index);
        };
        proto._unexecute = function () {
            this._parent.move_prop(this._prop_name, this._from_index);
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
			delete this._parent;
			delete this._prop_name;
			delete this._to_index;
			delete this._options;
		};
        ist.register_serializable_type("move_prop_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                return {
                    parent_uid: this._parent.id(),
                    name: this._prop_name,
                    to: this._to_index
                };
            },
            function (obj) {
                return new My({
                    parent: ist.find_uid(obj.parent_uid),
                    name: obj.name,
                    to: obj.to
                });
            });
    }(ist.MovePropCommand));
    
    // === STATEFUL PROPS ===
    
    ist.SetStatefulPropValueCommand = function (options) {
        ist.SetStatefulPropValueCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.stateful_prop || !this._options.state || !this._options.value) {
            throw new Error("Must select a stateful_prop object");
        }
    
        this._stateful_prop = this._options.stateful_prop;
        this._state = this._options.state;
		this._value = this._options.value;
    };
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
			this._old_value = this._stateful_prop._direct_value_for_state(this._state);
            this._stateful_prop.set(this._state, this._value);
        };
        proto._unexecute = function () {
			if(this._old_value) {
				this._stateful_prop.set(this._state, this._old_value);
			} else {
				this._stateful_prop.unset(this._state);
			}
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (in_effect) {
                if (this._old_value && this._old_value.destroy) {
                    this._old_value.destroy(true);
                }
            } else {
                if (this._value && this._value.destroy) {
                    this._value.destroy(true);
                }
			}
			delete this._options;
			delete this._stateful_prop;
			delete this._state;
			delete this._value;
			delete this._old_value;
        };
        ist.register_serializable_type("set_stateful_prop_value_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    stateful_prop_uid: this._stateful_prop.id(),
                    state_uid: this._state.id(),
                    value: ist.serialize.apply(ist, ([this._value]).concat(arg_array))
                };
            },
            function (obj) {
                return new My({
                    stateful_prop: ist.find_uid(obj.stateful_prop_uid),
                    state: ist.find_uid(obj.state_uid),
                    value: ist.deserialize(obj.value)
                });
            });
    }(ist.SetStatefulPropValueCommand));
    
    
    ist.UnsetStatefulPropValueCommand = function (options) {
        ist.UnsetStatefulPropValueCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.stateful_prop) {
            throw new Error("Must select a stateful_prop object");
        }
    
        this._stateful_prop = this._options.stateful_prop;
        this._state = this._options.state;
    };
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            this._value = this._stateful_prop._direct_value_for_state(this._state);
            this._stateful_prop.unset(this._state);
        };
        proto._unexecute = function () {
            this._stateful_prop.set(this._state, this._value);
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (in_effect) {
                if (this._value && this._value.destroy) {
                    this._value.destroy(true);
                }
            }
			delete this._options;
			delete this._stateful_prop;
			delete this._state;
			delete this._value;
        };
        ist.register_serializable_type("unset_stateful_prop_value_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                return {
                    parent_uid: this._stateful_prop.id(),
                    state_uid: this._state.id()
                };
            },
            function (obj) {
                return new My({
                    stateful_prop: ist.find_uid(obj.parent_uid),
                    state: ist.find_uid(obj.state_uid)
                });
            });
    }(ist.UnsetStatefulPropValueCommand));
    
    
    ist.SetBuiltinCommand = function (options) {
        ist.SetBuiltinCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.parent) {
            throw new Error("Must select a parent object");
        }
    
        this._parent = this._options.parent;
        this._builtin_name = this._options.name;
        this._value = this._options.value;
    };
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            var i;
            var builtins = this._parent.get_builtins();
            for (i in builtins) {
                if (builtins.hasOwnProperty(i)) {
                    var builtin = builtins[i];
                    var env_name = builtin._get_env_name();
                    if (this._builtin_name === env_name) {
                        var getter_name = builtin._get_getter_name();
                        var setter_name = builtin._get_setter_name();
                        this._old_value = this._parent[getter_name]();
                        this._parent[setter_name](this._value);
                        break;
                    }
                }
            }
        };
        proto._unexecute = function () {
            var builtins = this._parent.get_builtins();
            var i;
            for (i in builtins) {
                if (builtins.hasOwnProperty(i)) {
                    var builtin = builtins[i];
                    var env_name = builtin._get_env_name();
                    if (this._builtin_name === env_name) {
                        var setter_name = builtin._get_setter_name();
                        this._parent[setter_name](this._old_value);
                        break;
                    }
                }
            }
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (in_effect) {
                if (this._old_value && this._old_value.destroy) {
                    this._old_value.destroy(true);
                }
            } else {
                if (this._value && this._value.destroy) {
                    this._value.destroy(true);
                }
            }
			delete this._options;
			delete this._parent;
			delete this._builtin_name;
			delete this._value;
        };
    
        ist.register_serializable_type("set_builtin_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    parent_uid: this._parent.id(),
                    name: this._builtin_name,
                    value: ist.serialize.apply(ist, ([this._value]).concat(arg_array))
                };
            },
            function (obj) {
                return new My({
                    parent: ist.find_uid(obj.parent_uid),
                    name: obj.name,
                    value: ist.deserialize(obj.value)
                });
            });
    }(ist.SetBuiltinCommand));

    ist.SetCopiesCommand = function (options) {
        ist.SetCopiesCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.parent) {
            throw new Error("Must select a parent object");
        }
    
        this._parent = this._options.parent;
        this._value = this._options.value;
		if(_.isString(this._value)) {
			this._value = new ist.Cell({str: this._value});
		}
    };
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
			this._parent.set_copies(this._value);
        };
        proto._unexecute = function () {
			console.log("unset copies", this._value);
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (in_effect) {
            } else {
            }
			delete this._parent;
			delete this._value;
        };
    
        ist.register_serializable_type("set_copies",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    parent_uid: this._parent.id(),
                    value: ist.serialize.apply(ist, ([this._value]).concat(arg_array))
                };
            },
            function (obj) {
                return new My({
                    parent: ist.find_uid(obj.parent_uid),
                    value: ist.deserialize(obj.value)
                });
            });
    }(ist.SetCopiesCommand));

    ist.ResetCommand = function (options) {
        ist.ResetCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.parent) {
            throw new Error("Must select a parent object");
        }
    
        this._parent = this._options.parent;
		this._undoable = false;
    };
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
			this._parent.reset();
        };
        proto._unexecute = function () {
			console.log("reset");
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (in_effect) {
            } else {
            }
			delete this._options;
			delete this._parent;
        };
    
        ist.register_serializable_type("reset",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    parent_uid: this._parent.id()
                };
            },
            function (obj) {
                return new My({
                    parent: ist.find_uid(obj.parent_uid)
                });
            });
    }(ist.ResetCommand));

    ist.MovePropAboveBelowCommand = function (options) {
        ist.MovePropCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};

		this._from_obj = this._options.from_obj;
		this._from_name = this._options.from_name;
		this._target_obj = this._options.target_obj;
		this._target_name = this._options.target_name;
		this._above_below = this._options.above_below;
    };
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
			if(!_.isNumber(this._to_index)) {
				if(this._target_name) {
					this._to_index =  this._target_obj.prop_index(this._target_name);
					if(this._above_below === "below") {
						this._to_index++;
					}
				} else {
					this._to_index = 0;
				}

				this._from_index = this._from_obj.prop_index(this._from_name);
				if(this._from_obj === this._target_obj) {
					if(this._from_index < this._to_index) {
						this._to_index--;
					}
				}
			}

			if(this._from_obj === this._target_obj) {
				this._from_obj.move_prop(this._from_name, this._to_index);
			} else {
				var val = this._from_obj._get_direct_prop(this._from_name);
				this._from_obj.unset_prop(this._from_name);
				this._target_obj.set_prop(this._from_name, val, this._to_index);
			}
        };
        proto._unexecute = function () {
			if(this._from_obj === this._target_obj) {
				this._from_obj.move_prop(this._from_name, this._from_index);
			} else {
				var val = this._target_obj._get_direct_prop(this._from_name);
				this._target_obj.unset_prop(this._from_name);
				this._from_obj.set_prop(this._from_name, val, this._to_index);
			}
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
			delete this._options;
			delete this._from_obj;
			delete this._from_name;
			delete this._target_obj;
			delete this._target_name;
			delete this._above_below;
		};
        ist.register_serializable_type("move_prop_above_below_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                return {
					from_obj: this._from_obj.id(),
					target_obj: this._target_obj.id(),
					from_name: this._from_name,
					target_name: this._target_name,
					above_below: this._above_below
                };
            },
            function (obj) {
                return new My({
					from_obj: ist.find_uid(obj.from_obj),
					target_obj: ist.find_uid(obj.target_obj),
					from_name: obj.from_name,
					target_name: obj.target_name,
					above_below: obj.above_below
                });
            });
    }(ist.MovePropAboveBelowCommand));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;

    ist.ChangeCellCommand = function (options) {
        ist.ChangeCellCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.cell || !_.isString(this._options.str)) {
            throw new Error("Must select a cell");
        }
    
        this._cell = this._options.cell;
		if(this._cell instanceof ist.ContextualCell) {
			this._cell = this._cell.get_object();
		}
        this._to_str = this._options.str;
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            this._from_str = this._cell.get_str();
            this._cell.set_str(this._to_str);
			if(!this._cell.is_substantiated()) {
				this._cell.substantiate();
			}
        };
    
        proto._unexecute = function () {
            this._cell.set_str(this._from_str);
        };
    
        ist.register_serializable_type("change_cell_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                return {
                    cell_uid: this._cell.id(),
                    str: this._to_str
                };
            },
            function (obj) {
                return new My({
                    cell: ist.find_uid(obj.cell_uid),
                    str: obj.str
                });
            });
        proto.to_undo_string = function () {
            return "change cell back to '" + this._from_str + "'";
        };
        proto.to_redo_string = function () {
            return "change cell to '" + this._to_str + "'";
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
			delete this._options;
			delete this._cell;
			delete this._from_str;
			delete this._to_str;
		};
    }(ist.ChangeCellCommand));


}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,RedSet */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;
    
    ist.AddStateCommand = function (options) {
        ist.AddStateCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.statechart) {
            throw new Error("Must select a statechart");
        }
    
        this._statechart = this._options.statechart;
        this._state_name = this._options.name;
        if (this._options.state) {
            this._state = this._options.state;
        }
        this._index = this._options.index;
		this._make_start = this._options.make_start;
    
        if (this._statechart.basis && this._statechart.basis()) {
            this._statechart = this._statechart.basis();
        }
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            if (_.has(this, "_state")) {
                this._statechart.add_state(this._state_name, this._state, this._index);
            } else {
                this._statechart.add_state(this._state_name, "statechart", this._index);
                this._state = this._statechart.find_state(this._state_name);
            }

			if(this._make_start) {
				this._statechart.starts_at(this._state);
			}
        };
    
        proto._unexecute = function () {
            this._statechart.remove_state(this._state_name, false); //don't destroy
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (!in_effect) {
                this._state.destroy();
            }
			delete this._options;
			delete this._statechart;
			delete this._state_name;
			delete this._state;
			delete this._index;
			delete this._make_start;
        };
        ist.register_serializable_type("add_state_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var args = _.toArray(arguments);
                return {
                    statechart: this._statechart.id(),
                    name: this._state_name,
                    index: this._index,
                    state: ist.serialize.apply(ist, ([this._state]).concat(args)),
					make_start: this._make_start
                };
            },
            function (obj) {
                return new My({
                    statechart: ist.find_uid(obj.statechart),
                    name: obj.name,
                    index: obj.index,
                    state: ist.deserialize(obj.state),
					make_start: obj.make_start
                });
            });
    }(ist.AddStateCommand));
    
    ist.RemoveStateCommand = function (options) {
        ist.RemoveStateCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.statechart) {
            throw new Error("Must select a statechart");
        }
    
        this._statechart = this._options.statechart;
        this._state_name = this._options.name;
        if (this._statechart.basis && this._statechart.basis()) {
            this._statechart = this._statechart.basis();
        }
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            this._index = this._statechart.get_state_index(this._state_name);
            this._state = this._statechart.find_state(this._state_name);
            var transitions = new RedSet({
                hash: "hash"
            });
            var incoming_transitions = this._state.get_incoming_transitions(),
                outgoing_transitions = this._state.get_outgoing_transitions();
            transitions.add.apply(transitions, incoming_transitions);
            transitions.add.apply(transitions, outgoing_transitions);
            this._transitions = transitions.toArray();
            this._statechart.remove_state(this._state_name, false); //don't destroy
        };
    
        proto._unexecute = function () {
            this._statechart.add_state(this._state_name, this._state, this._index);
            var self = this;
            _.forEach(this._transitions, function (transition) {
                self._statechart.add_transition(transition);
            });
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (in_effect) {
				if(this._statechart && this._statechart.destroy) {
					this._statechart.destroy();
				}
                _.forEach(this._transitions, function (transition) {
                    transition.destroy();
                });
            }
			delete this._options;
			delete this._statechart;
			delete this._state_name;
        };
        ist.register_serializable_type("remove_state_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                return {
                    statechart: this._statechart.id(),
                    name: this._state_name
                };
            },
            function (obj) {
                return new My({
                    statechart: ist.find_uid(obj.statechart),
                    name: obj.name
                });
            });
    }(ist.RemoveStateCommand));
    
    ist.MoveStateCommand = function (options) {
        ist.MoveStateCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.statechart) {
            throw new Error("Must select a statechart");
        }
    
        this._statechart = this._options.statechart;
        this._state_name = this._options.name;
        this._to_index = this._options.index;
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            this._from_index = this._statechart.get_substate_index(this._state_name);
            this._statechart.move_state(this._state_name, this._to_index);
        };
    
        proto._unexecute = function () {
            this._statechart.move_state(this._state_name, this._from_index);
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
		};
    
        ist.register_serializable_type("move_state_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                return {
                    statechart: this._statechart.id(),
                    name: this._state_name,
                    index: this._to_index
                };
            },
            function (obj) {
                return new My({
                    statechart: ist.find_uid(obj.statechart),
                    name: obj.name,
                    index: obj.index
                });
            });
    }(ist.MoveStateCommand));
    
    ist.RenameStateCommand = function (options) {
        ist.RenameStateCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.statechart) {
            throw new Error("Must select a statechart");
        }
    
        this._statechart = this._options.statechart;
        this._from_state_name = this._options.from;
        this._to_state_name = this._options.to;
    
        if (this._statechart.basis && this._statechart.basis()) {
            this._statechart = this._statechart.basis();
        }
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            this._statechart.rename_state(this._from_state_name, this._to_state_name);
        };
    
        proto._unexecute = function () {
            this._statechart.rename_state(this._to_state_name, this._from_state_name);
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
		};
    
        ist.register_serializable_type("rename_state_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                return {
                    statechart: this._statechart.id(),
                    from: this._from_state_name,
                    to: this._to_state_name
                };
            },
            function (obj) {
                return new My({
                    statechart: ist.find_uid(obj.statechart),
                    from: obj.from,
                    to: obj.to
                });
            });
    }(ist.RenameStateCommand));
    
    ist.MakeConcurrentCommand = function (options) {
        ist.MakeConcurrentCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.statechart) {
            throw new Error("Must select a statechart");
        }
    
        this._statechart = this._options.statechart;
        this._concurrent = !!this._options.concurrent;
        if (this._statechart.basis && this._statechart.basis()) {
            this._statechart = this._statechart.basis();
        }
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            this._statechart.make_concurrent(this._concurrent);
        };
    
        proto._unexecute = function () {
            this._statechart.make_concurrent(!this._concurrent);
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
		};
        ist.register_serializable_type("make_concurrent_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                return {
                    statechart: this._statechart.id(),
                    concurrent: this._concurrent
                };
            },
            function (obj) {
                return new My({
                    statechart: ist.find_uid(obj.statechart),
                    concurrent: obj.concurrent
                });
            });
    }(ist.MakeConcurrentCommand));
    
    
    ist.AddTransitionCommand = function (options) {
        ist.AddTransitionCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.from || !this._options.to || !this._options.statechart) {
            throw new Error("Must specify statechart, from, and to");
        }
    
        if (this._options.transition) {
            this._transition = this._options.transition;
        }
        this._statechart = this._options.statechart;
        this._from_state = this._options.from;
        this._to_state = this._options.to;
        this._event = this._options.event;
    
        if (this._statechart.basis && this._statechart.basis()) {
            this._statechart = this._statechart.basis();
        }
        if (this._from_state.basis && this._from_state.basis()) {
            this._from_state = this._from_state.basis();
        }
        if (this._to_state.basis && this._to_state.basis()) {
            this._to_state = this._to_state.basis();
        }
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            if (_.has(this, "_transition")) {
                this._statechart.add_transition(this._transition);
            } else {
                this._statechart.add_transition(this._from_state, this._to_state, this._event);
                this._transition = this._statechart._last_transition;
            }
        };
    
        proto._unexecute = function () {
            //this._statechart.remove_transition(this._transition, false);
            this._transition.remove(false);
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (!in_effect) {
                this._transition.destroy();
            }
        };
        ist.register_serializable_type("add_transition_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    statechart_id: this._statechart.id(),
                    from_id: this._from_state.id(),
                    to_id: this._to_state.id(),
                    event: ist.serialize.apply(ist, ([this._event]).concat(arg_array)),
                    transition: ist.serialize.apply(ist, ([this._transition]).concat(arg_array))
                };
            },
            function (obj) {
                return new My({
                    statechart: ist.find_uid(obj.statechart_id),
                    from: ist.find_uid(obj.from_id),
                    to: ist.find_uid(obj.to_id),
                    event: ist.deserialize(obj.event),
                    transition: ist.deserialize(obj.transition)
                });
            });
    }(ist.AddTransitionCommand));
    
    
    ist.RemoveTransitionCommand = function (options) {
        ist.RemoveTransitionCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.statechart) {
            throw new Error("Must select a statechart");
        }
    
        this._statechart = this._options.statechart;
        this._transition = this._options.transition || this._statechart.get_transition_by_id(this._options.id);
        if (this._statechart.basis && this._statechart.basis()) {
            this._statechart = this._statechart.basis();
        }
        if (this._transition.basis && this._transition.basis()) {
            this._transition = this._transition.basis();
        }
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
        //	this._statechart.remove_transition(this._transition, false);
            this._transition.remove(false);
        };
    
        proto._unexecute = function () {
            this._transition.from()._add_direct_outgoing_transition(this._transition);
            this._transition.to()._add_direct_incoming_transition(this._transition);
            this._statechart.add_transition(this._transition);
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            if (in_effect) {
                this._transition.destroy();
            }
        };
        ist.register_serializable_type("remove_transition_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    statechart: this._statechart.id(),
                    transition: this._transition.id()
                };
            },
            function (obj) {
                return new My({
                    statechart: ist.find_uid(obj.statechart),
                    transition: ist.find_uid(obj.transition)
                });
            });
    }(ist.RemoveTransitionCommand));
    
    ist.SetTransitionEventCommand = function (options) {
        ist.SetTransitionEventCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.transition) {
            throw new Error("Must select a transition");
        }
    
        this._event_str = this._options.event;
    
        this._transition = this._options.transition || this._options.statechart.get_transition_by_id(this.options.id);
        if (this._transition.basis && this._transition.basis()) {
            this._transition = this._transition.basis();
        }
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            var event = this._transition.event();
            this._from_str = event.get_str();
            event.set_str(this._event_str);
        };
    
        proto._unexecute = function () {
            var event = this._transition.event();
            event.set_str(this._from_str);
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
		};
        ist.register_serializable_type("set_transition_event_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    transition_id: this._transition.id(),
                    event_str: this._event_str
                };
            },
            function (obj) {
                return new My({
                    transition: ist.find_uid(obj.transition_id),
                    event: obj.event_str
                });
            });
    }(ist.SetTransitionEventCommand));
    
    
    ist.SetTransitionFromCommand = function (options) {
        ist.SetTransitionFromCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.statechart) {
            throw new Error("Must select a statechart");
        }
    
        this._transition = this._options.transition;
        this._statechart = this._options.statechart;
        if (this._transition.basis && this._transition.basis()) {
            this._transition = this._transition.basis();
        }
        if (this._statechart.basis && this._statechart.basis()) {
            this._statechart = this._statechart.basis();
        }
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
			this._old_statechart = this._transition.from();
            this._transition.setFrom(this._statechart);
        };
    
        proto._unexecute = function () {
            this._transition.setFrom(this._old_statechart);
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
		};
        ist.register_serializable_type("set_transition_from_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    transition_id: this._transition.id(),
                    state_id: this._statechart.id()
                };
            },
            function (obj) {
                return new My({
                    transition: ist.find_uid(obj.transition_id),
                    statechart: ist.find_uid(obj.state_id)
                });
            });
    }(ist.SetTransitionFromCommand));
    
    
    ist.SetTransitionToCommand = function (options) {
        ist.SetTransitionToCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.statechart) {
            throw new Error("Must select a statechart");
        }
    
        this._transition = this._options.transition;
        this._statechart = this._options.statechart;
        if (this._transition.basis && this._transition.basis()) {
            this._transition = this._transition.basis();
        }
        if (this._statechart.basis && this._statechart.basis()) {
            this._statechart = this._statechart.basis();
        }
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
			this._old_statechart = this._transition.to();
            this._transition.setTo(this._statechart);
        };
    
        proto._unexecute = function () {
            this._transition.setTo(this._old_statechart);
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
		};
        ist.register_serializable_type("set_transition_to_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    transition_id: this._transition.id(),
                    state_id: this._statechart.id()
                };
            },
            function (obj) {
                return new My({
                    transition: ist.find_uid(obj.transition_id),
                    statechart: ist.find_uid(obj.state_id)
                });
            });
    }(ist.SetTransitionToCommand));
    
    var null_fn = function () {};
    
    ist.StatechartOnCommand = function (options) {
        ist.StatechartOnCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.statechart) {
            throw new Error("Must select a statechart");
        }
    
        this._statechart = this._options.statechart;
        this._context = this._options.context;
        //this._pcontext = this._options.pcontext;
        if (this._options.listener instanceof ist.ParsedFunction) {
            var func = this._options.listener;
            this._listener = function (info, type) {
                var state = info.state;
                var event = info.event;
                var pcontext = state.context();
                var js_context;
                if (pcontext) {
                    js_context = ist.find_or_put_contextual_obj(pcontext.points_at(), pcontext);
                }
                func._call(js_context, pcontext, event);
            };
        } else {
            this._listener = this._options.listener;
        }
        this._spec = this._options.spec;
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            this._statechart.on_transition(this._spec, this._listener, null_fn, this._context);
        };
    
        proto._unexecute = function () {
            this._statechart.off_transition(this._spec, this._listener, null_fn, this._context);
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
		};
        ist.register_serializable_type("set_transition_on_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    statechart_id: this._statechart.id(),
                    context: ist.serialize.apply(ist, ([this._context]).concat(arg_array)),
                    pcontext: ist.serialize.apply(ist, ([this._pcontext]).concat(arg_array)),
                    listener: ist.serialize.apply(ist, ([this._listener]).concat(arg_array)),
                    spec: this._spec
                };
            },
            function (obj) {
                return new My({
                    statechart: ist.find_uid(obj.statechart_id),
                    context: ist.deserialize(obj.context),
                    pcontext: ist.deserialize(obj.pcontext),
                    listener: ist.deserialize(obj.listener),
                    spec: obj._spec
                });
            });
    }(ist.StatechartOnCommand));
    
    ist.StatechartOff = function (options) {
        ist.StatechartOff.superclass.constructor.apply(this, arguments);
        this._options = options || {};
    
        if (!this._options.statechart) {
            throw new Error("Must select a statechart");
        }
    
        this._statechart = this._options.statechart;
        this._context = this._options.context;
        this._listener = this._options.listener;
        this._spec = this._options.spec;
    };
    
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            this._statechart.off_transition(this._spec, this._listener, null_fn, this._context);
        };
    
        proto._unexecute = function () {
            this._statechart.on_transition(this._spec, this._listener, null_fn, this._context);
        };
    
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
		};
        ist.register_serializable_type("set_transition_off_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    statechart_id: this._statechart.id(),
                    context: ist.serialize.apply(ist, ([this._context]).concat(arg_array)),
                    pcontext: ist.serialize.apply(ist, ([this._pcontext]).concat(arg_array)),
                    listener: ist.serialize.apply(ist, ([this._listener]).concat(arg_array)),
                    spec: this._spec
                };
            },
            function (obj) {
                return new My({
                    statechart: ist.find_uid(obj.statechart_id),
                    context: ist.deserialize(obj.context),
                    pcontext: ist.deserialize(obj.pcontext),
                    listener: ist.deserialize(obj.listener),
                    spec: obj._spec
                });
            });
    }(ist.StatechartOff));

}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;

    ist.CombinedCommand = function (options) {
        ist.CombinedCommand.superclass.constructor.apply(this, arguments);
        this._options = options || {};
        if (!this._options.commands) {
            throw new Error("Must specify commands!");
        }
        this._commands = options.commands;
    };
    (function (My) {
        _.proto_extend(My, ist.Command);
        var proto = My.prototype;
    
        proto._execute = function () {
            _.forEach(this._commands, function (command) {
                command._do();
            });
        };
        proto._unexecute = function () {
            _.forEach(this._commands.reverse(), function (command) {
                command._undo();
            });
        };
        proto._do_destroy = function (in_effect) {
			My.superclass._do_destroy.apply(this, arguments);
            _.forEach(this._commands, function (command) {
                command.destroy(in_effect);
            });
			delete this._options;
			delete this._commands;
        };
    
        ist.register_serializable_type("combined_command",
            function (x) {
                return x instanceof My;
            },
            function () {
                var arg_array = _.toArray(arguments);
                return {
                    commands: ist.serialize.apply(ist, ([this._commands]).concat(arg_array))
                };
            },
            function (obj) {
                return new My({
                    commands: ist.deserialize(obj.commands)
                });
            });
    }(ist.CombinedCommand));

}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
    "use strict";
    var cjs = ist.cjs,
        _ = ist._;
	ist.CommandStack = function () {
        var stack = [],
			index = -1, // Points at the next thing to undo
			transient_stack = [];

		var _add_to_stack = function(command) {
			var discarded_commands = stack.splice(index + 1, stack.length - index);

			_.forEach(discarded_commands, function (discarded_command) {
				if (cjs.isConstraint(discarded_command)) {
					discarded_command.destroy();
				}
			});

			if(command.is_undoable()) {
				stack.push(command);
				index += 1;
			}
			cjs.wait();
			this.$undo_description.invalidate();
			this.$redo_description.invalidate();
			cjs.signal();			

		};

		this.complete_transient = function() {
			var combined_command = new ist.CombinedCommand({commands: transient_stack});
			_add_to_stack.call(this, combined_command);
			transient_stack = [];
		};

		this._do = function(command, transient) {
			cjs.wait();
			command._do();

			if(transient) {
				transient_stack.push(command);
			} else {
				_add_to_stack.call(this, command);
			}
			cjs.signal();
		};

		this._undo = function() {
			if (this.can_undo()) {
				cjs.wait();
				var last_command = stack[index];
				last_command._undo();
				index -= 1;

				this.$undo_description.invalidate();
				this.$redo_description.invalidate();
				cjs.signal();
			}
		};

		this._redo = function() {
			if (this.can_redo()) {
				cjs.wait();
				var last_command = stack[index + 1];
				last_command._do();
				index += 1;

				this.$undo_description.invalidate();
				this.$redo_description.invalidate();
				cjs.signal();
			}
		};


		this.can_undo = function() {
			return index >= 0;
		};

		this.can_redo = function() {
			return index < stack.length - 1;
		};

		this.get_undo_description = function() {
			if(this.can_undo()) {
				var last_command = stack[index];
				return last_command.to_undo_string();
			} else {
				return false;
			}
		};

		this.get_redo_description = function() {
			if(this.can_redo()) {
				var last_command = stack[index + 1];
				return last_command.to_redo_string();
			} else {
				return false;
			}
		};

		this.$undo_description = cjs(this.get_undo_description, {context: this});
		this.$redo_description = cjs(this.get_redo_description, {context: this});

		this.clear = function() {
			for(var i = 0; i<stack.length; i++) {
				stack[i].destroy();
			}
			stack = [];
			index = -1;

			cjs.wait();
			this.$undo_description.invalidate();
			this.$redo_description.invalidate();
			cjs.signal();
		};
		

		this.destroy = function() {
			this.clear();
			this.$undo_description.destroy();
			this.$redo_description.destroy();
		};
	};
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console */

(function (ist) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.Environment = function (options) {
		// Undo stack
		this._command_stack = new ist.CommandStack();

		var root, root_pointer;
		if (options && _.has(options, "root")) {
			root = options.root;
		} else {
			root = ist.get_default_root(!options || options.builtins);
		}

		//Context tracking
		this.pointer = new ist.Pointer({stack: [root]});
		this.print_on_return = false;
	};

	(function (my) {
		var proto = my.prototype;

		proto.default_return_value = function () {
			if (this.print_on_return) {
				return this.print();
			} else {
				return this;
			}
		};

		proto.get_root_pointer = function () {
			return this.pointer.slice(0, 1);
		};
		proto.get_root = function () {
			return this.pointer.root();
		};
		proto.get_pointer_obj = function () {
			return this.pointer.points_at();
		};

		proto.get_current_statechart = function () {
			var statechart;
			var SOandC = ist.find_stateful_obj_and_context(this.pointer);
			var owner = SOandC.stateful_obj;
			statechart = owner.get_own_statechart();
			if (!statechart) {
				throw new Error("Could not find statechart");
			}
			return statechart;
		};

		proto.find_state = function (name) {
			var i, inherited_statecharts, isc;
			if (name instanceof ist.State || name instanceof ist.StatechartTransition) {
				return name.basis() || name;
			} else {
				var SOandC = ist.find_stateful_obj_and_context(this.pointer);
				var owner = SOandC.stateful_obj;
				var statechart = owner.get_own_statechart();

				var states = name.split(/->|-(\d+)>/);
				if (states.length > 1) { //transition
					var from_name = states[0].trim(),
						to_name = states[2].trim(),
						index = parseInt(states[1], 10) || 0;

					var transition = statechart.find_transitions(from_name, to_name, index);

					if (!transition) {
						var pointer = this.get_pointer_obj();
						inherited_statecharts = pointer.get_inherited_statecharts(this.pointer);
						for (i = 0; i < inherited_statecharts.length; i += 1) {
							isc = inherited_statecharts[i];
							transition = isc.find_transitions(from_name, to_name, index);
							if (transition) {
								break;
							}
						}
					}

					return transition.basis() || transition;
				} else {
					var state = statechart.find_state(name);

					if (!state) {
						var contextual_object = ist.find_or_put_contextual_obj(SOandC.stateful_obj, SOandC.context);
						var statecharts = contextual_object.get_statecharts();
						inherited_statecharts = statecharts.slice(1);
						for (i = 0; i < inherited_statecharts.length; i += 1) {
							isc = inherited_statecharts[i];
							state = isc.find_state(name);
							if (state) {
								break;
							}
						}
					}

					return state.basis() || state;
				}
			}
		};

		proto._do = function (command) {
			this._command_stack._do(command);
		};
		proto.undo = function () {
			this._command_stack._undo();
		};
		proto.redo = function () {
			this._command_stack._redo();
		};

		proto.cd = function (prop_name) {
			var dict = this.pointer.points_at(),
				pv = dict._get_direct_prop(prop_name);

			if (pv) {
				this.pointer = this.pointer.push(pv);
			}
			return this.default_return_value();
		};

		proto.top = function () {
			this.pointer = this.pointer.slice(0, 1);
			return this.default_return_value();
		};
		proto.up = function () {
			this.pointer = this.pointer.pop();
			return this.default_return_value();
		};
		proto.reset = function () {
			var parent_obj = this.get_pointer_obj(),
				cobj = ist.find_or_put_contextual_obj(parent_obj, this.pointer);

			if(cobj instanceof ist.ContextualStatefulObj) {
				cobj.reset();
			} else {
				throw new Error("Trying to reset non-stateful");
			}
			return this.default_return_value();
		};

		proto.set = function (prop_name, arg1, arg2, arg3) {
			var builtin_name, i, index, getter_name, val, value,
				commands = [],
				builtin_info = false,
				parent_obj = this.get_pointer_obj();

			if (prop_name[0] === "(" && prop_name[prop_name.length - 1] === ")") {
				builtin_name = prop_name.slice(1, prop_name.length - 1);

				var builtins = parent_obj.get_builtins();
				for (i in builtins) {
					if (builtins.hasOwnProperty(i)) {
						var builtin = builtins[i];
						var env_name = builtin._get_env_name();
						if (builtin_name === env_name) {
							builtin_info = builtin;
							break;
						}
					}
				}
			}
			if (arguments.length === 1) {
				if (parent_obj instanceof ist.StatefulObj) {
					value = "<stateful_prop>";
				} else {
					value = "<stateful>";
				}
			} else {
				value = _.last(arguments);
			}

			if (_.isString(value)) {
				if (value === "<dict>") {
					value = new ist.Dict({});
					var direct_protos = new ist.Cell({ ignore_inherited_in_first_dict: true});
					value._set_direct_protos(direct_protos);
				} else if (value === "<stateful>") {
					value = new ist.StatefulObj(undefined, true);
					value.initialize({
						direct_protos: new ist.StatefulProp({ can_inherit: false, statechart_parent: value })
					});
					/*
					value.get_own_statechart().add_state("INIT")
						.starts_at("INIT");
					*/
				} else if (value === "<stateful_prop>") {
					value = new ist.StatefulProp();
				//} else {
					//value = new ist.Cell({str: value});
				}
			}

			if (arguments.length === 3 || (arguments.length === 4 && _.isNumber(arg3))) { // prop_name, state, value
				var state = this.find_state(arg1);
				index = arg3;

				if (value instanceof ist.StatefulProp) {
					throw new Error("Value is an instanceof a stateful prop");
				}

				if (builtin_info) {
					getter_name = builtin_info._get_getter_name();
					val = parent_obj[getter_name]();
					if (val) {
						if (val instanceof ist.StatefulProp) {
							var val_for_state = val._direct_value_for_state(state);
							if(val_for_state instanceof ist.Cell && _.isString(value)) {
								commands.push(new ist.ChangeCellCommand({
									cell: val_for_state,
									str: value
								}));
							} else {
								commands.push(new ist.SetStatefulPropValueCommand({
									stateful_prop: val,
									state: state,
									value: _.isString(value) ? new ist.Cell({str: value}) : value
								}));
							}
						} else {
							throw new Error("Trying to set value for non stateful prop");
						}
					} else {
						val = new ist.StatefulProp();
						commands.push(new ist.SetBuiltinCommand({
							parent: parent_obj,
							name: builtin_name,
							value: value
						}));
						commands.push(new ist.SetStatefulPropValueCommand({
							stateful_prop: val,
							state: state,
							value: value
						}));
					}
				} else {
					if (parent_obj._has_direct_prop(prop_name)) {
						val = parent_obj._get_direct_prop(prop_name);
						if (val instanceof ist.StatefulProp) {
							if (val._has_direct_value_for_state(state)) {
								var sp_val = val._direct_value_for_state(state);
								if (sp_val instanceof ist.Cell && _.isString(arg2)) {
									commands.push(new ist.ChangeCellCommand({
										cell: sp_val,
										str: value
									}));
								} else {
									commands.push(new ist.SetStatefulPropValueCommand({
										stateful_prop: val,
										state: state,
										value: _.isString(value) ? new ist.Cell({str: value}) : value
									}));
								}
							} else {
								commands.push(new ist.SetStatefulPropValueCommand({
									stateful_prop: val,
									state: state,
									value: _.isString(value) ? new ist.Cell({str: value}) : value
								}));
							}
						} else {
							val = new ist.StatefulProp();
							commands.push(new ist.SetPropCommand({
								parent: parent_obj,
								name: prop_name,
								value: val,
								index: index
							}));
							commands.push(new ist.SetStatefulPropValueCommand({
								stateful_prop: val,
								state: state,
								value: _.isString(value) ? new ist.Cell({str: value}) : value
							}));
						}
					} else {
						val = new ist.StatefulProp();
						commands.push(new ist.SetPropCommand({
							parent: parent_obj,
							name: prop_name,
							value: val,
							index: index
						}));
						commands.push(new ist.SetStatefulPropValueCommand({
							stateful_prop: val,
							state: state,
							value: _.isString(value) ? new ist.Cell({str: value}) : value
						}));
					}
				}
			} else if (arguments.length === 2 || (arguments.length === 3 && _.isNumber(arg2))) {
				index = arg2;

				parent_obj = this.get_pointer_obj();
				if (builtin_info) {
					getter_name = builtin_info._get_getter_name();
					val = parent_obj[getter_name]();
					if (val) {
						if (val instanceof ist.Cell && _.isString(arg1)) {
							commands.push(new ist.ChangeCellCommand({
								cell: val,
								str: arg1
							}));
						} else {
							commands.push(new ist.SetBuiltinCommand({
								parent: parent_obj,
								name: builtin_name,
								value: value
							}));
						}
					} else {
						commands.push(new ist.SetBuiltinCommand({
							parent: parent_obj,
							name: builtin_name,
							value: value
						}));
					}
				} else {
					if (parent_obj._has_direct_prop(prop_name)) {
						val = parent_obj._get_direct_prop(prop_name);
						if (val instanceof ist.Cell && _.isString(arg1)) {
							commands.push(new ist.ChangeCellCommand({
								cell: val,
								str: value
							}));
						} else {
							commands.push(new ist.SetPropCommand({
								parent: parent_obj,
								name: prop_name,
								value: _.isString(value) ? new ist.Cell({str: value}) : value,
								index: index
							}));
						}
					} else {
						commands.push(new ist.SetPropCommand({
							parent: parent_obj,
							name: prop_name,
							value: _.isString(value) ? new ist.Cell({str: value}) : value,
							index: index
						}));
					}
				}
			} else if (arguments.length === 1) {
				if (builtin_info) {
					getter_name = builtin_info._get_getter_name();
					commands.push(new ist.SetBuiltinCommand({
						parent: parent_obj,
						name: builtin_name,
						value: _.isString(value) ? new ist.Cell({str: value}) : value
					}));
				} else {
					commands.push(new ist.SetPropCommand({
						parent: parent_obj,
						name: prop_name,
						value: _.isString(value) ? new ist.Cell({str: value}) : value,
						index: index
					}));
				}
			}
			var command;
			if (commands.length === 1) {
				command = commands[0];
			} else {
				command = new ist.CombinedCommand({
					commands: commands
				});
			}
			this._do(command);
			
			return this.default_return_value();
		};
		proto._get_unset_prop_command = function (prop_name) {
			var parent_obj = this.get_pointer_obj();
			if (!_.isString(prop_name)) {
				console.error("No name given");
				return;
			}
			var command = new ist.UnsetPropCommand({
				parent: parent_obj,
				name: prop_name
			});
			return command;
		};
		proto.unset = function () {
			var command = this._get_unset_prop_command.apply(this, arguments);
			this._do(command);
			return this.default_return_value();
		};

		proto.inherit = function(prop_name) {
			var parent_obj = this.get_pointer_obj();
			var ptr = this.pointer;
			var obj = ptr.points_at();
			var cobj = ist.find_or_put_contextual_obj(obj, ptr);
			cobj = cobj.prop(prop_name);
			var command = new ist.InheritPropCommand({
				cobj: cobj,
				//parent: cobj,
				name: prop_name
			});
			this._do(command);
			return this.default_return_value();
		};

		proto._get_rename_prop_command = function (from_name, to_name) {
			var parent_obj = this.get_pointer_obj();
			var command = new ist.RenamePropCommand({
				parent: parent_obj,
				from: from_name,
				to: to_name
			});
			return command;
		};
		proto.rename = function () {
			var command = this._get_rename_prop_command.apply(this, arguments);
			this._do(command);
			return this.default_return_value();
		};
		proto.set_copies = function (val) {
			var parent_obj = this.get_pointer_obj();
			var command = new ist.SetCopiesCommand({
				parent: parent_obj,
				value: val
			});
			this._do(command);
			return this.default_return_value();
		};
		proto._get_move_prop_command = function (prop_name, index) {
			var parent_obj = this.get_pointer_obj();
			var command = new ist.MovePropCommand({
				parent: parent_obj,
				name: prop_name,
				to: index
			});
			return command;
		};
		proto.move = function () {
			var command = this._get_move_prop_command.apply(this, arguments);
			this._do(command);
			return this.default_return_value();
		};

		proto._get_set_cell_command = function (arg0, arg1, arg2) {
			var cell, str, for_state, i, dict, builtin_name, builtins, env_name, builtin, commands = [];
			if (arguments.length === 1) {
				cell = this.get_pointer_obj();
				str = arg0;
			} else if (arguments.length === 2) {
				dict = this.get_pointer_obj();

				if (_.isString(arg0)) {
					if (arg0[0] === "(" && arg0[arg0.length - 1] === ")") {
						builtin_name = arg0.slice(1, arg0.length - 1);

						builtins = dict.get_builtins();
						for (i in builtins) {
							if (builtins.hasOwnProperty(i)) {
								builtin = builtins[i];
								env_name = builtin._get_env_name();
								if (builtin_name === env_name) {
									cell = dict[builtin._get_getter_name()]();
									break;
								}
							}
						}
					} else {
						cell = dict._get_prop(arg0, this.pointer);
					}
				} else {
					cell = arg0;
				}
			} else {
				var prop;
				dict = this.get_pointer_obj();

				if (_.isString(arg0)) {
					if (arg0[0] === "(" && arg0[arg0.length - 1] === ")") {
						builtin_name = arg0.slice(1, arg0.length - 1);

						builtins = dict.get_builtins();
						for (i in builtins) {
							if (builtins.hasOwnProperty(i)) {
								builtin = builtins[i];
								env_name = builtin._get_env_name();
								if (builtin_name === env_name) {
									prop = dict[builtin._get_getter_name()]();
									break;
								}
							}
						}
					} else {
						prop = dict._get_prop(arg0, this.pointer);
					}
				} else {
					prop = arg0;
				}

				for_state = this.find_state(arg1);
				str = arg2;

				cell = new ist.Cell({str: "", ignore_inherited_in_first_dict: true });
				commands.push(this._get_stateful_prop_set_value_command(prop,
																		for_state,
																		cell));
			}

			commands.push(new ist.ChangeCellCommand({
				cell: cell,
				str: str
			}));

			var command;
			if (commands.length === 1) {
				command = commands[0];
			} else {
				command = new ist.CombinedCommand({
					commands: commands
				});
			}
			return command;
		};

		proto.set_cell = function () {
			var command = this._get_set_cell_command.apply(this, arguments);
			this._do(command);
			return this.default_return_value();
		};

		var get_state = function (state_name, states) {
			var i, state;
			for (i = 0; i < states.length; i += 1) {
				state = states[i];
				if (state instanceof ist.Statechart) {
					if (state === state_name) {
						return state;
					} else if (state.get_name() === state_name) {
						return state;
					} else if (state.get_name(state.parent()) === state_name) {
						return state;
					}
				}
			}
			return undefined;
		};

		proto._get_stateful_prop_set_value_command = function (stateful_prop, state, value) {
			var command = new ist.SetStatefulPropValueCommand({
				stateful_prop: stateful_prop,
				state: state,
				value: value
			});
			return command;
		};

		proto._get_stateful_prop_unset_value_command = function (stateful_prop, state) {
			var command = new ist.UnsetStatefulPropValueCommand({
				stateful_prop: stateful_prop,
				state: state
			});
			return command;
		};

		proto._get_add_state_command = function (state_name, index) {
			var statechart = this.get_current_statechart();

			if (_.isNumber(index)) { index += 1; } // Because of the pre_init state

			var command = new ist.AddStateCommand({
				name: state_name,
				statechart: statechart,
				index: index
			});
			return command;
		};

		proto.add_state = function () {
			var command = this._get_add_state_command.apply(this, arguments);
			this._do(command);
			return this.default_return_value();
		};

		proto._get_remove_state_command = function (state_name) {
			var statechart = this.get_current_statechart();

			var command = new ist.RemoveStateCommand({
				name: state_name,
				statechart: statechart
			});
			return command;
		};
		proto.remove_state = function () {
			var command = this._get_remove_state_command.apply(this, arguments);
			this._do(command);
			return this.default_return_value();
		};

		proto._get_move_state_command = function (state_name, index) {
			var statechart = this.get_current_statechart();

			if (_.isNumber(index)) { index += 1; } // Because of the pre_init state
			var command = new ist.MoveStateCommand({
				name: state_name,
				statechart: statechart,
				index: index
			});
			return command;
		};

		proto.move_state = function () {
			var command = this._get_move_state_command.apply(this, arguments);
			this._do(command);
			return this.default_return_value();
		};


		proto._get_rename_state_command = function (from_state_name, to_state_name) {
			var statechart = this.get_current_statechart();

			var command = new ist.RenameStateCommand({
				from: from_state_name,
				to: to_state_name,
				statechart: statechart
			});
			return command;
		};
		proto.rename_state = function () {
			var command = this._get_rename_state_command.apply(this, arguments);
			this._do(command);
			return this.default_return_value();
		};


		proto._get_add_transition_command = function (from_state_name, to_state_name, event) {
			var statechart = this.get_current_statechart();
			var parent = this.get_pointer_obj();

			var from_state = statechart.find_state(from_state_name);
			var to_state = statechart.find_state(to_state_name);

			if (_.isString(event)) {
				event = new ist.ParsedEvent({str: event, inert: true});
			}

			var command = new ist.AddTransitionCommand({
				statechart: statechart,
				event: event,
				from: from_state,
				to: to_state
			});
			return command;
		};
		proto.make_concurrent = function (state_name, concurrent) {
			if(arguments.length === 1) {
				concurrent = state_name;
				state_name = false;
			}

			var state = state_name ? this.find_state(state_name) : this.get_current_statechart(),
				command = new ist.MakeConcurrentCommand({
					statechart: state,
					concurrent: concurrent !== false
				});

			this._do(command);
			return this.default_return_value();
		};
		proto.add_transition = function () {
			var command = this._get_add_transition_command.apply(this, arguments);
			this._do(command);
			return this.default_return_value();
		};

		proto._get_remove_transition_command = function (transition_id) {
			var statechart = this.get_current_statechart();
			var id, transition;
			
			if (transition_id instanceof ist.StatechartTransition) {
				transition = transition_id;
			} else {
				id = transition_id;
			}
			var command = new ist.RemoveTransitionCommand({
				statechart: statechart,
				id: id,
				transition: transition
			});
			return command;
		};
		proto.remove_transition = function () {
			var command = this._get_remove_transition_command.apply(this, arguments);
			this._do(command);
			return this.default_return_value();
		};

		proto._get_set_event_command = function (transition_id, event) {
			var statechart = this.get_current_statechart();

			var command = new ist.SetTransitionEventCommand({
				statechart: statechart,
				id: transition_id,
				event: event
			});
			return command;
		};
		proto.set_event = function () {
			var command = this._get_set_event_command.apply(this, arguments);
			this._do(command);
			return this.default_return_value();
		};
		proto.set_from = function (transition, to_state) {
			transition = this.find_state(transition);
			to_state = this.find_state(to_state);
			var command = new ist.SetTransitionFromCommand({
				transition: transition,
				statechart: to_state
			});
			this._do(command);
			return this.default_return_value();
		};
		proto.set_to = function (transition, to_state) {
			transition = this.find_state(transition);
			to_state = this.find_state(to_state);
			var command = new ist.SetTransitionToCommand({
				transition: transition,
				statechart: to_state
			});
			this._do(command);
			return this.default_return_value();
		};
		proto.start_at = function(state_name) {
			var statechart,
				start_state, outgoing_transition, command,
				to_state = this.find_state(state_name);

			if(state_name.indexOf(".") < 0) {
				statechart = this.get_current_statechart();
			} else {
				statechart = this.find_state(state_name.slice(0, state_name.lastIndexOf(".")));
			}

			start_state = statechart.get_start_state();
			outgoing_transition = start_state.get_outgoing_transition();

			command = new ist.SetTransitionToCommand({
				transition: outgoing_transition,
				statechart: to_state
			});

			this._do(command);
			return this.default_return_value();
		};
		proto.on_state = function (spec, func, context) {
			var statechart = this.get_current_statechart();
			if (_.isString(func)) {
				func = ist.get_parsed_val(ist.parse(func), { });
			}
			var command = new ist.StatechartOnCommand({
				statechart: statechart,
				spec: spec,
				listener: func,
				pcontext: this.pointer,
				context: context
			});
			this._do(command);
			return this.default_return_value();
		};
		proto.off_state = function (spec, func, context) {
			var statechart = this.get_current_statechart();
			var command = new ist.StatechartOffCommand({
				statechart: statechart,
				spec: spec,
				listener: func,
				context: context
			});
			this._do(command);
			return this.default_return_value();
		};
		proto.print = function (logging_mechanism) {
			return ist.print(this.pointer, logging_mechanism);
		};
		proto.destroy = function () {
			var ptr = this.pointer,
				root = ptr.root(),
				croot = ist.find_or_put_contextual_obj(root);


			this._command_stack.destroy();
			delete this._command_stack;

			window.dbg = true;
			croot.destroy();
			window.dbg = false;
			/*
			if(_.keys(interstate.cobj_hashes).length>0) {
				debugger;
			}
			*/
			root.destroy();
			delete this.pointer;
		};
		proto._cycle_stringify_destringify = function() {
			var root = this.get_root(),
				stringified_root = ist.stringify(root);

			root.destroy();
			this._command_stack.clear();

			var new_root = ist.destringify(stringified_root);

			this.pointer = new ist.Pointer({stack: [new_root]});
		};
	}(ist.Environment));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,jQuery,window,FileReader,document */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._,
		origin = window.location.protocol + "//" + window.location.host;

    var platform = window.navigator.platform;
	var display;
	if(platform === "iPhone" || platform === "iPod") {
		display = "phone";
	} else if(platform === "iPad") {
		display = "tablet";
	} else {
		display = "desktop";
	}

/*	var run_edit_template = cjs.createTemplate(
		"{{#fsm run_state}}" +
			"{{#state edit}}" +
				"<a class='edit'>edit</span>" +
			"{{#state run}}" +
				"<a class='run'>run</span>" +				
		"{{/fsm}}"
	);
*/

	$.widget("interstate.dom_output", {
		options: {
			root: undefined,
			show_edit_button: true,
			edit_on_open: false,
			editor_url: "editor.html",
			editor_name: uid.get_prefix() + "ist_editor",
			open_separate_client_window: true,
			external_editor: display === "phone" || display === "tablet",
			auto_open_external_editor: false,
			editor_window_options: function () {
				return "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, width=" + window.innerWidth + ", height=" + (2*window.innerHeight/3) + ", left=" + window.screenX + ", top=" + (window.screenY + window.outerHeight);
			},
			client_id: uid.get_prefix(),
			immediately_create_server_socket: false
		},

		_create: function () {
			this.element.addClass("ist_runtime");
			this._command_stack = new ist.CommandStack();
			this.$dirty_program = cjs(false);
			this.$highlighting_objects = cjs([]);
			this.$inspecting_hover_object = cjs(false);
			this.$breakpoints = cjs({});

			if(!this.option("root")) {
				var root = ist.load();
				if(!root) {
					root = ist.get_default_root();
					ist.saveAndSetCurrent(root);
				}
				this.option("root", root);
			}
			if (this.option("show_edit_button")) {
				this.button_color = "#990000";
				this.edit_button_css = {
					float: "right",
					"text-decoration": "none",
					"font-variant": "small-caps",
					//"padding-top": "0px",
					position: "fixed",
					top: (display === "tablet" || display === "phone") ? "15px" : "0px",
					right: "0px",
					color: this.button_color,
					"background-color": "",
					"font-size": "1.2em",
					"font-family": '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif',
					cursor: "pointer",
					padding: "5px",
					"border-bottom": ""
				};
				this.running_button_css = {
					float: "right",
					position: "fixed",
					top: "20px",
					"padding-left": "5px",
					right: "20px",
					"font-family": '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif',
					color: this.button_color,
					"-webkit-touch-callout": "none",
					"-webkit-user-select": "none",
					"-khtml-user-select": "none",
					"-moz-user-select": "none",
					"-ms-user-select": "none",
					"user-select": "none"							
				};
				this.editing_button_css = {					
					position: "fixed",
					top: "40px"
				};
				this.editing_button_open_css = {
					top: "60px"
				};
				this.hidden_button_css = {
					display: "none"
				};
				this.shown_button_css = {
					display: "block"
				};
				this.run_edit_active_css = {
					"font-weight": "bold"
				};
				this.run_edit_inactive_css = {
					"font-weight": "normal"
				};
				this.edit_hover_css = {
					opacity: 1.0,
					color: "white",
					"background-color": this.button_color,
					cursor: "pointer",
					"border-bottom": ""
				};
				this.edit_active_css = {
					opacity: 1.0,
					color: this.button_color,
					"background-color": "",
					cursor: "default",
					"border-bottom": "5px solid " + this.button_color
				};
				this.palette_css = {
					"float":"right",					
					"position": "fixed",
					top: "65px",
					right:"13px",
					"padding-left": "0",
					"margin": "0",
					display: "none",
					"font-size": "0.95em",
					"list-style-type": "none",
					"font-family": '"HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif',
					color: this.button_color				
				};
				this.palette_css_show = {
					display: "block"
				};
				this.inspect_css = {
					display: "block",
					top: "42px",
					right: "25px"
				};
				this.code_view_css = {
					right: "25px"
				};
				this.inspect_css_show = {
					display: "none"
				};
				this.undo_redo_css = {
					float: "right",
					position: "fixed",
					right: "0px",
					padding: "5px",
					top: "0",
					display: "none"
				};

				var that = this;

				this.edit_button = $("<a />")	.text("edit")
												.css(this.edit_button_css)
												.on("mouseover.make_active", _.bind(function() {
													if (!this.edit_button.hasClass("active")) {
														this.edit_button.addClass("hover").css(this.edit_hover_css);
													}
												}, this))
												.on("mouseout.make_active", _.bind(function () {
													if (!this.edit_button.hasClass("active")) {
														this.edit_button.removeClass("hover").css(this.edit_button_css);
													}
												}, this))
												.on("mousedown.open_editor touchstart.open_editor", _.bind(this.open_editor, this));

				var append_interval = window.setInterval(_.bind(function() {
					this.element.append(this.edit_button);
				}, this));


			}

			if (this.option("edit_on_open")) {
				this.open_editor();
			}

			$(window)	.on("keydown.open_editor", _.bind(this.on_key_down, this))
						.on("beforeunload.do_save onunload.do_save unload.do_save pagehide.do_save", _.bind(function() {
							this._save();
							this.element.dom_output("destroy");
						}, this));

			if(this.option("immediately_create_server_socket")) {
				this.server_socket = this._create_server_socket();
			}

			this._add_change_listeners();
			this._add_highlight_listeners();
		},


		_setOption: function(key, value) {
			if(key === "root") {
				this._remove_change_listeners();
				var old_root = this.option("root");
				if(old_root) {
					var old_root_contextual_object = ist.find_or_put_contextual_obj(old_root);
					if(old_root_contextual_object) {
						//old_root_contextual_object.destroy();
					}
					//old_root.destroy();
				}
			}
			this._super(key, value);
			if(key === "root") {
				this._command_stack.clear();
				if(this.server_socket) {
					this.server_socket.set_root(this.option("root"));
				}
				if(value) {
					this._add_change_listeners();
				}
				this.$dirty_program.set(false);
			}
		},

		import_component: function(name, obj) {
			var root = this.option("root");
			var orig_name = name;
			var i = 1;
			while(root._has_direct_prop(name)) {
				name = orig_name+"_"+i;
				i++;
			}
			root.set(name, obj);
		},

		get_server_socket: function() {
			return this.server_socket;
		},

		on_key_down: function(event) {
			if(event.altKey && event.metaKey) {
				if(event.keyCode === 69) { // e
					this.open_editor();
				} else if(event.keyCode === 84) { // i
					this.begin_inspect();
					event.preventDefault();
					event.stopPropagation();
				}
			}
		},

		_destroy: function () {
			this._super();
			this.close_editor();
			$(window).off(".do_save");
			this._remove_highlight_listeners();

			this.$highlighting_objects.destroy(true);
			delete this.$highlighting_objects;
			this.$inspecting_hover_object.destroy(true);
			delete this.$inspecting_hover_object;

			this.$dirty_program.destroy(true);
			delete this.$dirty_program;
			this.$breakpoints.destroy(true);
			delete this.$breakpoints;

			this._remove_change_listeners();
			this.element.removeClass("ist_runtime");
			$(window).off("keydown.open_editor");
			if (this.edit_button) {
				this.edit_button.off("mouseover.make_active")
								.off("mouseout.make_active")
								.off("click.open_editor")
								.remove();
			}
			if (this.server_socket) {
				this.server_socket.destroy();
				delete this.server_socket;
			}
			this._command_stack.destroy();

			delete this._command_stack;
			delete this.options;
		},

		_add_highlight_listeners: function () {
			var old_highlighting_elements = [],
				svg_followers = [];
			this._highlight_fn = cjs.liven(function() {
				var highlighting_objects = this.$highlighting_objects.toArray(),
					highlighting_elements = _	.chain(highlighting_objects)
												.map(function(cobj) {
													if(cobj.is_destroyed()) {
														return false;
													} else if(cobj.is_template()) {
														return cobj.instances();
													} else {
														return cobj;
													}
												})
												.compact()
												.flatten()
												.map(function(obj) {
													if(!obj._destroyed) {
														return obj.get_dom_obj();
													}
												})
												//.compact()
												.flatten()
												.value()
												.concat(this.$inspecting_hover_object.get());
				highlighting_elements = _.compact(highlighting_elements);
				var diff = _.diff(old_highlighting_elements, highlighting_elements);

				_.each(diff.added, function(info) {
					var dom_node = info.item;
					$(dom_node).addClass("highlight");
					if(dom_node instanceof SVGElement) {
						var bounding_rect = dom_node.getBoundingClientRect(),
							tagName = dom_node.tagName,
							follower = $("<div />").appendTo(document.body)
													.addClass("highlight svg_follow")
													.css({
														left: bounding_rect.left+"px",
														top: bounding_rect.top+"px",
														width: bounding_rect.width+"px",
														height: bounding_rect.height+"px",
														borderRadius: tagName.toUpperCase() === "CIRCLE" ? bounding_rect.width/2+"px" : "0px"
													});
						svg_followers.push({
							following: dom_node,
							follower: follower
						});
					}
				});
				_.each(diff.removed, function(info) {
					var dom_node = info.from_item;
					$(dom_node).removeClass("highlight");
					if(dom_node instanceof SVGElement) {
						_.each(svg_followers, function(info, index) {
							if(info.following === dom_node) {
								info.follower.remove();
								svg_followers.splice(index, 1);
							}
						});
					}
				});

				old_highlighting_elements = highlighting_elements;
			}, {
				context: this,
				on_destroy: function() {
					_.each(old_highlighting_elements, function(dom_node) {
						$(dom_node).removeClass("highlight");
						if(dom_node instanceof SVGElement) {
							_.each(svg_followers, function(info, index) {
								if(info.following === dom_node) {
									info.follower.remove();
									svg_followers.splice(index, 1);
								}
							});
						}
					});
				},
				run_on_start: false
			});

			this._highlight_fn.run();
		},

		_remove_highlight_listeners: function () {
			if(this._highlight_fn) {
				this._highlight_fn.destroy();
			}
		},

		_add_change_listeners: function () {
			var root_dict = this.option("root");
			var root_contextual_object = ist.find_or_put_contextual_obj(root_dict);

			if(!ist.__empty_files) {
				this._dom_tree_fn = cjs.liven(function () {
					var dom_attachment = root_contextual_object.get_attachment_instance("dom");
					var dom_element = dom_attachment.get_dom_obj();
					if (this.element.children().is(dom_element)) {
						this.element.children().not(dom_element).remove();
					} else {
						this.element.children().remove();
						this.element.append(dom_element);
					}
				}, {
					context: this,
					pause_while_running: true,
					on_destroy: function() {
						this.element.children().remove();
					}
				});
			}
		},
		
		_remove_change_listeners: function () {
			if(this._dom_tree_fn) {
				this._dom_tree_fn.destroy();
				delete this._dom_tree_fn;
			}
			if(this._raphael_fn) {
				this._raphael_fn.destroy();
				delete this._raphael_fn;
			}
			if(this._update_fn) {
				this._update_fn.destroy();
				delete this._update_fn;
			}
		},

		_create_server_socket: function() {
			var root = this.option("root");

			var server_socket = new ist.ProgramStateServer({
				root: root,
				command_stack: this._command_stack,
				dirty_program: this.$dirty_program
			}).on("connected", function () {
				if(this.edit_button) {
					this.edit_button.addClass("active").css(this.edit_active_css);
				}
			}, this).on("disconnected", function () {
				this.cleanup_closed_editor();
			}, this).on("command", function (command) {
				if (command === "undo") {
					this._command_stack._undo();
					this.$dirty_program.set(true);
				} else if (command === "redo") {
					this._command_stack._redo();
					this.$dirty_program.set(true);
				} else {
					this._command_stack._do(command);
					this.$dirty_program.set(true);
				}
			}, this).on("load_program", function (name) {
				var new_root = ist.load(name);
				this.option("root", new_root);
			}, this).on("load_file", function (message) {
				this.load_str(message.contents, message.name, message.also_load);
			}, this).on("download_program", function (name, type) {
				if(type === "component") {
					this.server_socket.post({
						type: "stringified_obj",
						value: ist.loadString(name, type),
						name: name
					});
				} else {
					this.server_socket.post({
						type: "stringified_root",
						value: ist.loadString(name, type),
						name: name
					});
				}
			}, this).on("save_component", function (event) {
				var cobj_id = event.cobj_id,
					cobj = ist.find_uid(cobj_id);
				if(cobj) {
					var obj = cobj.get_object();
					ist.save(obj, cobj.get_name(), "component");
				}
			}, this).on("save_curr", function (event) {
				this._save();
			}, this).on("save_curr_as", function (event) {
				this._save();
				ist.saveAndSetCurrent(this.option("root"), event.name);
			}, this).on("create_program", function (event) {
				this._save();
				var newroot = ist.get_default_root();
				ist.saveAndSetCurrent(newroot, event.name);
				this.option("root", newroot);
			}, this).on("copy_component", function (event) {
				var target_obj_id = event.target_obj_id;
				var target_obj = ist.find_uid(target_obj_id);
				//var tobj = target_cobj.get_object();
				var component = ist.load(event.name, "component");
				target_obj.set(event.name, component);
			}, this).on("rename_program", function(event) {
				var from_name = event.from_name,
					to_name = event.to_name,
					storage_type = event.storage_type;

				this._save();
				ist.rename(from_name, to_name, storage_type);
			}, this).on("add_highlight", function(event) {
				var cobj_id = event.cobj_id,
					cobj = ist.find_uid(cobj_id);
				if(cobj) {
					this.$highlighting_objects.push(cobj);
				}
			}, this).on("remove_highlight", function(event) {
				var cobj_id = event.cobj_id,
					cobj = ist.find_uid(cobj_id);
				if(cobj) {
					var index = this.$highlighting_objects.indexOf(cobj);
					if(index >= 0) {
						this.$highlighting_objects.splice(index, 1);
					}
				}
			}, this)
			;
			return server_socket;
		},
		load_str: function(fr_result, filename, also_load) {
			var result = fr_result.replace(/^COMPONENT:/, ""),
				is_component = result.length !== fr_result.length,
				obj,
				name = filename.replace(/\.\w*$/, "");

			if(ist.__debug) {
				obj = ist.destringify(result);
			} else {
				try {
					obj = ist.destringify(result);
				} catch(e) {
					console.error("Error loading " + filename);
					console.error(e);
					return;
				}
			}

			if(is_component) {
				//this.import_component(name, obj);
				interstate.save(obj, name, "component");
			} else {
				this._save();
				if(also_load) {
					ist.saveAndSetCurrent(obj, name);
					this.option("root", obj);
					this.element.trigger("change_root", obj);
				} else {
					ist.save(obj, name);
				}
			}
		},
		open_editor: function (event, cobj) {
			if(this.editing_button) {
				this.editing_button.css(this.shown_button_css);
			}
			if(this.running_button) {
				this.running_button.css(this.shown_button_css);
			}
			if(this.undo_redo_buttons) {
				this.undo_redo_buttons.css(this.shown_button_css);
			}
			if(event) {
				event.preventDefault();
				event.stopPropagation();
			}
			if (this.editor_window) {
				this.editor_window.focus();
			} else {
				var on_comm_mechanism_load = function(communication_mechanism) {
					this.server_socket = this.server_socket || this._create_server_socket(cobj);
					this.server_socket.set_communication_mechanism(communication_mechanism);

					if (this.server_socket.is_connected()) { // It connected immediately
						if(this.edit_button) {
							this.edit_button.addClass("active").css(this.edit_active_css);
						}
					}
					this.element.trigger("editor_open");
				};

				if(this.option("external_editor")) {
					interstate.async_js("/socket.io/socket.io.js", _.bind(function() {
						var socket_wrapper = new ist.SocketCommWrapper(this.option("client_id"), true);
						if(this.option("auto_open_external_editor")) {
							$.ajax({
								url: "auto_open_editor",
								data: {
									client_id: this.option("client_id")
								},
								type: "GET"
							});
						} else {
							var url = origin+"/e/"+encodeURIComponent(this.option("client_id"));
							var code_container = $("<div />");
							var size = display === "tablet" ? 500 : 256;

							var qrcode = new QRCode(code_container[0], {
								text: url,
								width: size,
								height: size,
								colorDark : "#000000",
								colorLight : "#ffffff",
								correctLevel : QRCode.CorrectLevel.H
							});

							var alert = $("<div />").addClass("upload_url")
													.appendTo(document.body)
													.append(code_container, $("<a />").attr({"href": url, "target": "_blank"}).text(url));
							$(window).on("touchstart.close_alert mousedown.close_alert", function(event) {
								if(!$(event.target).parents().is(alert)) {
									$(window).off("touchstart.close_alert mousedown.close_alert");
									alert.remove();
								}
							});
						}
						on_comm_mechanism_load.call(this, socket_wrapper);
					}, this));
				} else if (this.option("open_separate_client_window")) {
					this.editor_window = window.open(this.option("editor_url")+"?client_id="+encodeURIComponent(this.option("client_id")), this.option("editor_name"), this.option("editor_window_options")());
					on_comm_mechanism_load.call(this, new ist.InterWindowCommWrapper(this.editor_window, this.option("client_id")));
				} else {
					this.editor_window = window;
					on_comm_mechanism_load.call(this, new ist.SameWindowCommWrapper(this.option("client_id"), 0));
				}
			}
		},
		
		close_editor: function () {
			if (this.editor_window) {
				this.editor_window.close();
				this.cleanup_closed_editor();
			}
		},

		_save: function() {
			if(this.$dirty_program.get()) {
				this.$dirty_program.set(false);
				ist.save(this.option("root"));
			}
		},

		cleanup_closed_editor: function () {
			this.$highlighting_objects.setValue([]);
			if(this.edit_button) {
				this.edit_button.removeClass("active").css(this.edit_button_css);
			}
			delete this.editor_window;
		},
		begin_inspect: function () {
			if(this._inspecting) {
				this.cancel_inspect();
			} else {
				this._inspecting = true;
				this._inspecting_target = false;

				this._on_mover = _.bind(function(mo_event) {
					var target = this._inspecting_target = mo_event.target;
					this.$inspecting_hover_object.set(target);
				}, this);
				this._on_mout = _.bind(function(mo_event) {
					if(mo_event.target === this._inspecting_target) {
						this.$inspecting_hover_object.set(false);
						this._inspecting_target = false;
					}
				}, this);
				this._on_click = _.bind(function(c_event) {
					var target = c_event.target,
						cobj = target.__ist_contextual_object__;
					this.inspect_cobj(cobj);
				}, this);

				$(this.element).get(0).addEventListener("mouseover", this._on_mover, true);
				$(this.element).get(0).addEventListener("mouseout", this._on_mout, true);
				$(this.element).get(0).addEventListener("click", this._on_click, true);
				$(window).on("keydown.inspector", _.bind(function(kd_event) {
					if(kd_event.keyCode === 27) { // esc
						this.cancel_inspect();
					} else if(kd_event.keyCode === 13) { // enter
						if(this._inspecting_target) {
							var cobj = this._inspecting_target.__ist_contextual_object__;

							this.inspect_cobj(cobj);
						}
					}
				}, this));
			}

		},
		cancel_inspect: function() {
			if(this._inspecting) {
				this._inspecting = false;
				this._inspecting_target = false;
				this.$inspecting_hover_object.set(false);

				$(this.element).get(0).removeEventListener("mouseover", this._on_mover, true);
				$(this.element).get(0).removeEventListener("mouseout", this._on_mout, true);
				$(this.element).get(0).removeEventListener("click", this._on_click, true);
				$(window).off("keydown.inspector");
			}
		},
		inspect_cobj: function(cobj) {
			if (this.editor_window) {
				this.server_socket.post({
					type: "inspect",
					cobj_id: cobj.id()
				});
				this.editor_window.focus();
			} else {
				this.open_editor();
			}
			this.cancel_inspect();
		}
	});
}(interstate, jQuery));

/*jslint nomen: true, vars: true, white: true */
/*global interstate,esprima,able,uid,console,window,jQuery,Raphael */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;
	
	var editing_text_template = cjs.createTemplate("<textarea cjs-on-blur=on_edit_blur cjs-on-keydown=on_edit_keydown />");

	cjs.registerCustomPartial("editing_text", {
		createNode: function(init_val) {
			var node = editing_text_template({
				on_edit_blur: function(event) {
					$(node).editing_text("on_edit_blur", event);
				},
				on_edit_keydown: function(event) {
					$(node).editing_text("on_edit_keydown", event);
				}
			});
			$(node).editing_text({
				init_val: init_val
			});

			return node;
		},
		onAdd: function(node, init_val) {
			_.defer(function() { $(node).val(init_val).select().focus(); });
			$(node).editing_text("onAdd");
		},
		onRemove: function(node) {
			$(node).editing_text("option", "helper", false);
			$(node).editing_text("onRemove");
		},
		destroyNode: function(node) {
			$(node).editing_text("destroy");
		}
	});
	$.widget("interstate.editing_text", {
		options: {
			init_val: "",
			helper: false
		},
		_create: function () {
			this._helper_focused = false;
			this.element.val(this.option("init_val"));
			this._confirm = _.bind(this._confirm_edit, this);
			this._cancel = _.bind(this._cancel_edit, this);
		},
		_destroy: function () {
			if(this.$textarea_binding) { this.$textarea_binding.destroy(); }
			this.option("helper", false);
			this._super();
		},

		onAdd: function() {
			$("#confirm_button").on("mousedown", this._confirm);
			$("#cancel_button").on("mousedown", this._cancel);
		},

		onRemove: function() {
			$("#confirm_button").off("mousedown", this._confirm);
			$("#cancel_button").off("mousedown", this._cancel);
		},

		_setOption: function(key, value) {
			if(key === "helper") {
				var editor = value,
					old_editor = this.option("helper");

				if(this.$textarea_binding) { this.$textarea_binding.destroy(); }

				if(old_editor) {
					old_editor.setValue("");
				}

				if(editor) {
					editor.setValue(this.element.val() || " ", 1);
					this.$textarea_binding = cjs(this.element[0]);
					this.$textarea_binding.onChange(function() {
						editor.setValue(this.$textarea_binding.get(), 1);
					}, this);
				}
			}
			this._super(key, value);
		},
		on_edit_blur: function(event) {
			var editor = this.option("helper"),
				do_confirm = _.bind(this._confirm_edit, this);
			event.preventDefault();
			event.stopPropagation();

			var on_editor_blur = _.bind(function(e) {
					this._helper_focused = false;
					_.delay(_.bind(function() {
						if(editor.isFocused()) {
							this._helper_focused = true;
						} else if(this.element.is(":focus")) {
							this._helper_focused = false;
						} else {
							do_confirm();
						}
					}, this), 50);

					editor.off("blur", on_editor_blur);
					editor.off("change", on_editor_change);
				}, this),
				on_editor_change = _.bind(function(event) {
					if(this._helper_focused) {
						this.element.val(editor.getValue());
					}
				}, this);

			if(editor) { // they might have clicked on the helper
				_.delay(_.bind(function() {
					if(editor.isFocused()) {
						this._helper_focused = true;
						editor.on("change", on_editor_change);
						editor.on("blur", on_editor_blur);
					} else {
						do_confirm();
					}
				}, this), 50);
			} else {
				do_confirm();
			}
		},
		on_edit_keydown: function(event) {
			var keyCode = event.keyCode;

			if(keyCode === 27) { //esc
				event.preventDefault();
				event.stopPropagation();
				this._cancel_edit();
			} else if(keyCode === 13) { //enter
				if(!event.shiftKey && !event.ctrlKey && !event.metaKey) {
					event.preventDefault();
					event.stopPropagation();

					this._confirm_edit();
				}
			}
		},
		cancel: function() {
			return this._cancel_edit();
		},

		_confirm_edit: function() {
			if(!this.__blocked) {
				this.__blocked = true;

				var e = new $.Event("confirm_value");
				e.value = this.element.val().trim();
				this.element.trigger(e);

				_.delay(_.bind(function() {
					delete this.__blocked;
				}, this), 50);
			}
		},
		_cancel_edit: function() {
			if(!this.__blocked) {
				this.__blocked = true;
				var e = new $.Event("cancel_value");
				this.element.trigger(e);
				_.delay(_.bind(function() {
					delete this.__blocked;
				}, this), 50);
			}
		}
	});
}(interstate, jQuery));

/*jslint nomen: true, vars: true, white: true */
/*jshint scripturl: true */
/*global interstate,esprima,able,uid,console,window,jQuery,Raphael */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var editor_template = cjs.createTemplate(
		"<nav class='navbar navbar-default' role='navigation'>" +
			"<div class='undoredo_group btn-group navbar-left'>" +
				"{{#if undo_desc}}" +
					"<div type='button' class='btn btn btn-default' data-cjs-on-click='undo'>" +
						"<div class='tooltip'>{{undo_desc}}</div>" +
						"<span class='glyphicon glyphicon-arrow-left'></span> " +
						"Undo" +
					"</div>" +
				"{{#else}}" +
					"<div disabled type='button' class='btn btn btn-default'>" +
						"<span class='glyphicon glyphicon-arrow-left'></span> " +
						"Undo" +
					"</div>" +
				"{{/if}}" +

				"{{#if redo_desc}}" +
					"<div type='button' class='btn btn btn-default' data-cjs-on-click='redo'>" +
						"<div class='tooltip'>{{redo_desc}}</div>" +
						"Redo" +
						" <span class='glyphicon glyphicon-arrow-right'></span>" +
					"</div>" +
				"{{#else}}" +
					"<div disabled type='button' class='btn btn btn-default'>" +
						"Redo" +
						" <span class='glyphicon glyphicon-arrow-right'></span>" +
					"</div>" +
				"{{/if}}" +
			"</div>" + // btn group
			"<table id='cell_group' class='input-group navbar-left'>" +
				"<tr>" +
					"<td>" +
						"<pre id='ace_ajax_editor'></pre>" +
					"</td>" +
					"<td id='confirm'>" +
						"<span title='Confirm cell' id='confirm_button' class='glyphicon glyphicon-ok-circle'></span>" +
					"</td>" +
					"<td id='cancel'>" +
						"<span title='Cancel' id='cancel_button' class='glyphicon glyphicon-remove-circle'></span>" +
					"</td>" +
				"</tr>" +
				"<tr>" +
					"<td class='resize_bar' data-cjs-on-mousedown='beginResizeAce'></td>" +
				"</tr>" +
			"</table>" +
			"<div class='widget_group navbar-right pull-right'>" +
				"<div type='button' class='btn btn btn-default {{show_components ? \"active\" : \"\"}}' data-cjs-on-click='toggle_show_widgets'>" +
					"Files" +
					" <span class='glyphicon {{show_components ? \"glyphicon-chevron-up\" : \"glyphicon-chevron-down\"}}'></span>" +
				"</div>" +
			"</div>" +
		"</nav>" +


		"{{#fsm loading_state}}" +
			"{{#state loading}}" +
				"<div class='loading'>loading editor...</div>" +
			"{{#state loaded}}" +
				"{{#if show_components}}" +
					"{{> widgetList getWidgetListOptions()}}" +
				"{{/if}}" + // show components
				"{{> navigator getNavigatorOptions()}}" +
				"{{> pinned getPinnedOptions()}}" +
		"{{/fsm}}"
	);
	$.widget("interstate.editor", {
		options: {
			full_window: true,
			server_window: window.opener,
			client_id: uid.get_prefix(),
			upload_usage: false,
			use_socket: false,
			pinned_row: true
		},
		_create: function () {
			this.$pinned_columns = cjs([]);
			this.loading_state = cjs.fsm("loading", "loaded")
									.startsAt("loading");

			this.$dragging_client = cjs(false);

			var on_load = this.loading_state.addTransition("loading", "loaded"),
				on_rootchange = this.loading_state.addTransition("loaded", "loading");

			this.$window_inner_width = cjs(function() { return window.innerWidth; });
			this.$window_inner_height = cjs(function() { return window.innerHeight; });
			$(window).on("resize.owr", _.bind(function() {
				this.$window_inner_width.invalidate();
				this.$window_inner_height.invalidate();
			}, this));

			this.$show_components = cjs(false);
			this.$info_servers = cjs(false);
			this.$undo_client = this.$info_servers.prop("undo_description");
			this.$redo_client = this.$info_servers.prop("redo_description");
			this.$pinned_height_pct = cjs(0.5);

			var get_pinned_height_pct = _.bind(function() {
				if(this.$pinned_columns.length() === 0) {
					if(this.$dragging_client.get()) {
						return 0.3;
					} else {
						return 0;
					}
				} else {
					return this.$pinned_height_pct.get();
				}
			}, this);
			this.$obj_nav_y = cjs(function() {
				var obj_nav_pos = $("#obj_nav", this.element).position();
				return obj_nav_pos ? obj_nav_pos.top : 0;
			}, {context: this});
			_.delay(_.bind(function() {
				this.$obj_nav_y.invalidate();
			}, this), 500);
			this.$nav_height = cjs(function() {
				var obj_nav_y = this.$obj_nav_y.get();
				return (this.$window_inner_height.get() - obj_nav_y)*(1-get_pinned_height_pct());
			}, {context: this});
			this.$pinned_height = cjs(function() {
				var obj_nav_y = this.$obj_nav_y.get();
				return (this.$window_inner_height.get() - obj_nav_y)*get_pinned_height_pct();
			}, {context: this});

			this.$undo_desc = cjs(function() {
				var client = this.$undo_client.get();
				return client ? client.get() : false;
			}, { context: this});

			this.$redo_desc = cjs(function() {
				var client = this.$redo_client.get();
				return client ? client.get() : false;
			}, { context: this});

			var on_comm_mechanism_load = function(communication_mechanism) {
				this.client_socket = new ist.ProgramStateClient({
					ready_func: this.option("debug_ready"),
					comm_mechanism: communication_mechanism
				})
				.on("loaded", function (root_client, info_servers) {
					this.root_client = root_client;
					this.$info_servers.set(info_servers);
					on_load();
				}, this)
				.on("root_changed", function () {
					on_rootchange();
				}, this)
				.on("stringified_root", function(data) {
					downloadWithName(data.value, data.name+".ist");
					//window.open("data:text/plain;charset=utf-8," + data.value);
				}, this)
				.on("stringified_obj", function(data) {
					downloadWithName("COMPONENT:"+data.value, data.name+".istc");
					//window.open("data:text/plain;charset=utf-8,COMPONENT:" + data.value);
				}, this)
				.on("inspect", function(data) {
					$("#obj_nav", this.element).navigator("open_cobj", data);
				}, this);
				/*
				.on("message", function (data) {
					if(data.type === "upload_url") {
						var url = data.value;
						var code_container = $("<div />");
						var qrcode = new QRCode(code_container[0], {
							text: url,
							width: 128,
							height: 128,
							colorDark : "#000000",
							colorLight : "#ffffff",
							correctLevel : QRCode.CorrectLevel.H
						});
						var alert = $("<div />").addClass("upload_url")
												.appendTo(document.body)
												.append(code_container, $("<a />").attr({"href": url, "target": "_blank"}).text(url));
						$(window).on("mousedown.close_alert", function(event) {
							if(!$(event.target).parents().is(alert)) {
								alert.remove();
							}
						});
					} else if(data.type === "stringified_root") {
						window.open("data:text/plain;charset=utf-8," + data.value);
					} else if(data.type === "stringified_obj") {
						window.open("data:text/plain;charset=utf-8,COMPONENT:" + data.value);
					}
				}, this)
				*/
			};

			if(this.option("use_socket")) {
				interstate.async_js("/socket.io/socket.io.js", _.bind(function() {
					var socket_info = this.option("use_socket");
					var socket_wrapper = new ist.SocketCommWrapper(socket_info.client_id, false);
					on_comm_mechanism_load.call(this, socket_wrapper);
				}, this));
			} else {
				if(this.option("server_window") === window) {
					on_comm_mechanism_load.call(this, new ist.SameWindowCommWrapper(this.option("client_id"), 0));
				} else {
					on_comm_mechanism_load.call(this, new ist.InterWindowCommWrapper(this.option("server_window"), this.option("client_id")));
				}
			}

			$(window).on("keydown.editor_undo_redo", _.bind(function (event) {
				if (event.keyCode === 90 && (event.metaKey || event.ctrlKey)) {
					if (event.shiftKey) { this._redo(); }
					else { this._undo(); }
					event.stopPropagation();
					event.preventDefault();
				}
			}, this));
			this.element.on("dragstart.pin", _.bind(function(event) {
				this.$dragging_client.set(true);
				var targ = $(event.target),
					component_list = $(".components", this.element),
					pinned = $("#pinned", this.element);
				var clear_drag_info = function() {
												this.$dragging_client.set(false);
                                                component_list.add(pinned)	.removeClass("drop_indicator")
																			.off("dragover.pin drop.pin dragenter.pin dragleave.pin");
                                                targ.off("dragcancel.pin dragend.pin");
                                        };
				component_list.add(pinned)	.addClass("drop_indicator")
											.on("drop.pin", _.bind(function(e) {
												var client = targ.column("option", "client");
												if($(e.target).parents().is(".component_drop")) {
													this.client_socket.post({
														type: "save_component",
														cobj_id: client.cobj_id
													});
												} else {
													clear_drag_info.call(this);
													pinned.pinned("addClient", client);
												}
											}, this));
				
				targ.on("dragcancel.pin dragend.pin", _.bind(function(ev2) {
					clear_drag_info.call(this);
				}, this));
			}, this))
			.on("resize_pinned", _.bind(function(event) {
				var obj_nav_y = $("#obj_nav", this.element).position().top,
					obj_nav_height = Math.max(200, event.clientY - obj_nav_y),
					pinned_height = Math.max(200, window.innerHeight - obj_nav_height - obj_nav_y);

				this.$pinned_height_pct.set(pinned_height / (pinned_height + obj_nav_height));
			}, this));
			$(window).on("beforeunload.close_editor", _.bind(function () {
				this.destroy();
			}, this));

			this._addClassBindings();
			this._addEventListeners();
			this._addContentBindings();
		},
		_destroy: function () {
			this._removeContentBindings();
			this._removeEventListeners();
			this._removeClassBindings();
			this.$show_components.destroy();
			this.on_unload();

			this._super();
		},

		_undo: function() {
			this.client_socket.post_command("undo");
		},
		_redo: function() {
			this.client_socket.post_command("redo");
		},

		_addContentBindings: function() {
			editor_template({
				loading_state: this.loading_state,
				getNavigatorOptions: _.bind(function() {
					return {
						root_client: this.root_client,
						client_socket: this.client_socket,
						editor: this,
						height: this.$nav_height
					};
				}, this),
				getPinnedOptions: _.bind(function() {
					return {
						root_client: this.root_client,
						client_socket: this.client_socket,
						editor: this,
						columns: this.$pinned_columns,
						height: this.$pinned_height
					};
				}, this),
				undo: _.bind(this._undo, this),
				redo: _.bind(this._redo, this),
				show_components: this.$show_components,
				toggle_show_widgets: _.bind(function() {
					this.$show_components.set(!this.$show_components.get());
				}, this),
				getWidgetListOptions: _.bind(function() {
					return {
						info_servers: this.$info_servers,
						editor: this
					};
				}, this),
				undo_desc: this.$undo_desc,
				redo_desc: this.$redo_desc,
				dirty_program: this.$dirty_program,
				beginResizeAce: _.bind(function(event) {
					if(!$("table#cell_group", this.element).hasClass("disabled")) {
						var origY = event.clientY,
							height_diff = 0,
							origHeight = ace_editor.height();
						$(window).on("mousemove.resize_editor", _.bind(function(e) {
							height_diff = e.clientY - origY;
							var height = origHeight + height_diff;
							ace_editor.height(height);
							this.editor.resize();
						}, this)).on("mouseup.resize_editor", _.bind(function(e) {
							$(window).off(".resize_editor");
						}, this));
						event.preventDefault();
						event.stopPropagation();
					}
				}, this),
				dragging_client: this.$dragging_client
			}, this.element);
			var ace_editor = $("nav #ace_ajax_editor", this.element);
			ace_editor.css("width", "100%");
			this.editor = ace.edit(ace_editor[0]);
			this.editor.setHighlightActiveLine(false);
			this.editor.setShowPrintMargin(false);
			this.editor.renderer.setShowGutter(false); 
			this.editor.getSession().setMode("ace/mode/javascript");

			this._cellwidth_binding = cjs.bindCSS(ace_editor, "width", this.$window_inner_width.sub((this.$window_inner_width.le(767).iif(300, 300))).add("px"));
			this.$window_inner_width.onChange(function() {
				this.editor.resize();
			}, this);
			this._disable_editor();
		},
		_removeContentBindings: function() {
			this.editor.destroy();
			cjs.destroyTemplate(this.element);
			$(window).off("resize.owr");
			this._cellwidth_binding.destroy();
			this.$window_inner_width.destroy();
		},
		_addClassBindings: function() {
			if(this.option("full_window")) {
				$("html").addClass("full_window_editor");
			}
			this.element.addClass("editor_view");
		},
		_removeClassBindings: function() {
			if(this.option("full_window")) {
				$("html").removeClass("full_window_editor");
			}
			this.element.removeClass("editor_view");
		},

		_disable_editor: function() {
			$("table#cell_group", this.element).addClass("disabled");
			this.editor.setReadOnly(true);
		},

		_enable_editor: function() {
			$("table#cell_group", this.element).removeClass("disabled");
			this.editor.setReadOnly(false);
		},

		on_unload: function() {
			if(this.client_socket) {
				this.client_socket.destroy();
				delete this.client_socket;
			}
		},

		_addEventListeners: function() {
			this.element.on("command.editor", _.bind(this.on_command, this))
						.on("export.editor", _.bind(function(event) {
							var obj = event.obj;
							this.client_socket.post({
								type: "export_component",
								cobj_id: obj ? obj.cobj_id : false
							});
						}, this))
						.on("remove_storage.editor", _.bind(function(event) {
							this.client_socket.post({
								type: "remove_storage",
								name: event.name,
								storage_type: event.storage_type
							});
						}, this))
						.on("save_curr.editor", _.bind(function(event) {
							this.client_socket.post({
								type: "save_curr"
							});
						}, this))
						.on("save_curr_as.editor", _.bind(function(event) {
							this.client_socket.post({
								type: "save_curr_as",
								name: event.name
							});
						}, this))
						.on("create_program.editor", _.bind(function(event) {
							this.client_socket.post({
								type: "create_program",
								name: event.name
							});
						}, this))
						.on("rename_storage.editor", _.bind(function(event) {
							this.client_socket.post({
								type: "rename_program",
								from_name: event.from_name,
								to_name: event.to_name,
								storage_type: event.storage_type
							});
						}, this))
						.on("download_program.editor", _.bind(function(event) {
							this.client_socket.post({
								type: "download_program",
								name: event.name,
								storage_type: event.storage_type
							});
						}, this))
						.on("load_program.editor", _.bind(function(event) {
							this.client_socket.post({
								type: "load_program",
								name: event.name,
								storage_type: event.storage_type
							});
						}, this))
						.on("load_saved_file.editor", _.bind(function(event) {
							this.client_socket.post({
								type: "load_file",
								contents: event.filecontents,
								name: event.filename,
								also_load: event.also_load
							});
						}, this))
						.on("copy_component.editor", _.bind(function(event) {
							this.client_socket.post({
								type: "copy_component",
								name: event.name,
								target_obj_id: event.target_obj_id,
								above_below: event.above_below,
							});
						}, this))
						.on("begin_editing_cell", _.bind(function(event) {
							this.editor.setValue(event.initial_val, 1);

							this._enable_editor();
							$(event.textarea).editing_text("option", "helper", this.editor);
						}, this))
						.on("done_editing_cell", _.bind(function(event) {
							this.editor.setValue("");
							this._disable_editor();
						}, this))
						.on("add_highlight", _.bind(function(event) {
							var client = event.client,
								type = client.type ? client.type() : false;
							if(type === "stateful" || type === "dict") {
								this.client_socket.post({
									type: "add_highlight",
									cobj_id: client.cobj_id
								});
							}
						}, this))
						.on("remove_highlight", _.bind(function(event) {
							var client = event.client,
								type = client.type ? client.type() : false;
							if(type === "stateful" || type === "dict") {
								if(this.client_socket) { // this might happen after everything was destroyed
									this.client_socket.post({
										type: "remove_highlight",
										cobj_id: client.cobj_id
									});
								}
							}
						}, this)) ;
		},

		_removeEventListeners: function() {
			this.element.off(".editor");
		},

		getDraggingClientConstraint: function() {
			return this.$dragging_client;
		},

		on_command: function(event) {
			var type = event.command_type;
			var client, name, value, command, state, transition, statechart_puppet_id, parent_puppet_id;
			var command_str;

			if(type === "add_property") {
				client = event.client;
				var prop_type = event.prop_type;

				if(prop_type === "stateful") {
					value = new ist.StatefulObj(undefined, true);
					value.initialize({
						direct_protos: new ist.StatefulProp({ can_inherit: false, statechart_parent: value })
					});
				} else if(prop_type === "stateful_prop") {
					if(client.type() === "dict") {
						value = new ist.Cell({str: ''});
					} else {
						value = new ist.StatefulProp();
					}
				}

				command = new ist.SetPropCommand({
					in_effect: true,
					parent: { id: to_func(client.obj_id) },
					value: value,
					index: 0,
					name: event.prop_name
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;

					value.destroy();
					value = null;
				});
			} else if(type === "rename") {
				client = event.client;
				command = new ist.RenamePropCommand({
					in_effect: true,
					parent: { id: to_func(client.obj_id) },
					from: event.from_name,
					to: event.to_name
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if(type === "inherit") {
				client = event.client;
				//value = event.value;
				var prop_name = event.name;

				command = new ist.InheritPropCommand({
					in_effect: true,
					//parent: { id: to_func(client.cobj_id) },
					cobj: { id: to_func(client.cobj_id) },
					name: prop_name
					//value: { id: to_func(value.cobj_id) }
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if(type === "unset") {
				client = event.client;
				command = new ist.UnsetPropCommand({
					in_effect: true,
					parent: { id: to_func(client.obj_id) },
					name: event.name
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if(type === "set_stateful_prop_for_state") {
				client = event.prop;
				state = event.state;
				value = new ist.Cell({str: event.text || '', substantiated: false});

				command = new ist.SetStatefulPropValueCommand({
					in_effect: true,
					stateful_prop: { id: to_func(client.obj_id) },
					state: { id: to_func(state.cobj_id) },
					value: value
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
					value.destroy();
					value = null;
				});
			} else if(type === "unset_stateful_prop_for_state") {
				client = event.prop;
				state = event.state;

				command = new ist.UnsetStatefulPropValueCommand({
					in_effect: true,
					stateful_prop: { id: to_func(client.obj_id) },
					state: { id: to_func(state.cobj_id) }
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if(type === "set_str") {
				client = event.client;
				value = event.str;

				command = new ist.ChangeCellCommand({
					in_effect: true,
					cell: { id: to_func(client.cobj_id || client.obj_id) },
					str: value
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if(type === "add_state") {
				state = event.state;
				statechart_puppet_id = state.puppet_master_id || state.id(); 
				var substates = state.get_substates();

				var substates_size = _.size(substates);
				var state_name, make_start;

				if(substates_size === 0) {
					state_name = "init";
					make_start = true;
				} else {
					var orig_state_name = "state_" + substates_size;
					state_name = orig_state_name;
					var i = 1;
					while(_.has(substates, state_name)) {
						state_name = orig_state_name + "_" + i;
					}
					make_start = false;
				}

				command = new ist.AddStateCommand({
					in_effect: true,
					statechart: { id: to_func(statechart_puppet_id) },
					name: state_name,
					make_start: make_start
				});

				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if(type === "remove_state") {
				state = event.state;
				name = state.get_name("parent");
				parent_puppet_id = state.parent().puppet_master_id || state.parent().id();
				command = new ist.RemoveStateCommand({
					in_effect: true,
					statechart: { id: to_func(parent_puppet_id) },
					name: name
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if(type === "remove_transition") {
				transition = event.transition;
				var statechart = transition.root();
				command = new ist.RemoveTransitionCommand({
					in_effect: true,
					transition: { id: to_func(transition.puppet_master_id || transition.id()) },
					statechart: { id: to_func(statechart.puppet_master_id || transition.id()) }
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if(type === "set_type") {
				var to_type = event.type_name;
				name = event.prop_name;
				client = event.client;
				if(to_type === "stateful") {
					value = new ist.StatefulObj(undefined, true);
					value.initialize({
						direct_protos: new ist.StatefulProp({ can_inherit: false, statechart_parent: value })
					});
				} else if(to_type === "stateful_prop") {
					value = new ist.StatefulProp();
				} else if(to_type === "cell") {
					value = new ist.Cell();
				}

				command = new ist.SetPropCommand({
					in_effect: true,
					parent: { id: to_func(client.obj_id) },
					value: value,
					name: name
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
					value.destroy();
					value = null;
				});
			} else if(type === "add_transition") {
				var from_state = event.from;
				var to_state = event.to;
				state = from_state.root();
				statechart_puppet_id = state.puppet_master_id || state.id();
				var from_puppet_id = from_state.puppet_master_id || from_state.id(),
					to_puppet_id = to_state.puppet_master_id || to_state.id();
				event = new ist.ParsedEvent({str: "false", inert: true});
				command = new ist.AddTransitionCommand({
					in_effect: true,
					from: { id: to_func(from_puppet_id) },
					to: { id: to_func(to_puppet_id) },
					event: event,
					statechart: { id: to_func(statechart_puppet_id) }
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
					event.destroy();
					event = null;
				});
			} else if(type === "set_transition_to") {
				transition = event.transition;
				state = event.to;
				statechart_puppet_id = state.puppet_master_id || state.id();
				command = new ist.SetTransitionToCommand({
					in_effect: true,
					transition: { id: to_func(transition.puppet_master_id || transition.id()) },
					statechart: { id: to_func(statechart_puppet_id) }
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if(type === "set_transition_from") {
				transition = event.transition;
				state = event.from;
				statechart_puppet_id = state.puppet_master_id || state.id();
				command = new ist.SetTransitionFromCommand({
					in_effect: true,
					transition: { id: to_func(transition.puppet_master_id || transition.id()) },
					statechart: { id: to_func(statechart_puppet_id) }
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if(type === "rename_state") {
				state = event.state;
				var new_name = event.new_name;
				var old_name = state.get_name("parent");
				parent_puppet_id = state.parent().puppet_master_id || state.parent().id();
				command = new ist.RenameStateCommand({
					in_effect: true,
					statechart: { id: to_func(parent_puppet_id) },
					from: old_name,
					to: new_name
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if (type === 'set_transition_str') {
				transition = event.transition;
				var str = event.str;
				var transition_id = transition.puppet_master_id || transition.id();
				command = new ist.SetTransitionEventCommand({
					in_effect: true,
					transition: { id: to_func(transition_id) },
					event: str
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if (type === 'set_copies') {
				value = event.str;
				client = event.client;
				command = new ist.SetCopiesCommand({
					in_effect: true,
					parent: { id: to_func(client.obj_id) },
					value: value
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if (type === 'reset') {
				client = event.client;
				command = new ist.ResetCommand({
					in_effect: true,
					parent: { id: to_func(client.cobj_id) }
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if (type === 'make_concurrent') {
				state = event.state;
				var state_puppet_id = state.puppet_master_id || state.id();
				command = new ist.MakeConcurrentCommand({
					in_effect: true,
					statechart: { id: to_func(state_puppet_id) },
					concurrent: event.concurrent
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else if (type === 'move_prop') {
				var from_obj = event.from_obj;
				var from_name = event.from_name;
				var target_obj = event.target_obj;
				var target_name = event.target_name;
				var above_below = event.above_below;

				command = new ist.MovePropAboveBelowCommand({
					in_effect: true,
					from_obj: { id: to_func(from_obj.obj_id) },
					from_name: from_name,
					target_obj: { id: to_func(target_obj.obj_id) },
					target_name: target_name,
					above_below: above_below
				});
				command_str = this.client_socket.post_command(command, function() {
					command.destroy();
					command = null;
				});
			} else {
				console.log("Unhandled type " + type);
			}
			if(this.option("upload_usage")) {
				this.upload_event({
					type: "command",
					value: command_str
				});
			}
		}
	});

	ist.create_key_val_map = function(key_constraint, value_constraint) {
		var map = cjs.map({}),
			old_keys = [],
			old_vals = [];

		var live_fn = cjs.liven(function() {
			var keys = key_constraint.get() || [],
				vals = value_constraint.get() || [];

			var map_diff = ist.get_map_diff(old_keys, keys, old_vals, vals);

			_.each(map_diff.key_change, function(info) {
				map.rename(info.from, info.to);
			});
			_.each(map_diff.set, function(info) {
				map.put(info.key, info.value);
			});
			_.each(map_diff.unset, function(info) {
				map.remove(info.key);
			});
			_.each(map_diff.value_change, function(info) {
				map.put(info.key, info.to);
			});

			old_keys = keys;
			old_vals = vals;
		});

		var old_destroy = map.destroy;
		map.destroy = function() {
			old_destroy.apply(this, arguments);
			live_fn.destroy();
		};

		return map;
	};
	function to_func(value) {
		return function () { return value; };
	}

	function eventFire(el, etype) {
		if (el.fireEvent) {
			(el.fireEvent('on' + etype));
		} else {
			var evObj = document.createEvent('Events');
			evObj.initEvent(etype, true, false);
			el.dispatchEvent(evObj);
		}
	}

	function downloadWithName(data, name) {
		var is_chrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1,
			link;

/*
		console.log(name);
		if(is_chrome) {
			link = document.createElement("a");
			link.download = name;
			link.href = "data:," + data;
			eventFire(link, "click");
		} else {
			//window.open("data:text/plain;charset=utf-8," + data);
			link = document.createElement("a");
			link.download = name;
			link.href = "data:," + data;
			eventFire(link, "click");
		}
		*/
		link = $("<a />").attr({
				href: "data:text/plain;charset=utf-8," + data,
				alt: name,
				download: name
			});
		eventFire(link[0], "click");
	}
}(interstate, jQuery));

/*jslint nomen: true, vars: true, white: true */
/*jshint scripturl: true */
/*global interstate,esprima,able,uid,console,window,jQuery,Raphael,RedMap */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	cjs.registerCustomPartial("widgetList", {
		createNode: function(options) {
			return $("<div />").component_list(options);
		},
		destroyNode: function(node) {
			$(node).component_list("destroy");
		}
	});

	var tlate = cjs.createTemplate(
				"<div class='header'>" +
					"<h3>my programs</h3>" +
					"<p>whole files</p>" +
				"</div>" +
				"<div class='programs'>" +
					"{{#each programs}}" +
						"{{>widgetItem getWidgetItemOptions(this, '')}}" +
					"{{#else}}" +
						"{{#if !new_program}}" +
							"<div class='none'>no programs</div>" +
						"{{/if}}" +
					"{{/each}}" +
				"</div>" +
				"{{#if new_program}}" +
					"<div class='new_prog'>" +
						"{{>editing_text getDefaultSketchName()}}" +
						"<button type='button' class='btn btn-success btn-xs'>OK</button>" +
						"<button cjs-on-mousedown='cancel_newprog' type='button' class='btn btn-danger btn-xs'>Cancel</button>" +
					"</div>" +
				"{{/if}}" +
				"<div class='btn-group'>" +
					"<button disabled={{new_program}} class='new_sketch btn btn-sm btn-default' data-cjs-on-click='createNewSketch'>" +
						"<span class='glyphicon glyphicon-file'></span>" +
						" New" +
					"</button>" +
					"<button disabled={{disable_save_btn}} class='save_sketch btn btn-sm btn-default' data-cjs-on-click='saveSketch'>" +
						"{{#if dirty_program}}" +
							"<span class='glyphicon glyphicon-floppy-disk'></span>" +
							" Save" +
						"{{#else}}" +
							"<span class='glyphicon glyphicon-floppy-saved'></span>" +
							" Saved" +
						"{{/if}}" +
					"</button>" +
					"<button disabled={{new_program}} class='saveas_sketch btn btn-sm btn-default' data-cjs-on-click='saveSketchAs'>" +
						"<span class='glyphicon glyphicon-floppy-save'></span>" +
						" Save as..." +
					"</button>" +
					"<div disabled={{new_program}} style='position:relative' id='import_btn' class='btn btn-sm btn-default'>" +
						"<span class='glyphicon glyphicon-cloud-upload'></span>" +
						" Import" +
						"<input multiple data-cjs-on-change='onImport' style='width:100%;position:absolute;top:0px;left:-3px;height:30px;opacity:0' title='Import' type='file'/>" +
					"</div>" +
				"</div>" +
				"<div class='header components_header'>" +
					"<h3>my components</h3>" +
					"<p>reusable parts</p>" +
				"</div>" +

				"<div class='components component_drop' data-cjs-on-dragover=dragoverComponent data-cjs-on-dragout=dragoutComponent data-cjs-on-dragenter=dragEnterComponent data-cjs-on-dragleave=dragLeaveComponent>" +
					"{{#each components}}" +
						"{{>widgetItem getWidgetItemOptions(this, 'component')}}" +
					"{{#else}}" +
						"<div class='none component_drop'>(drop objects here)</div>" +
					"{{/each}}" +
				"</div>" +

				"<div class='toolbar'>" +
					"<div disabled={{new_program}} style='position:relative' id='import_btn' class='btn btn-sm btn-default'>" +
						"<span class='glyphicon glyphicon-cloud-upload'></span>" +
						" Import" +
						"<input multiple data-cjs-on-change='onImport' style='width:100%;position:absolute;top:0px;left:-3px;height:30px;opacity:0' title='Import' type='file'/>" +
					"</div>" +
				"</div>"
				);
	
	$.widget("interstate.component_list", {
		options: {
			info_servers: false,
			editor: false
		},
		_create: function() {
			var info_servers = this.option("info_servers").get();

			this.$program_names = cjs(function() {
				return info_servers.programs.get();
			});
			this.$component_names = cjs(function() {
				return info_servers.components.get();
			});
			this.$loaded_program = cjs(function() {
				return info_servers.loaded_program.get();
			});
			this.$dirty_program = cjs(function() {
				return info_servers.dirty_program.get();
			});
			this.$dirty_program = cjs(function() {
				return info_servers.dirty_program.get();
			});
			this.$new_program = cjs(false);
			this.$dragging = this.option("editor").getDraggingClientConstraint();

			this._addContentBindings();
			this._addClassBindings();
		},
		_destroy: function() {
			this._removeContentBindings();
			this._removeClassBindings();

			this._super();
		},
		_addClassBindings: function() {
			this.element.addClass("component_list");
		},
		_removeClassBindings: function() {
		},
		_addContentBindings: function() {
			this.element.on('confirm_value', _.bind(function(event) {
							var event_type;
							if(this.__next_action === 'create') {
								event_type = "create_program";
							} else if(this.__next_action === 'saveAs') {
								event_type = "save_curr_as";
							} else {
								return;
							}

							var e = new $.Event(event_type);
							e.name = event.value;
							this.element.trigger(e);
							
							this.$new_program.set(false);
							delete this.__next_action;
						}, this))
						.on('cancel_value', _.bind(function(event) {
							this.$new_program.set(false);
						}, this));

			tlate({
				programs: this.$program_names,
				components: this.$component_names,
				cancel_newprog: _.bind(function(event) {
					$(".new_prog > textarea", this.element).editing_text("cancel");
					event.preventDefault();
					event.stopPropagation();
					this.$new_program.set(false);
					return false;
				}, this),
				new_program: this.$new_program,
				dirty_program: this.$dirty_program,
				disable_save_btn: (this.$dirty_program.not()).or(this.$new_program),
				createNewSketch: _.bind(function() {
					this.__next_action = 'create';
					this.$new_program.set(true);
				}, this),
				saveSketch: _.bind(function() {
					var e = new $.Event("save_curr");
					this.element.trigger(e);
				}, this),
				saveSketchAs: _.bind(function() {
					this.__next_action = 'saveAs';
					this.$new_program.set(true);
				}, this),
				getWidgetItemOptions: _.bind(function(name, type) {
					return {
						name: name,
						selected: this.$loaded_program.eqStrict(name),
						storage_type: type,
						hover_tip: type === "component" ? "drag & drop in" : "",
						editor: this.option("editor")
					};
				}, this),
				getDefaultSketchName: _.bind(function() {
					var names = this.$program_names.get(),
						original_name = "sketch_"+(names.length+1),
						i = 1,
						name = original_name;

					while(names.indexOf(name)>=0) {
						name = original_name + "_" + i;
						i++;
					}
					return name;
				}, this),
				onImport: _.bind(function(event) {
					var files = event.target.files || event.dataTransfer.files;
					if(files && files.length > 0) {
						var also_load_index = files.length-1;
						_.each(files, function(file, index) {
							var fr = new FileReader();
							fr.onload = _.bind(function() {
								var result = fr.result,name = file.name;
								_.defer(_.bind(function() {
									var event = new $.Event("load_saved_file");
									event.filecontents = result;
									event.filename = name;
									event.also_load = also_load_index === index;

									this.element.trigger(event);
								}, this));

								delete fr.onload;
								fr = null;
							}, this);
							fr.readAsText(file);
						}, this);
					}
				}, this),
				dragoverComponent: _.bind(function(event) {
					event.preventDefault();
					event.stopPropagation();
					return false;
				}, this),
				dragoutComponent: _.bind(function(event) {
					event.preventDefault();
					event.stopPropagation();
					return false;
				}, this),
				dragEnterComponent: _.bind(function(event) {
					event.preventDefault();
					event.stopPropagation();
					return false;
				}, this),
				dragLeaveComponent: _.bind(function(event) {
					event.preventDefault();
					event.stopPropagation();
					return false;
				}, this)
			}, this.element);
		},
		_removeContentBindings: function() {
			cjs.destroyTemplate(this.element);
		},
		save_curr: function(e) {
			var inp = $("<input type='text'>").insertBefore(e.target).focus();
			inp.on("blur", function() {
				inp.remove();
			}).on("keydown", _.bind(function(event) {
				if(event.keyCode === 13) {
					var val = inp.val();
					if(val.length > 0) {
						var new_event = new $.Event("save_curr");
						new_event.name = val;
						new_event.storage_type = "";
						this.element.trigger(new_event);
					}
					inp.remove();
				} else if(event.keyCode === 27) {
					inp.remove();
				}
			}, this));
			
		},
		show_drag_over: function() {
			$(this.element).addClass("drop_target");
			if(!this.hasOwnProperty("overlay")) {
				this.overlay = $("<div />")	.addClass("overlay")
											.css({
												"background-color": "#555",
												"opacity": "0.8",
												"position": "absolute",
												//"left": "0px",
												//"top": "0px",
												"width": "100%",
												"height": "100%",
												"pointer-events": "none",
												"border": "10px dashed #DDD",
												"box-sizing": "border-box"
											})
											.prependTo(this.element);
			}
		},

		hide_drag_over: function() {
			$(this.element).removeClass("drop_target");
			this.overlay.remove();
			delete this.overlay;
		},
	});

	cjs.registerCustomPartial("widgetItem", {
		createNode: function(options) {
			return $("<div />").component_item(options);
		},
		destroyNode: function(node) {
			$(node).component_item("destroy");
		}
	});

	var witem_tlate = cjs.createTemplate(
					"<div data-name='{{name}}' data-cjs-on-click='load_program'>" +
						"{{#fsm name_edit_state}}" +
							"{{#state idle}}" +
								"{{name}}" +
								"<span class='hover_tip'>{{hover_tip}}</span>" +
							"{{#state editing}}" +
								"{{>editing_text name 'input'}}" +
						"{{/fsm}}" +
					"</div>" +
					"{{#if show_menu}}" +
						"<ul class='menu'>" +
							"<li class='menu-item' data-action='export'>Export</li>" +
							"<li class='menu-item' data-action='delete'>Delete</li>" +
							"<li class='menu-item' data-action='rename'>Rename</li>" +
						"</ul>" +
					"{{/if}}"
					);
	
	$.widget("interstate.component_item", {
		options: {
			name: "",
			selected: false,
			storage_type: "",
			hover_tip: "",
			editor: false
		},
		_create: function() {
			this.$name = this.option("name");
			this.$selected = this.option("selected");
			this.$dragging = this.option("editor").getDraggingClientConstraint();

			var elem = this.element;
			this.name_edit_state = cjs	.fsm("idle", "editing")
										.startsAt("idle")
										.addTransition('editing', 'idle', function(dt) {
											elem.on('confirm_value', dt);
										})
										.addTransition('editing', 'idle', function(dt) {
											elem.on('cancel_value', dt);
										})
										.on('editing->idle', function(event) {
											if(event.type === 'confirm_value') {
												this._emit_new_name(event.value);
											}
										}, this);
			if(this.option("storage_type") === "component") {
				this.element.attr("draggable", true)
							.on("dragstart.ondragstart", _.bind(this.on_drag_start, this));
			}

			this._addMenu();
			this._addContentBindings();
			this._addClassBindings();
		},
		_destroy: function() {
			this._removeContentBindings();
			this._removeClassBindings();
			this._removeMenu();

			this._super();
		},
		_addMenu: function() {
			this.$show_menu  = cjs(false);
			this.menu_state = cjs.fsm("hidden", "holding", "on_release", "on_click")
									.addTransition("hidden", "holding", cjs.on("contextmenu", this.element[0]))
									.addTransition("holding", "on_click", cjs.on("mouseup"))
									.addTransition("holding", "on_release", cjs.on("timeout", 500))
									.addTransition("holding", "hidden", cjs.on("keydown").guard('keyCode', 27))
									.addTransition("on_click", "hidden", cjs.on("keydown").guard('keyCode', 27))
									.addTransition("on_release", "hidden", cjs.on("keydown").guard('keyCode', 27))
									.startsAt("hidden");
			var on_mup_holding = this.menu_state.addTransition("holding", "hidden"),
				on_mup_orelease = this.menu_state.addTransition("on_release", "hidden"),
				on_mup_oclick = this.menu_state.addTransition("on_click", "hidden");

			this.menu_state.on("hidden->holding", function(event) {
				this.$show_menu.set(true);
				event.stopPropagation();
				event.preventDefault();
				var my_position = this.element.position();
				
				return false;
			}, this);

			var on_click = function(event) {
				$(window).add("ul.menu > li", this.element).off('.menu_item');
				$("ul.menu > li", this.element).on('click.menu_item', _.bind(function(e) {
					this.on_menu_action(e.target.getAttribute('data-action'));
					on_mup_oclick(e);
					e.stopPropagation();
					e.preventDefault();
				}, this));
				$(window).on('mousedown.menu_item', function(e) {
					if(!$(e.target).parents().is($("ul.menu", this.element))) {
						on_mup_oclick(e);
						e.stopPropagation();
						e.preventDefault();
					}
				});
			},
			on_hold = function(event) {
				$("ul.menu > li", this.element).on('mouseup.menu_item', _.bind(function(e) {
					this.on_menu_action(e.target.getAttribute('data-action'));
					on_mup_holding(e);
					on_mup_orelease(e);
					e.stopPropagation();
					e.preventDefault();
				}, this));

				$(window).on('mouseup.menu_item', function(e) {
					if(!$(e.target).parents().is($("ul.menu", this.element))) {
						on_mup_holding(e);
						on_mup_orelease(e);
						e.stopPropagation();
						e.preventDefault();
					}
				});
			},
			on_hidden = function(event) {
				this.menu_state .off("on_click", on_click, this)
								.off("holding", on_hold, this)
								.off("hidden", on_hidden, this);
				this.$show_menu.set(false);
				$(window).add("ul.menu > li", this.element).off('.menu_item');
			};
			this.menu_state.on("on_click", on_click, this);
			this.menu_state.on("holding", on_hold, this);
			this.menu_state.on("hidden", on_hidden, this);
		},
		_removeMenu: function() {
			$("ul.menu > li", this.element).off('.menu_item');
			$(window).off('.menu_item');
			this.menu_state.destroy();
			this.$show_menu.destroy();
		},

		_emit_new_name: function(str) {
			if(str.length>0) {
				var event = new $.Event("rename_storage");
				event.from_name = cjs.get(this.$name);
				event.to_name = str;
				event.storage_type = this.option("storage_type");
				this.element.trigger(event);
			}
		},
		_addContentBindings: function() {
			witem_tlate({
				name: this.$name,
				selected: this.$selected,
				show_menu: this.$show_menu,
				load_program: _.bind(function(event) {
					if(!this.option("type")) {
						var e = new $.Event("load_program");
						e.storage_type = this.option("storage_type");
						e.name = $(event.target).attr("data-name");
						this.element.trigger(e);
					}
				}, this),
				hover_tip: this.option("hover_tip"),
				name_edit_state: this.name_edit_state
			}, this.element);
		},
		begin_rename: function() {
			this.name_edit_state._setState('editing');
		},
		_removeContentBindings: function() {
			cjs.destroyTemplate(this.element);
		},
		_addClassBindings: function() {
			this._cssBinding = cjs.bindClass(this.element, "program", "entry",
											this.$selected.iif("selected", ""),
											this.$show_menu.iif("menuized", ""));
		},
		_removeClassBindings: function() {
			this._cssBinding.destroy();
		},

		on_menu_action: function(action_name) {
			var event;
			if(action_name === 'delete') {
				event = new $.Event("remove_storage");
				event.name = cjs.get(this.$name);
				event.storage_type = this.option("storage_type");
				this.element.trigger(event);
			} else if(action_name === 'rename') {
				this.begin_rename();
			} else if(action_name === 'export') {
				event = new $.Event("download_program");
				event.name = cjs.get(this.$name);
				event.storage_type = this.option("storage_type");
				this.element.trigger(event);
			}
		},
		on_drag_start: function(event) {
			this.element.addClass("dragging");
			var name = this.option("name");
			this.$dragging.set(name);
			event.preventDefault();
			event.stopPropagation();
			var curr_target = false;
			var above_below = false;
			var on_mmove = function(e) {
				above_below = 2 * e.offsetY > curr_target.height() ? "below" : "above";
				curr_target.addClass(above_below === "above" ? "dragtop" : "dragbottom");
				curr_target.removeClass(above_below === "above" ? "dragbottom" : "dragtop");
			};
			var on_mover_child = function(e) {
				curr_target = $(this);
				curr_target.addClass("dragtop");
				curr_target.on("mousemove", on_mmove);
			};
			var on_mout_child = function(e) {
				if(curr_target) {
					curr_target.removeClass("dragtop dragbottom");
					curr_target.off("mousemove", on_mmove);
					curr_target = false;
				}
			};
			var on_mup = _.bind(function() {
				this.$dragging.set(false);
				targets.off("mouseover", on_mover_child);
				targets.off("mouseout", on_mout_child);
				$(window).off("mouseup", on_mup);
				this.element.removeClass("dragging");
				if(curr_target) {
					var my_obj = this.option("obj"),
						my_name = this.option("name");
					var target_name, target_obj;
					if(curr_target.is("tr.no_children")) {
						target_obj = curr_target.parents(".col").column("option", "client");
						target_name = false;
					} else {
						target_obj = curr_target.prop("option", "obj");
						target_name = curr_target.prop("option", "name");
					}

					curr_target.removeClass("dragtop dragbottom");
					curr_target.off("mousemove", on_mmove);
					curr_target = false;


					var event = new $.Event("copy_component");
					event.name = name;
					event.target_obj_id = target_obj.obj_id;
					event.above_below = above_below;
					this.element.trigger(event);
				}
			}, this);
			var targets = $("tr.child").not(".inherited").add("tr.no_children");

			targets.on("mouseover", on_mover_child);
			targets.on("mouseout", on_mout_child);
			$(window).on("mouseup", on_mup);
		},
	});
}(interstate, jQuery));

/*jslint nomen: true, vars: true, white: true */
/*jshint scripturl: true */
/*global interstate,esprima,able,uid,console,window,jQuery,Raphael */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var navigator_template = cjs.createTemplate(
		"{{#each columns}}" +
			"{{> col getColumnOptions(this, @index) }}" +
		"{{/each}}"
	);

	cjs.registerCustomPartial("navigator", {
		createNode: function(options) {
			return $("<div />").navigator(options);
		},
		destroyNode: function(node) {
			$(node).navigator("destroy");
		},
		onAdd: function(node, options) {
			if(!$(node).data("interstate-navigator")) {
				$(node).navigator(options);
			}
		},
		onRemove: function(node) {
			$(node).navigator("destroy");
		}
	});

	$.widget("interstate.navigator", {
		options: {
			root_client: false,
			single_col: false,
			client_socket: false,
			editor: false,
			height: false
		},
		_create: function() {
			var client = this.option("root_client");
			client.signal_interest();

			this.$columns = cjs([client]);
			this.$selected_column = this.$columns.itemConstraint(cjs(_.bind(this.$columns.length, this.$columns)).sub(1));

			this.element.on("child_select.nav", _.bind(this.on_child_select, this))
						.on("header_click.nav", _.bind(this.on_header_click, this))
						.on("open_cobj.nav", _.bind(this.open_cobj, this));

			this._add_content_bindings();
			this._add_class_bindings();
			this._add_destroy_check();
		},
		_destroy: function() {
			var client = this.option("root_client");

			this.element.off(".nav");

			this._remove_class_bindings();
			this._remove_content_bindings();
			this._remove_destroy_check();

			client.signal_destroy();

			this._super();
		},
		_setOption: function(key, value) {
			this._super(key, value);
		},
		_add_content_bindings: function() {
			var client_socket = this.option("client_socket");
			navigator_template({
				columns: this.$columns,
				getColumnOptions: _.bind(function(client, index) {
					return {
						client: client,
						client_socket: client_socket,
						is_curr_col: this.$selected_column.eqStrict(client),
						columns: this.$columns,
						column_index: index,
						editor: this.option("editor")
					};
				}, this)
			}, this.element);
		},

		_remove_content_bindings: function() {
			cjs.destroyTemplate(this.element);
		},

		_add_class_bindings: function() {
			this.element.attr("id", "obj_nav");
			this._height_binding = cjs.bindCSS(this.element, "height", this.option("height").add("px"));
		},

		_remove_class_bindings: function() {
			this.element.attr("id", "");
			this._height_binding.destroy();
		},
		_add_destroy_check: function() {
			var old_cols = [],
				ondestroy = _.bind(function(client) {
					var index = this.$columns.indexOf(client);
					this.$columns.splice(index, this.$columns.length()-index);
				}, this);

			this._destroy_check_fn = cjs.liven(function() {
				_.each(old_cols, function(c) {
					c.off('begin_destroy', ondestroy);
				}, this);
				var cols = this.$columns.toArray();
				_.each(cols, function(c) {
					c.on('begin_destroy', ondestroy);
				}, this);
				old_cols = cols;
			}, {
				context: this
			});
		},
		_remove_destroy_check: function() {
			this._destroy_check_fn.destroy();
		},

		on_child_select: function(event, child) {
			if(child instanceof ist.WrapperClient && (child.type() === "dict" || child.type() === "stateful")) {
				var column_index = this.$columns.indexOf(child);
				if(column_index >= 0) {
					this.$columns.splice(column_index, this.$columns.length()-column_index);
				} else {
					var parent_col = $(event.target).column("option", "client");
					column_index = this.$columns.indexOf(parent_col);
					this.$columns.splice(column_index+1, this.$columns.length()-column_index - 1, child);
				}
			} else {
				this.on_header_click(event, $(event.target).column("option", "client"));
			}
		},
		on_header_click: function(event, client) {
			var column_index = this.$columns.indexOf(client);
			if(column_index >= 0) {
				this.$columns.splice(column_index + 1, this.$columns.length()-column_index-1);
			}
		},
		open_cobj: function(event) {
			var client_socket = this.option("client_socket");
			var cobj_id = event.cobj_id;
			client_socket.once("get_ptr_response", function(message) {
				if(message.cobj_id === cobj_id) {
					var cobjs = message.cobjs,
						wrapper_clients = _.map(cobjs, function(cobj) {
							return client_socket.get_wrapper_client(cobj);
						});
					this.$columns.setValue(wrapper_clients);
				}
			}, this);
			client_socket.post({type: "get_ptr", cobj_id: cobj_id});
		}
	});
}(interstate, jQuery));

/*jslint nomen: true, vars: true, white: true */
/*jshint scripturl: true */
/*global interstate,esprima,able,uid,console,window,jQuery,Raphael */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var pinned_template = cjs.createTemplate(
		"{{#if show_instructions}}" +
			"<div class='instructions'>" +
				"Drop here to pin" +
			"</div>" +
		"{{#else}}" +
			"{{#if columns.length()>0}}" +
				"<div class='resize_bar' data-cjs-on-mousedown=beginResize />" +
			"{{/if}}" +
			"<div class='pinned_cols'>" +
				"{{#each columns}}" +
					"{{> col getColumnOptions(this, @index) }}" +
				"{{/each}}" +
			"</div>" +
		"{{/if}}"
	);

	cjs.registerCustomPartial("pinned", {
		createNode: function(options) {
			return $("<div />").pinned(options);
		},
		destroyNode: function(node) {
			$(node).pinned("destroy");
		},
		onAdd: function(node, options) {
			if(!$(node).data("interstate-pinned")) {
				$(node).pinned(options);
			}
		},
		onRemove: function(node) {
			$(node).pinned("destroy");
		}
	});

	$.widget("interstate.pinned", {
		options: {
			single_col: false,
			client_socket: false,
			editor: false,
			root_client: false,
			columns: false
		},
		_create: function() {
			this.$columns = this.option("columns");
			this.$dragging = this.option("editor").getDraggingClientConstraint();

			this.$show_instructions = cjs(function() {
				if(this.$columns.length() === 0) {
					return this.$dragging.get();
				}
				return false;
			}, {context: this});

			this.element.on("child_select.nav", _.bind(this.on_child_select, this))
						.on("close_column.nav", _.bind(this.on_close_col, this))
						.on("prev_column.nav", _.bind(this.on_prev_col, this))
						.on("open_cobj.nav", _.bind(this.open_cobj, this));

			this._add_content_bindings();
			this._add_class_bindings();
			this._add_destroy_check();
			this.element.on("dragover", _.bind(this.dragoverComponent, this))
						.on("dragout", _.bind(this.dragoutComponent, this))
						.on("dragenter", _.bind(this.dragEnterComponent, this))
						.on("dragleave", _.bind(this.dragLeaveComponent, this));
		},
		_destroy: function() {
			this.element.off(".nav");

			this._remove_class_bindings();
			this._remove_content_bindings();
			this._remove_destroy_check();

			this._super();
		},
		_setOption: function(key, value) {
			this._super(key, value);
		},
		_add_content_bindings: function() {
			var client_socket = this.option("client_socket");
			pinned_template({
				columns: this.$columns,
				getColumnOptions: _.bind(function(client, index) {
					return {
						client: client,
						client_socket: client_socket,
						is_curr_col: cjs(true),
						editor: this.option("editor"),
						pinned: true
					};
				}, this),
				show_instructions: this.$show_instructions,
				beginResize: _.bind(function(event) {
					var origY = event.clientY;

					$(window).on("mousemove.resize_pinned", _.bind(function(e) {
						var event = new $.Event("resize_pinned");
						event.clientY = e.clientY;

						this.element.trigger(event);

					}, this)).on("mouseup.resize_pinned", _.bind(function(e) {
						$(window).off(".resize_pinned");
					}, this));
					event.preventDefault();
					event.stopPropagation();
				}, this)
			}, this.element);
		},

		_remove_content_bindings: function() {
			cjs.destroyTemplate(this.element);
		},

		_add_class_bindings: function() {
			this.element.attr("id", "pinned");
			this._height_binding = cjs.bindCSS(this.element, "height", this.option("height").add("px"));
		},

		_remove_class_bindings: function() {
			this._height_binding.destroy();
			this.element.attr("id", "");
		},
		_add_destroy_check: function() {
			var old_cols = [],
				ondestroy = _.bind(function(client) {
					var index = this.$columns.indexOf(client);
					this.$columns.splice(index, this.$columns.length()-index);
				}, this);

			this._destroy_check_fn = cjs.liven(function() {
				_.each(old_cols, function(c) {
					c.off('begin_destroy', ondestroy);
				}, this);
				var cols = this.$columns.toArray();
				_.each(cols, function(c) {
					c.on('begin_destroy', ondestroy);
				}, this);
				old_cols = cols;
			}, {
				context: this
			});
		},
		_remove_destroy_check: function() {
			this._destroy_check_fn.destroy();
		},

		on_child_select: function(event, child) {
			if(child instanceof ist.WrapperClient && (child.type() === "dict" || child.type() === "stateful")) {
				var column_index = $(event.target).index();
				if(column_index >= 0) {
					this.$columns.splice(column_index, 1, child);
				}
			}
		},
		on_close_col: function(event) {
			var column_index = $(event.target).index();
			if(column_index >= 0) {
				this.$columns.splice(column_index, 1);
			}
		},
		on_prev_col: function(event) {
			var client = $(event.target).column("option", "client"),
				column_index = $(event.target).index();
			if(column_index >= 0) {
				var client_socket = this.option("client_socket"),
					cobj_id = client.cobj_id;

				client_socket.once("get_ptr_response", function(message) {
					if(message.cobj_id === cobj_id) {
						var cobjs = message.cobjs;
						if(cobjs.length > 1) {
							var wrapper_client = client_socket.get_wrapper_client(cobjs[cobjs.length-2]);
							this.$columns.splice(column_index, 1, wrapper_client);
						}
					}
				}, this);
				client_socket.post({type: "get_ptr", cobj_id: cobj_id});
			}
		},

		addClient: function(client) {
			this.$columns.unshift(client);
		},
		open_cobj: function(event) {
			var column_index = $(event.target).parents(".col").index();
			if(column_index >= 0) {
				var client_socket = this.option("client_socket"),
					cobj_id = event.cobj_id;
				client_socket.once("get_ptr_response", function(message) {
					if(message.cobj_id === cobj_id) {
						var cobjs = message.cobjs,
							wrapper_client = client_socket.get_wrapper_client(cobjs[cobjs.length-1]);
						this.$columns.splice(column_index, 1, wrapper_client);
					}
				}, this);
				client_socket.post({type: "get_ptr", cobj_id: cobj_id});
			}
		},


		dragoverComponent: _.bind(function(event) {
			event.preventDefault();
			event.stopPropagation();
			return false;
		}, this),
		dragoutComponent: _.bind(function(event) {
			event.preventDefault();
			event.stopPropagation();
			return false;
		}, this),
		dragEnterComponent: _.bind(function(event) {
			event.preventDefault();
			event.stopPropagation();
			return false;
		}, this),
		dragLeaveComponent: _.bind(function(event) {
			event.preventDefault();
			event.stopPropagation();
			return false;
		}, this)
	});
}(interstate, jQuery));

/*jslint nomen: true, vars: true, white: true */
/*jshint scripturl: true */
/*global interstate,esprima,able,uid,console,window,jQuery,Raphael */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	cjs.registerCustomPartial("col", {
		createNode: function(options) {
			return $("<table />").column(options);
		},
		destroyNode: function(node) {
			$(node).column("destroy");
		}
	});

	var column_template = cjs.createTemplate(
		"<tbody>" +
			"<tr class='header'>" +
				"<th colspan={{num_curr_values+1}} class='obj_name'>" +
					"{{#if pinned && !is_root}}" +
						"<span title='Previous' data-cjs-on-click='prev_col' class='prev_btn glyphicon glyphicon-chevron-left'/>" +
					"{{/if}}" +
					"<h2 data-cjs-on-mouseover='headerMOver' data-cjs-on-mouseout='headerMOut' data-cjs-on-click='headerClicked'>" +
						"{{ci}}{{name}}" +
						"{{#if is_template}}" +
							"[{{curr_copy_index}}]" +
						"{{/if}}" +
					"</h2>" +
					"{{#if pinned}}" +
						"<span title='Close' data-cjs-on-click='close_col' class='close_btn glyphicon glyphicon-remove'/>" +
					"{{/if}}" +
				"</th>" +
				"{{#if stateful}}" +
					"<th rowspan='{{is_template ? 4 : 3}}' class='statechart_cell'>" +
						"{{#if is_curr_col}}" +
							"{{statechart_view}}" +
						"{{/if}}" +
					"</th>" +
				"{{#else}}" +
					"<th rowspan='2'></th>" +
				"{{/if}}" +
			"</tr>" +

			"{{#if is_curr_col}}" +
				"{{#if stateful}}" +
					"<tr class='copies_spec'>" +
						"<td colspan='{{num_curr_values+1}}' class='copies_spec'>" +
							"<span class='copies_label'>Copies: </span>" +
							"{{> propCell getCopiesCellOptions() }}" +
						"</td>" +
					"</tr>" +
				"{{/if}}" +

				"<tr class='add_prop'>" +
					"<td colspan='{{num_curr_values+1}}' class='add_prop'>" +
						"<div class='add_prop' data-cjs-on-click=addProperty>Add Field</div>" +
					"</td>" +
				"</tr>" +
				"{{#if is_template}}" +
					"<tr class='switch_copy'>" +
						"<td></td>" +
						"{{#if show_prev_value}}" +
							"<td class='prev_copy' data-cjs-on-mouseover='prevMOver' data-cjs-on-mouseout='prevMOut' data-cjs-on-click='selectPrevClient'>" +
								"<span class='glyphicon glyphicon-chevron-left'></span>" +
							"</td>" +
						"{{/if}}" +
						"<td class='curr_copy' data-cjs-on-mouseover='currMOver' data-cjs-on-mouseout='currMOut'>" +
							"copy {{curr_copy_index+1}} of {{num_instances}}" +
						"</td>" +
						"{{#if show_next_value}}" +
							"<td class='next_copy' data-cjs-on-mouseover='nextMOver' data-cjs-on-mouseout='nextMOut' data-cjs-on-click='selectNextClient'>" +
								"<span class='glyphicon glyphicon-chevron-right'></span>" +
							"</td>" +
						"{{/if}}" +
					"</tr>" +
				"{{/if}}" +
			"{{/if}}" +
			"{{#each builtins}}" +
				"{{>prop getPropertyViewOptions(this, true)}}" +
			"{{/each}}" +

			"{{#if adding_field&&is_curr_col}}" +
				"<tr class='new_field'>" +
					"<td class='name'><input placeholder='Field name' class='name' /></td>" +
					"<td class='type'>" +
						"<select class='type'>" + 
							"<option value='stateful'>Object</option>" +
							"<option value='stateful_prop'>Property</option>" +
						"</select>" + 
					"</td>" +
					"<td class='confirm_field'>" +
						"<a href='javascript:void(0)'>OK</a>" +
					"</td>" +
				"</tr>" +
			"{{/if}}" +

			"{{#each children}}" +
				"{{>prop getPropertyViewOptions(this)}}" +
				"{{#else}}" +
					"{{#if !adding_field && builtins.length===0}}" +
						"<tr class='no_children'>" +
							"<td colspan='{{num_curr_values+2}}'>No fields</td>" +
						"</tr>" +
					"{{/if}}" +
			"{{/each}}" +
		"</tbody>"
		);

	$.widget("interstate.column", {
		options: {
			client: false,
			prev_col: false,
			show_prev: false,
			is_curr_col: false,
			show_source: true,
			curr_copy_client: false,
			client_socket: false,
			selected_prop_name: false,
			curr_copy_index: false,
			close_button: false,
			columns: false,
			column_index: -1,
			editor: false,
			pinned: false
		},

		_create: function() {
			var client = this.option("client");
			client.signal_interest();

			this.element.attr("draggable", true);
			this.$dragging = this.option("editor").getDraggingClientConstraint();

			var root_client = this.option("editor").root_client; 
			this.is_root = client === root_client;
			
			this.$adding_field = cjs(false);
			if(this.option("pinned")) {
				this.$selected_prop = cjs(false);
			} else {
				this.$selected_prop = this.option("columns").itemConstraint(this.option("column_index")+1);
			}

			this.$is_curr_col = this.option("is_curr_col");

			this.$name = client.get_$("get_name");
			this.$copies_obj = client.get_$("copies_obj");
			this.$is_template = client.get_$("is_template");
			this.$instances = client.get_$("instances");

			this.$num_instances = this.$instances.prop("length");

			this.$curr_copy_index = cjs(0);
			this.$curr_copy_client = cjs(function() {
				if(this.$is_template.get()) {
					var instances = this.$instances.get(),
						curr_copy_index = this.$curr_copy_index.get();
					if(instances[curr_copy_index]) {
						return instances[curr_copy_index];
					} else {
						return false;
					}
				} else {
					return client;
				}
			}, {context: this});

			this.$prev_copy_client = cjs(function() {
				if(this.$is_template.get()) {
					var instances = this.$instances.get(),
						copy_index = this.$curr_copy_index.get()-1;
					if(instances[copy_index]) {
						return instances[copy_index];
					}
				}

				return false;
			}, {context: this});

			this.$next_copy_client = cjs(function() {
				if(this.$is_template.get()) {
					var instances = this.$instances.get(),
						copy_index = this.$curr_copy_index.get()+1;
					if(instances[copy_index]) {
						return instances[copy_index];
					}
				}

				return false;
			}, {context: this});

			this.$show_prev_value = cjs(this.$prev_copy_client);
			this.$show_next_value = cjs(this.$next_copy_client);

			this.$num_curr_values = this.$is_template.iif(this.$prev_copy_client.iif(2,1).add(this.$next_copy_client.iif(1,0)), 1);

			this.$column_info = ist.indirectClient(this.$curr_copy_client, ["children", true], "builtin_children");
			this.$children = this.$column_info.itemConstraint("children");
			this.$builtins = this.$column_info.itemConstraint("builtin_children");

			if(client.type() === "stateful") {
				this.$statecharts = ist.indirectClient(this.$curr_copy_client, "get_statecharts");

				var statecharts = [], wrappers = [], wrapper_infos = [];

				this.statechart_view = $("<div />")	.statechart({
														statecharts: statecharts,
														client: this.$curr_copy_client
													});

				this.layout_manager = this.statechart_view.statechart("get_layout_manager");

				this.sc_live_fn = cjs.liven(function() {
					var old_wrapper_infos = wrapper_infos;
					wrapper_infos = this.$statecharts.get() || [];
					var diff = _.diff(old_wrapper_infos, wrapper_infos, function(a, b) {
						return a.object_summary.id === b.object_summary.id;
					});
					_.forEach(diff.removed, function (info) {
						var index = info.from, child = info.from_item;

						var wrapper = wrappers[index];
						var statechart = statecharts[index];

						wrapper.signal_destroy();

						wrappers.splice(index, 1);
						statecharts.splice(index, 1);
						//statechart.destroy();
					}, this);
					_.forEach(diff.added, function (info) {
						var index = info.to, child = info.item;
						var wrapper = child;
						var statechart = ist.create_remote_statechart(wrapper);
						wrappers.splice(index, 0, wrapper);
						wrapper.signal_interest();
						statecharts.splice(index, 0, statechart);
					}, this);
					_.forEach(diff.moved, function (info) {
						var from_index = info.from, to_index = info.to, child = info.item;

						//var wrapper = wrappers[from_index];
						var statechart = statecharts[from_index];
						//wrapper.splice(from_index, 1);
						//wrappers.splice(to_index, 0, wrapper);
						statecharts.splice(from_index, 1);
						statecharts.splice(to_index, 0, statechart);
					}, this);
					if(diff.added.length > 0 || diff.removed.length > 0 || diff.moved.length > 0) {
						this.statechart_view.statechart("option", "statecharts", statecharts);
					}
				}, {
					context: this,
					on_destroy: function() {
						_.each(wrappers, function(wrapper) {
							wrapper.signal_destroy();
						});
					}
				});
			}

			this._add_content_bindings();
			this._add_class_bindings();

			this.element.on("expand.on_child_select", _.bind(this.on_child_select, this));
		},
		_destroy: function() {
			var client = this.option("client");

			this._remove_class_bindings();
			this._remove_content_bindings();

			if(this.$statecharts) {
				this.statechart_view.statechart("destroy");
				this.sc_live_fn.destroy();
				this.$statecharts.destroy();
			}

			this.$curr_copy_client.destroy();
			this.$prev_copy_client.destroy();
			this.$next_copy_client.destroy();
			this.$is_template.signal_destroy();
			this.$is_curr_col.destroy();
			this.$name.signal_destroy();
			this.$instances.signal_destroy();
			this.$copies_obj.signal_destroy();
			this.$children.destroy();
			this.$builtins.destroy();

			this.$column_info.destroy();

			client.signal_destroy();

			this._super();
		},

		_add_content_bindings: function() {
			var client = this.option("client");
			column_template({
				name: this.$name,
				children: this.$children,
				builtins: this.$builtins,
				stateful: client.type() === "stateful",
				is_template: this.$is_template,
				getPropertyViewOptions: _.bind(function(child) {
					return {
						client: child.value,
						name: child.name,
						inherited: child.inherited,
						builtin: child.builtin,
						layout_manager: this.layout_manager,
						show_src: this.$is_curr_col,
						obj: this.option("client"),
						client_socket: this.option("client_socket"),
						statechart_view: this.statechart_view,
						selected: this.$selected_prop.eqStrict(child.value),
						prev: this.$prev_copy_client,
						next: this.$next_copy_client,
						editor: this.option("editor")
					};
				}, this),
				statechart_view: this.statechart_view,
				is_curr_col: this.$is_curr_col,
				headerClicked: _.bind(this.on_header_click, this),
				close_col: _.bind(this.close_col, this),
				prev_col: _.bind(this.prev_col, this),
				addProperty: _.bind(this._add_property, this),
				adding_field: this.$adding_field,
				getCopiesCellOptions: _.bind(function() {
					return {
						client: cjs.constraint(this.$copies_obj)
					};
				}, this),
				num_curr_values: this.$num_curr_values,
				curr_copy_index: this.$curr_copy_index,
				show_prev_value: this.$show_prev_value,
				show_next_value: this.$show_next_value,
				selectPrevClient: _.bind(function() {
					this.$curr_copy_index.set(this.$curr_copy_index.get() - 1);
				}, this),
				selectNextClient: _.bind(function() {
					this.$curr_copy_index.set(this.$curr_copy_index.get() + 1);
				}, this),
				num_instances: this.$num_instances,
				pinned: this.option("pinned"),
				is_root: this.is_root,
				headerMOver: _.bind(function() {
					var copy_client = this.$curr_copy_client.get(),
						event = new $.Event("add_highlight");
					event.client = copy_client;
					this.element.trigger(event);
				}, this),
				headerMOut: _.bind(function() {
					var copy_client = this.$curr_copy_client.get(),
						event = new $.Event("remove_highlight");
					event.client = copy_client;
					this.element.trigger(event);
				}, this),
				prevMOver: _.bind(function() {
					var copy_client = this.$prev_copy_client.get(),
						event = new $.Event("add_highlight");
					event.client = copy_client;
					this.element.trigger(event);
				}, this),
				prevMOut: _.bind(function() {
					var copy_client = this.$prev_copy_client.get(),
						event = new $.Event("remove_highlight");
					event.client = copy_client;
					this.element.trigger(event);
				}, this),
				nextMOver: _.bind(function() {
					var copy_client = this.$next_copy_client.get(),
						event = new $.Event("add_highlight");
					event.client = copy_client;
					this.element.trigger(event);
				}, this),
				nextMOut: _.bind(function() {
					var copy_client = this.$next_copy_client.get(),
						event = new $.Event("remove_highlight");
					event.client = copy_client;
					this.element.trigger(event);
				}, this),
				currMOver: _.bind(function() {
					var copy_client = this.$curr_copy_client.get(),
						event = new $.Event("add_highlight");
					event.client = copy_client;
					this.element.trigger(event);
				}, this),
				currMOut: _.bind(function() {
					var copy_client = this.$curr_copy_client.get(),
						event = new $.Event("remove_highlight");
					event.client = copy_client;
					this.element.trigger(event);
				}, this)
			}, this.element);
			this._select_just_added_name = cjs.liven(function() {
				var children = this.$children.get();
				if(this._just_added_prop_name) {
					var child;
					for(var i = 0; i<children.length; i++) {
						child = children[i];
						if(child.name === this._just_added_prop_name) {
							this._trigger_child_select(child.value);
							delete this._just_added_prop_name;
							return;
						}
					}
				}
			}, {
				context: this
			});
		},

		_remove_content_bindings: function() {
			cjs.destroyTemplate(this.element);
		},

		_add_class_bindings: function() {
			this._class_binding = cjs.bindClass(this.element, "col",
									this.$is_curr_col.iif("curr_col"),
									this.$is_template.iif("template"));
		},

		_remove_class_bindings: function() {
			this._class_binding.destroy();
		},

		_setOption: function(key, value) {
			this._super(key, value);
			if(key === "is_curr_col") {
				this.$is_curr_col.set(value);
			}
		},

		close_col: function(event) {
			event.stopPropagation();
			event.preventDefault();

			var e = new $.Event("close_column");
			this.element.trigger(e);
		},
		prev_col: function(event) {
			event.stopPropagation();
			event.preventDefault();

			var e = new $.Event("prev_column");
			this.element.trigger(e);
		},
		on_header_click: function(event) {
			this.element.trigger("header_click", this.option("client"));
			event.stopPropagation();
			event.preventDefault();
		},
		on_child_select: function(event) {
			if(event && $(event.target).hasClass("selected")) {
				this.on_header_click(event);
			} else {
				var target = $(event.target),
					client = target.data("interstate-prop") ? target.prop("option", "client"): false;
				this._trigger_child_select(client);
			}
		},
		_trigger_child_select: function(client) {
			this.element.trigger("child_select", client);
		},
		_add_property: function() {
			var child_names = _.pluck(this.$children.get(), "name"),
				default_name = "field_"+(child_names.length+1),
				name = default_name,
				i = 1,
				client = this.option("client");
				
			while(child_names.indexOf(name) >= 0) {
				name = default_name + "_" + i;
				i++;
			}

			this.$adding_field.set(true);
			if(client.type() === "stateful") {
				$("select.type", this.element).val("stateful_prop");
			} else {
				$("select.type", this.element).val("stateful");
			}

			$('.new_field input.name', this.element).val(name)
												.select()
												.focus();
			var trigger_add_prop = _.bind(function() {
					$('select.type,input', this.element).off('.addfield');
					clearTimeout(onFormBlur);

					var event = new $.Event("command");
					event.command_type = "add_property";
					event.client = this.option("client");
					this._just_added_prop_name = event.prop_name = $('.new_field input.name', this.element).val();
					window.setTimeout(_.bind(function() {
						delete this._just_added_prop_name;
					}, this), 200);
					event.prop_type = $('select.type', this.element).val();

					this.element.trigger(event);

					this.$adding_field.set(false);
				}, this),
				cancel_add_prop = _.bind(function() {
					$('select.type,input', this.element).off('.addfield');
					this.$adding_field.set(false);
				}, this);
			var onFormBlur;
			$('select.type,input', this.element).on('blur.addfield', function(e) {
				e.preventDefault();
				e.stopPropagation();
				onFormBlur = setTimeout(function() {
					trigger_add_prop();
				}, 50);
			}).on('focus.addfield', function() {
				clearTimeout(onFormBlur);
			}).on('keydown.addfield', function(event) {
				if(event.keyCode === 13) { // enter
					trigger_add_prop();
				} else if(event.keyCode === 27) { //esc
					cancel_add_prop();
				}
			});
		},
	});
}(interstate, jQuery));

/*jslint nomen: true, vars: true, white: true */
/*jshint scripturl: true */
/*global interstate,esprima,able,uid,console,window,jQuery,Raphael,RedMap */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	cjs.registerCustomPartial("prop", {
		createNode: function(options) {
			return $("<tr />").prop(options);
		},
		destroyNode: function(node) {
			$(node).prop("destroy");
		}
	});

	var prop_template = cjs.createTemplate(
		"<td data-cjs-on-mouseover='propMOver' data-cjs-on-mouseout='propMOut' class='name'>" +
			"{{#fsm name_edit_state}}" +
				"{{#state idle}}" +
					"<span>{{ prop_name }}</span>" +
				"{{#state editing}}" +
					"{{>editing_text prop_name 'input'}}" +
			"{{/fsm}}" +
			"{{#if show_menu}}" +
				"<ul class='menu'>" +
					"<li class='menu-item' data-action='change_type'>Change to {{ (type === 'stateful_prop' || type==='cell') ? 'object' : 'property'}}</li>" +
					"<li class='menu-item' data-action='delete'>Delete</li>" +
					"<li class='menu-item' data-action='rename'>Rename</li>" +
				"</ul>" +
			"{{/if}}" +
		"</td>" +
		"{{#if show_prev_value}}" +
			"{{> valueSummary getPrevValueSummaryOptions() }}"  +
		"{{/if}}" +
		"{{> valueSummary getValueSummaryOptions() }}"  +
		"{{#if show_next_value}}" +
			"{{> valueSummary getNextValueSummaryOptions() }}"  +
		"{{/if}}" +
		"{{#if show_src}}" +
			"{{#if type==='stateful_prop'}}" +
				"<td class='stateful_prop src'>" +
					"{{#each propValues}}" +
						"{{> propCell getPropCellOptions(@key) }}" +
					"{{/each}}" +
				"</td>" +
			"{{#elif type==='cell'}}" +
				"<td class='src'>" +
					"{{> propCell getPurePropCellOptions() }}" +
				"</td>" +
			"{{#else}}" +
				"<td class='cannot_modify src' />" +
			"{{/if}}" +
		"{{/if}}"
	);
	$.widget("interstate.prop", {
		options: {
			name: "",
			client: false,
			inherited: false,
			builtin: false,
			layout_manager: false,
			show_src: false,
			obj: false,
			client_socket: false,
			selected: false,
			prev: false,
			next: false
		},

		_create: function() {
			var client = this.option("client");

			this.$dragging = this.option("editor").getDraggingClientConstraint();
			this.$prop_name = cjs(this.option("name"));
			this.$inherited = cjs(this.option("inherited"));
			this.$show_src  = this.option("show_src");
			this.$selected  = this.option("selected");

			this.$prev_dict_client = this.option("prev");
			this.$next_dict_client = this.option("next");

			this.$show_prev_value = cjs(this.$prev_dict_client);
			this.$show_next_value = cjs(this.$next_dict_client);

			this.prev_value = ist.indirectClient(this.$prev_dict_client, ["prop_val", this.option("name")]);
			this.next_value = ist.indirectClient(this.$next_dict_client, ["prop_val", this.option("name")]);

			this.$type = cjs(function() {
				if(client instanceof ist.WrapperClient) {
					return client.type();
				} else {
					return "";
				}
			});

			var elem = this.element;
			this.name_edit_state = cjs	.fsm("idle", "editing")
										.startsAt("idle")
										.addTransition('editing', 'idle', function(dt) {
											elem.on('confirm_value.prop', dt);
										})
										.addTransition('editing', 'idle', function(dt) {
											elem.on('cancel_value.prop', dt);
										})
										.on('editing->idle', function(event) {
											if(event.type === 'confirm_value') {
												this._emit_new_name(event.value);
											}
										}, this);

			this.element.on("click.expand", _.bind(this._trigger_expand, this));

			this._add_menu();
			this._create_state_map();
			this._add_content_bindings();
			this._add_class_bindings();
			this._add_tooltip();

			if(this.option("inherited")) {
				this.element.on("mousedown.inherit", _.bind(this.inherit, this));
			} else {
				this.element.attr("draggable", true)
							.on("dragstart.ondragstart", _.bind(this.on_drag_start, this));
			}

			if(client instanceof ist.WrapperClient) {
				client.signal_interest();
			}
		},
		_destroy: function() {
			var client = this.option("client");

			this.element.off(".prop").off(".inherit .ondragstart .menu_item");
			this._remove_tooltip();
			this._remove_content_bindings();
			this._remove_class_bindings();
			this._destroy_state_map();
			this._destroy_menu();

			if(client instanceof ist.WrapperClient) {
				client.signal_destroy();
			}

			this.$prop_name.destroy();
			this.$inherited.destroy();
			this.$show_menu.destroy();
			this.$type.destroy();
			this.name_edit_state.destroy();

			this._super();
		},

		_add_menu: function() {
			this.$show_menu  = cjs(false);
			this.menu_state = cjs.fsm("hidden", "holding", "on_release", "on_click");
			if(this.option("builtin")) {
				this.element.on("contextmenu", function(event) {
					event.preventDefault();
					event.stopPropagation();
				});
			} else {
				this.menu_state.addTransition("hidden", "holding", cjs.on("contextmenu", this.element[0]));
			}
			this.menu_state	.addTransition("holding", "on_click", cjs.on("mouseup"))
							.addTransition("holding", "on_release", cjs.on("timeout", 500))
							.addTransition("holding", "hidden", cjs.on("keydown").guard('keyCode', 27))
							.addTransition("on_click", "hidden", cjs.on("keydown").guard('keyCode', 27))
							.addTransition("on_release", "hidden", cjs.on("keydown").guard('keyCode', 27))
							.startsAt("hidden");

			var on_mup_holding = this.menu_state.addTransition("holding", "hidden"),
				on_mup_orelease = this.menu_state.addTransition("on_release", "hidden"),
				on_mup_oclick = this.menu_state.addTransition("on_click", "hidden");

			this.menu_state.on("hidden->holding", function(event) {
				this.$show_menu.set(true);
				event.stopPropagation();
				event.preventDefault();
				var my_position = this.element.position();
				
				return false;
			}, this);

			var on_click = function(event) {
				$(window).add("ul.menu > li", this.element).off('.menu_item');

				$("ul.menu > li", this.element).on('click.menu_item', _.bind(function(e) {
					this.on_menu_action(e.target.getAttribute('data-action'));
					on_mup_oclick(e);
					e.stopPropagation();
					e.preventDefault();
				}, this));
				$(window).on('mousedown.menu_item', function(e) {
					if(!$(e.target).parents().is($("ul.menu", this.element))) {
						on_mup_oclick(e);
						e.stopPropagation();
						e.preventDefault();
					}
				});
			},
			on_hold = function(event) {
				$("ul.menu > li", this.element).on('mouseup.menu_item', _.bind(function(e) {
					this.on_menu_action(e.target.getAttribute('data-action'));
					on_mup_holding(e);
					on_mup_orelease(e);
					e.stopPropagation();
					e.preventDefault();
				}, this));

				$(window).on('mouseup.menu_item', function(e) {
					if(!$(e.target).parents().is($("ul.menu", this.element))) {
						on_mup_holding(e);
						on_mup_orelease(e);
						e.stopPropagation();
						e.preventDefault();
					}
				});
			},
			on_hidden = function(event) {
				this.menu_state .off("on_click", on_click, this)
								.off("holding", on_hold, this)
								.off("hidden", on_hidden, this);
				this.$show_menu.set(false);
				$(window).add("ul.menu > li", this.element).off('.menu_item');
			};
			this.menu_state.on("on_click", on_click, this);
			this.menu_state.on("holding", on_hold, this);
			this.menu_state.on("hidden", on_hidden, this);
		},
		_destroy_menu: function() {
			$(window).add("ul.menu > li", this.element).off('.menu_item').remove();
			this.menu_state.destroy();
			this.$show_menu.destroy();
		},
		on_menu_action: function(action_name) {
			// Give the menu a bit of time to transition back to hidden
			_.defer(_.bind(function() {
				if(action_name === 'delete') {
					var event = new $.Event("command");
					event.command_type = "unset";
					event.name = this.$prop_name.get();
					event.client = this.option("obj");

					this.element.trigger(event);
				} else if(action_name === 'rename') {
					this.begin_rename();
				} else if(action_name === 'change_type') {
					var client = this.option("client"),
						client_type = client.type(),
						obj = this.option("obj"),
						obj_type = obj.type(),
						new_type = (client_type === 'cell' || client_type === 'stateful_prop') ? 'stateful' : (obj_type === 'stateful' ? 'stateful_prop' : 'cell');
					this._change_type(new_type);
				}
			}, this));
		},

		begin_rename: function() {
			this.name_edit_state._setState('editing');
		},

		_add_tooltip: function() {
			var client = this.option("client");
			if(client instanceof ist.WrapperClient && client.type() === "stateful_prop") {
				this.$runtime_errors = client.get_$("get_runtime_errors");
				this.element.tooltip({
					position: {
						my: "center bottom-1",
						at: "center top"
					},
					show: false,
					hide: false,
					content: ""
				});
				this._tooltip_live_fn = cjs.liven(function() {
					var runtime_errors = this.$runtime_errors.get();
					if(runtime_errors && runtime_errors.length > 0) {
						var runtime_error_text = runtime_errors[0];

						this.element.addClass("error")
									.attr("title", runtime_error_text)
									.tooltip("option", {
										tooltipClass: "error",
										content: runtime_error_text
									});
					} else {
						this.element.removeClass("error")
									.attr("title", "")
									.tooltip("option", {
										tooltipClass: "",
										content: ""
									});
					}
				}, {
					context: this,
					on_destroy: function() {
						this.element.tooltip("destroy");
					}
				});
			}
		},

		_remove_tooltip: function() {
			if(this._tooltip_live_fn) {
				this._tooltip_live_fn.destroy();
				delete this._tooltip_live_fn;
			}
		},

		_create_state_map: function() {
			var client = this.option("client");
			if(client instanceof ist.WrapperClient && client.type() === "stateful_prop") {
				this.$states = client.get_$("get_states");
				this.$values = client.get_$("get_values");
				this.$active_value = client.get_$("active_value");

				this.$full_values = cjs(function() {
					var values = this.$values.get() || [], 
						states = this.$states.get() || [],
						indexed_vals = [];

					_.each(states, function(state, i) {
						indexed_vals[i] = undefined;
					});

					_.each(values, function(value) {
						var key_index = states.indexOf(value.state);
						indexed_vals[key_index] = value.value;
					});

					return indexed_vals;
				}, {
					context: this
				});

				this.$prop_values = ist.create_key_val_map(this.$states, this.$full_values);
			}
		},
		_destroy_state_map: function() {
			if(this.$states) {
				this.$states.signal_destroy();
				this.$values.signal_destroy();
				this.$active_value.signal_destroy();

				this.$full_values.destroy();
				this.$prop_values.destroy();
			}
		},

		_add_content_bindings: function() {
			var layout_manager = this.option("layout_manager");
			prop_template({
				prop_name: this.$prop_name,
				name_edit_state: this.name_edit_state,
				getPrevValueSummaryOptions: _.bind(function() {
					return { is_primary: false, client: this.prev_value, itemClass:'prev'};
				}, this),
				getValueSummaryOptions: _.bind(function() {
					return { is_primary: true, client: this.option("client"), itemClass:'primary' };
				}, this),
				getNextValueSummaryOptions: _.bind(function() {
					return { is_primary: false, client: this.next_value, itemClass:'next'};
				}, this),
				getPurePropCellOptions: _.bind(function() {
					return { client: cjs.constraint(this.option("client")), prop: false };
				}, this),
				getPropCellOptions: _.bind(function(key) {
					var value = this.$prop_values.itemConstraint(key),
						$active = true,
						left = function() { return layout_manager.get_x(key); },
						width = function() { return value.get() ? layout_manager.get_width(key) : 7; };

					// One of the worst lines of code I've ever written was here: `value: value ? value.value : value`
					return {prop: this.option("client"),
							state: key,
							client: value,
							left: left,
							width: width,
							active_value: this.$active_value
							};
				}, this),
				show_prev_value: this.$show_prev_value,
				show_next_value: this.$show_next_value,
				show_src: this.$show_src,
				value: this.option("client"),
				type: this.$type,
				propValues: this.$prop_values,
				show_menu: this.$show_menu,
				propMOver: _.bind(function() {
					var client = this.option("client"),
						event = new $.Event("add_highlight");
					event.client = client;

					this.element.trigger(event);
				}, this),
				propMOut: _.bind(function() {
					var client = this.option("client"),
						event = new $.Event("remove_highlight");
					event.client = client;

					this.element.trigger(event);
				}, this)
			}, this.element);
		},

		_remove_content_bindings: function() {
			cjs.destroyTemplate(this.element);
		},

		_add_class_bindings: function() {
			this._class_binding = cjs.bindClass(this.element, "child", this.option("builtin") ? "builtin":"",
									this.$selected.iif("selected", ""),
									this.$inherited.iif("inherited", ""),
									this.$show_menu.iif("menuized", ""));
		},

		_remove_class_bindings: function() {
			this._class_binding.destroy();
		},

		_setOption: function(key, value) {
			this._super(key, value);
			if(key === "name") {
				this.$prop_name.set(value);
			} else if(key === "inherited") {
				this.$inherited.set(value);
			} else if(key === "show_src") {
				this.$show_src.set(value);
			}
		},

		_trigger_expand: function(event) {
			event.stopPropagation();
			event.preventDefault();
			if(this.element.not(".selected")) {
				this.element.trigger("expand");
			}
		},
		inherit: function(e) {
			if(e) {
				e.preventDefault();
				e.stopPropagation();
			}
			var event = new $.Event("command");
			event.command_type = "inherit";
			//event.client = this.option("client");
			event.name = this.option("name");
			event.client = this.option("client");

			this.element.trigger(event);
		},

		_emit_new_name: function(str) {
			if(ist.is_valid_prop_name(str)) {
				var to_return = false;
				var self = this;
				$("span.prop_name", this.element.parent()).each(function() {
					var child_parent = $(this).parents(".child");
					if(child_parent !== self && child_parent.data("interstate-prop") && child_parent.prop("option", "name") === str) {
						to_return = true;
						self.name_span.editable_text("option", "text", old_name);
						window.alert("Property with name '" + str + "' already exists");
					}
				});
				if(to_return) { return; }
				var event = new $.Event("command");
				event.command_type = "rename";
				event.from_name = this.$prop_name.get();
				event.to_name = str;
				event.client = this.option("obj");

				if(event.from_name !== event.to_name) {
					this.element.trigger(event);
				}
			}
		},

		_change_type: function(type) {
			var event = new $.Event("command");
			event.command_type = "set_type";
			event.client = this.option("obj");
			event.prop_name = this.$prop_name.get();
			event.type_name = type;

			this.element.trigger(event);
		},

		on_drag_start: function(event) {
			event.preventDefault();
			event.stopPropagation();
			if(this.element.is(".inherited") || this.element.is(".builtin")) {
				return;
			}

			this.$dragging.set(this.option("client"));

			this.element.addClass("dragging");
			var curr_target = false;
			var above_below = false;
			var on_mmove = function(e) {
				above_below = 2 * e.offsetY > curr_target.height() ? "below" : "above";
				curr_target.addClass(above_below === "above" ? "dragtop" : "dragbottom");
				curr_target.removeClass(above_below === "above" ? "dragbottom" : "dragtop");
			};
			var on_mover_child = function(e) {
				curr_target = $(this);
				curr_target.addClass("dragtop");
				curr_target.on("mousemove", on_mmove);
			};
			var on_mout_child = function(e) {
				if(curr_target) {
					curr_target.removeClass("dragtop dragbottom");
					curr_target.off("mousemove", on_mmove);
					curr_target = false;
				}
			};
			var on_mup = _.bind(function() {
				this.$dragging.set(false);
				targets.off("mouseover", on_mover_child);
				targets.off("mouseout", on_mout_child);
				$(window).off("mouseup", on_mup);
				this.element.removeClass("dragging");
				if(curr_target) {
					var my_obj = this.option("obj"),
						my_name = this.option("name");
					var target_name, target_obj;
					if(curr_target.is("tr.no_children")) {
						target_obj = curr_target.parents(".col").column("option", "client");
						target_name = false;
					} else {
						target_obj = curr_target.prop("option", "obj");
						target_name = curr_target.prop("option", "name");
					}

					curr_target.removeClass("dragtop dragbottom");
					curr_target.off("mousemove", on_mmove);
					curr_target = false;

					var event = new $.Event("command");
					event.command_type = "move_prop";
					event.from_obj = my_obj;
					event.from_name = my_name;
					event.target_obj = target_obj;
					event.target_name = target_name;
					event.above_below = above_below;

					this.element.trigger(event);
				}
			}, this);
			var targets = $("tr.child").not(".inherited").add("tr.no_children");

			targets.on("mouseover", on_mover_child);
			targets.on("mouseout", on_mout_child);
			$(window).on("mouseup", on_mup);
		},
	});

	var eqProp = function(prop_name, values, thisArg) {
		return function(x) {
			var val = x[prop_name];
			if(values[val]) {
				return values[val].apply(thisArg || this, arguments);
			}
		};
	};
}(interstate, jQuery));

/*jslint nomen: true, vars: true, white: true */
/*global interstate,esprima,able,uid,console,window,jQuery,Raphael */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;
	
	cjs.registerCustomPartial("propCell", {
		createNode: function(options) {
			return $("<span />").prop_cell(options);
		},
		destroyNode: function(node) {
			$(node).prop_cell("destroy");
		}
	});

	var cell_template = cjs.createTemplate(
		"{{#fsm client_state}}" +
			"{{#state initialedit}}" +
				"{{>editing_text ''}}" +
			"{{#state set}}" +
				"{{#fsm edit_state}}" +
					"{{#state idle}}" +
						"{{#if str===''}}" +
							"<span class='empty'>(empty)</span>" +
						"{{#else}}" +
							"{{str}}" +
						"{{/if}}" +
					"{{#state editing}}" +
						"{{>editing_text str}}" +
				"{{/fsm}}" +
		"{{/fsm}}"
	);

	var eqProp = function(prop_name, values, thisArg) {
		return function(x) {
			var val = x[prop_name];
			if(values[val]) {
				return values[val].apply(thisArg || this, arguments);
			}
		};
	};

	$.widget("interstate.prop_cell", {
		options: {
			client: false,
			left: undefined,
			width: 0,
			edit_width: 150,
			unset_radius: 7,
			active: false,
			parent: false,
			state: false,
			prop: false,
			default_max_width: 90,
			char_limit: 200
		},
		_create: function() {
			var client = this.option("client");

			var elem = this.element;
			this.client_state = cjs.fsm('unset', 'initialedit', 'set')
									.addTransition('unset', 'initialedit', cjs.on('click', this.element))
									.addTransition('initialedit', 'set', function(dt) {
										elem.on('confirm_value.cell', dt);
									})
									.addTransition('initialedit', 'unset', function(dt) {
										elem.on('cancel_value.cell', dt);
									})
									.on('initialedit->set', function(event) {
										this._set_value_for_state(event.value);
									}, this)
									.on("unset->initialedit", this._emit_begin_editing, this)
									.on("initialedit->*", this._emit_done_editing, this);

			this.client_state._setState(client.get() ? 'set' : 'unset');
			client.onChange(function() {
				this.client_state._setState(client.get() ? 'set' : 'unset');
			}, this);

			this.$cell_info = ist.indirectClient(this.option("client"), "get_str", "get_syntax_errors");

			this.$str = this.$cell_info.itemConstraint("get_str");
			this.$syntax_errors = this.$cell_info.itemConstraint("get_syntax_errors");

			this.edit_state = cjs	.fsm("idle", "editing")
									.startsAt("idle")
									.addTransition('idle', 'editing', cjs.on('click', this.element).guard(_.bind(function() {
										return !!client.get();
									}, this)))
									.addTransition('editing', 'idle', function(dt) {
										elem.on('confirm_value.cell', dt);
									})
									.addTransition('editing', 'idle', function(dt) {
										elem.on('cancel_value.cell', dt);
									})
									.on('editing->idle', function(event) {
										if(event.type === 'confirm_value') {
											this._emit_new_value(event.value);
										}
									}, this);

			this.$active = cjs(function() {
				var active_value = this.option("active_value"),
					avval = cjs.get(active_value),
					av = avval ? avval.value : false;

				return av && av === cjs.get(this.option("client"));
			}, {context: this});
			this.$left = cjs(this.option("left"));

								
			this.$pure = cjs(!this.option("prop"));
			this.$visible = this.$pure.or(this.$left.neq(undefined));
			
			this.do_edit = this.edit_state.addTransition("idle", "editing");

			this._add_content_bindings();
			this._add_tooltip();
			this._add_class_bindings();
			this._add_position_bindings();
		},
		_destroy: function() {
			var client = this.option("client");

			this.element.off("confirm_value.cell cancel_value.cell")
				.children().remove();

			this._remove_position_bindings();
			this._remove_class_bindings();
			this._remove_tooltip();
			this._remove_content_bindings();


			this.$str.destroy();
			this.$syntax_errors.destroy();

			this.$cell_info.destroy();

			this.$active.destroy();
			this.$left.destroy();
			this.client_state.destroy();
			this.$pure.destroy();
			this.$visible.destroy();
			this.edit_state.destroy();

			client.destroy();

			this._super();
		},

		_emit_new_value: function(value) {
			var event;
			if(this.option("prop") && value === "") {
				event = new $.Event("command");
				event.command_type = "unset_stateful_prop_for_state";
				event.prop = this.option("prop");
				event.state = this.option("state");

				this.element.trigger(event);
			} else {
				event = new $.Event("command");
				event.command_type = "set_str";
				event.str = value;
				event.client = cjs.get(this.option("client"));

				this.element.trigger(event);
			}
		},
		_setOption: function(key, value) {
			this._super(key, value);
			if(key === "left") {
				this.$left.set(value);
			} else if(key === "width") {
				this.$specified_width.set(value);
			} else if(key === "active") {
				this.$active.set(value);
			}
		},
		_add_content_bindings: function() {
			var cancel_edit = this.edit_state.addTransition("editing", "idle"),
				confirm_edit = this.edit_state.addTransition("editing", "idle"),
				cell = cell_template({
					edit_state: this.edit_state,
					str: this.$str,
					client_state: this.client_state
				}, this.element);
		},
		_remove_content_bindings: function() {
			this.element.off("click.start_edit");
			cjs.destroyTemplate(this.element);
		},
		_add_class_bindings: function() {
			this.element.addClass("cell");
			this._class_binding = cjs.bindClass(this.element,
									this.$active.iif("active", ""),
									this.$pure.iif("pure_cell", ""),
									cjs.inFSM(this.client_state, {
										unset: 'unset',
										set: '',
										initialedit: 'editing'
									}),
									this.edit_state.state);
		},
		_remove_class_bindings: function() {
			this._class_binding.destroy();
			this.element.removeClass("cell");
		},
		_add_position_bindings: function() {
			this.$specified_width = cjs(this.option("width"));
			this.$width = cjs.inFSM(this.edit_state, {
				idle: cjs.inFSM(this.client_state, {
					unset: this.option("unset_radius")*2,
					set: this.$specified_width,
					initialedit: this.option("edit_width")
				}),
				editing: this.option("edit_width")
			});
			this.$edit_width = cjs(this.option("edit_width"));

			this.$z_index = cjs.inFSM(this.edit_state, {
				idle: cjs.inFSM(this.client_state, {
					unset: 0,
					set: 0,
					initialedit: 99
				}),
				editing: 99
			});
			this.element.css("min-width", this.option("width"));

			this.position_binding = cjs.bindCSS(this.element, {
				left: this.$left.sub(this.$width.div(2)).add("px"),
				"z-index": this.$z_index,
				"visibility": this.$visible.iif("visible", "hidden"),
				'max-width': cjs.inFSM(this.edit_state, {
					idle: cjs.inFSM(this.client_state, {
						unset: this.option("unset_radius")*2,
						set: this.option("default_max_width") + 'px',
						initialedit: 'none'
					}),
					editing: 'none'
				})
			});
		},
		_remove_position_bindings: function() {
			_.each([this.$specified_width, this.$width, this.$left, this.$edit_width, this.$z_index, this.$active, this.position_binding],
					function(x) {
						x.destroy(true);
					});
		},
		_add_tooltip: function() {
			this.element.tooltip({
				position: {
					my: "center bottom-1",
					at: "center top"
				},
				show: false,
				hide: false,
				content: ""
			});
			var enable_tooltip = _.bind(function() { this.element.tooltip("enable"); }, this);
			var disable_tooltip = _.bind(function() { this.element.tooltip("disable"); }, this);
			this._tooltip_live_fn = cjs.liven(function() {
				var syntax_errors = this.$syntax_errors.get();
				if(syntax_errors && syntax_errors.length > 0) {
					var syntax_error_text = syntax_errors[0];

					this.element.addClass("error")
								.attr("title", syntax_error_text)
								.tooltip("option", {
									tooltipClass: "error",
									content: syntax_error_text
								});
				} else {
					var str = this.$str.get() || "";

					if(str.length > this.option("char_limit")) {
						str = str.slice(0, this.option("char_limit")-3)+"...";
					}

					this.element.removeClass("error")
								.attr("title", str)
								.tooltip("option", {
									tooltipClass: "cell_text",
									content: str
								});
				}
			}, {
				context: this,
				on_destroy: function() {
					this.element.tooltip("destroy");
					this.edit_state	.off("idle->editing", disable_tooltip)
									.off("editing->idle", enable_tooltip);
				}
			});

			this.edit_state	.on("idle->editing", disable_tooltip)
							.on("idle->editing", this._emit_begin_editing, this)
							.on("editing->idle", enable_tooltip)
							.on("editing->idle", this._emit_done_editing, this);
		},
		_remove_tooltip: function() {
			this._tooltip_live_fn.destroy();
			delete this._tooltip_live_fn;
		},
		_set_value_for_state: function(val) {
			var event = new $.Event("command");
			event.command_type = "set_stateful_prop_for_state";
			event.prop = this.option("prop");
			event.state = this.option("state");
			event.text = val || "";

			this.element.trigger(event);
		},
		_emit_begin_editing: function() {
			var event = new $.Event("begin_editing_cell");
			event.initial_val = this.$str.get();
			event.textarea = $("textarea", this.element)[0];
			this.element.trigger(event);
		},
		_emit_done_editing: function() {
			var event = new $.Event("done_editing_cell");
			this.element.trigger(event);
		}
	});
}(interstate, jQuery));

/*jslint nomen: true, vars: true, white: true */
/*jshint scripturl: true */
/*global interstate,esprima,able,uid,console,window,jQuery,Raphael */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	$.widget("interstate.copy", {
		options: {
			curr_copy: false,
			out_of: 0,
			client: false,
			displayed: false
		},

		_create: function () {
			var client = this.option("client");
			client.signal_interest();
			this.left_brace = $("<span />").text(" [").addClass("brace");
			this.content = $("<span />");
			this.right_brace = $("<span />").text("]").addClass("brace");

			this.curr_copy_text = $("<span />")	.addClass("copy_num");
			this.of_text = $("<span />")	.addClass("of_text");

			this.content.append(this.curr_copy_text, this.of_text);

			this.element.addClass("copy");

			if(this.option("displayed")) {
				this.on_displayed();
			}

			this.content.on("click.on_click", _.bind(this.on_click, this));
			this.add_listener();
		},

		_destroy: function () {
			this.destroy_copy_num_input();
			this.content.off("click.on_click");
			this._super();
			this.remove_listener();
			var client = this.option("client");
			client.signal_destroy();
			delete this.options.client;
			delete this.options;
		},

		on_click: function() {
			this.copy_num_input = $("<input />").attr({
													type: "number",
													min: 0,
													max: this.option("out_of")
												})
												.val(this.option("curr_copy"))
												.addClass("copy_input")
												.insertBefore(this.content)
												.focus()
												.select()
												.on("blur.on_blur", _.bind(this.on_blur, this))
												.on("change.on_change", _.bind(this.on_change, this))
												.on("keydown.on_keydown", _.bind(this.on_key_down, this));

			this.original_copy_num = this.option("curr_copy");
			this.content.hide();
		},

		destroy_copy_num_input: function() {
			if(this.copy_num_input) {
				this.copy_num_input	.off("blur.on_blur")
									.off("change.on_change")
									.off("keydown.on_keydown")
									.remove();
				delete this.copy_num_input;
			}
		},

		on_blur: function() {
			this.destroy_copy_num_input();
			this.content.show();
		},

		on_change: function(event) {
			var value = parseInt(this.copy_num_input.val(), 10);
			this.option("curr_copy", value);
		},

		on_key_down: function(jqEvent) {
			var event = jqEvent.originalEvent;
			if(event.keyCode === 13) { // Enter
				this.on_change();
				this.on_blur();
			} else if(event.keyCode === 27) { // Esc
				this.on_blur();
				this.option("curr_copy", this.original_copy_num);
			}
		},

		add_listener: function() {
			var client = this.option("client");
			var $is_template = client.get_$("is_template");
			var $copies = client.get_$("instances");
			this.copy_listener = cjs.liven(function() {
				var is_template = $is_template.get();
				if(is_template) {
					var copies = $copies.get();
					if(_.isArray(copies)) {
						var len = copies.length;
						this.option({
							displayed: true,
							out_of: len-1,
							curr_copy: Math.min(this.option("curr_copy"), len)
						});
					} else {
						this.option({
							displayed: false
						});
					}
				} else {
					this.option({
						displayed: false
					});
				}
			}, {
				context: this,
				on_destroy: function() {
					$is_template.signal_destroy();
					$copies.signal_destroy();
				}
			});
		},
		remove_listener: function() {
			if(this.copy_listener) {
				this.copy_listener.destroy();
				delete this.copy_listener;
			}
		},

		update_display: function() {
			if(this.option("curr_copy") === false) {
				this.curr_copy_text.text("");
				this.of_text.text(this.option("out_of"));
			} else  {
				this.curr_copy_text.text(this.option("curr_copy"));
				this.of_text.text(" , length " + (this.option("out_of") + 1));
			}
		},

		on_displayed: function() {
			this.update_display();
			this.element.append(this.left_brace, this.content, this.right_brace);
		},

		on_not_displayed: function() {
			this.element.children().remove();
		},

		_setOption: function(key, value) {
			var old_value;
			if(key === "curr_copy" || key === "out_of") {
				old_value = this.option(key);
			}
			this._super(key, value);
			if(key === "displayed") {
				if(value) {
					this.on_displayed();
				} else {
					this.on_not_displayed();
				}
			} else if(key === "curr_copy" || key === "out_of") {
				if(old_value !== value) {
					if(key === "curr_copy") {
						this.element.trigger("curr_copy_change", value);
					}
					this.update_display();
				}
			}

		}
	});
}(interstate, jQuery));

/* jslint nomen: true, vars: true, white: true */
/* jshint scripturl: true */
/*global interstate,esprima,able,uid,console,window,jQuery,Raphael */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	cjs.registerCustomPartial("valueSummary", {
		createNode: function(options) {
			return $("<td />").value_summary(options);
		},
		destroyNode: function(node) {
			$(node).value_summary("destroy");
		}
	});

	var value_summary_template = cjs.createTemplate(
		"{{#if type ==='dict' || type === 'stateful'}}" + 
			"{{#if is_template}}" + 
				"<span class='copies'>" +
					"[{{num_instances}}]" +
				"</span>" +
			"{{/if}}" +
			"<span class='expand_arrow'>></span>" +
		"{{#else}}" +
			"<span>{{{ summarize_val(value, is_primary) }}}</span>" +
		"{{/if}}"
	);

	var round_num = function(num, decimals) {
		var n = Math.pow(10, decimals);
		return Math.round(num*n)/n;
	};
	var NAN = NaN;
	var summarize_val = function(val, is_primary) {
		if(_.isString(val)) {
			if(val === "(native function)") {
				return val;
			} else {
				return "'" + escapeHtml(val) + "'";
			}
		} else if(_.isArray(val)) {
			return "[" + _.map(val, function(v) { return summarize_val(v, is_primary); }).join(", ") + "]";
		} else if(val instanceof ist.WrapperClient) {
			if(is_primary) {
				return "<span class='cobj_link' data-cobj_id='"+val.cobj_id+"'>" + val.colloquial_name + "</span>";
			} else {
				return "";
			}
		} else {
			return summarize_plain_val.apply(this, arguments);
		}
	};
	var summarize_plain_val = function(val) {
		if(_.isString(val)) {
			if(val === "(native function)") {
				return val;
			} else {
				return "'" + val + "'";
			}
		} else if(_.isNumber(val)) {
			return round_num(val, 2)+"";
		} else if(val === undefined) {
			return "undefined";
		} else if(val === null) {
			return "null";
		} else if(val === NAN) {
			return "NaN";
		} else if(_.isFunction(val)) {
			return "(func)";
		} else if(_.isArray(val)) {
			return "[" + _.map(val, summarize_plain_val).join(", ") + "]";
		} else if(val instanceof ist.WrapperClient) {
			return val.colloquial_name;
		} else {
			return val+"";
		}
	};

	$.widget("interstate.value_summary", {
		options: {
			client: false,
			is_primary: true,
			itemClass: "",
			char_limit: 200
		},
		_create: function() {
			var client = this.option("client");

			if(client instanceof ist.WrapperClient) {
				this.$type = client.type();
				this.$value = ist.indirectClient(client, "val");
			} else {
				this.$type = false;
				this.$value = client;
			}

			this.$client_info = ist.indirectClient(client, "is_template", "instances", "val");
			this.$is_template = this.$client_info.itemConstraint("is_template");
			this.$instances = this.$client_info.itemConstraint("instances");
			this.$num_instances = this.$instances.prop("length");

			this._add_content_bindings();
			this._add_class_bindings();
			this._add_tooltip();
			this.element.on("click.navigate", _.bind(function(event) {
				var cobj_id = $(event.target).attr("data-cobj_id");
				if(cobj_id) {
					if(this.element.parents().is(".col.curr_col")) {
						this.open_cobj(cobj_id);
						event.preventDefault();
						event.stopPropagation();
					}
				}
			}, this));
		},
		_destroy: function() {
			this._remove_tooltip();
			this._remove_content_bindings();
			this._remove_class_bindings();

			this.$num_instances.destroy();
			this.$instances.destroy();
			this.$is_template.destroy();
			this.$client_info.destroy();
			if(this.$value && this.$value.destroy) {
				this.$value.destroy();
			}

			this._super();
		},
		_add_content_bindings: function() {
			var val_summary = value_summary_template({
					is_dict: this.$is_dict,
					is_template: this.$is_template,
					num_instances: this.$num_instances,
					summarize_val: summarize_val,
					value: this.$value,
					type: this.$type,
					is_primary: this.option("is_primary")
				}, this.element);
		},
		_remove_content_bindings: function() {
			cjs.destroyTemplate(this.element);
		},
		_add_class_bindings: function() {
			this.element.addClass("value_summary " + this.option("itemClass"));
		},
		_remove_class_bindings: function() {
			this.element.removeClass("value_summary");
		},
		open_cobj: function(cobj_id) {
			var event = new $.Event("open_cobj");
			event.cobj_id = cobj_id;

			this.element.trigger(event);
		},
		_add_tooltip: function() {
			this.element.tooltip({
				position: {
					my: "center bottom-1",
					at: "center top"
				},
				show: false,
				hide: false,
				content: ""
			});
			var enable_tooltip = _.bind(function() { this.element.tooltip("enable"); }, this);
			var disable_tooltip = _.bind(function() { this.element.tooltip("disable"); }, this);
			this._tooltip_live_fn = cjs.liven(function() {
				var type = this.$type;
				if(type === "stateful_prop" || type === "cell") {
					var str = summarize_plain_val(cjs.get(this.$value));

					if(str.length > this.option("char_limit")) {
						str = str.slice(0, this.option("char_limit")-3)+"...";
					}

					this.element.attr("title", str)
								.tooltip("option", {
									tooltipClass: "val_summary",
									content: str
								});
				}
			}, {
				context: this,
				on_destroy: function() {
					this.element.tooltip("destroy");
				}
			});
		},
		_remove_tooltip: function() {
			this._tooltip_live_fn.destroy();
			delete this._tooltip_live_fn;
		},
	});

	var entityMap = {
		"&": "&amp;",
		"<": "&lt;",
		">": "&gt;",
		'"': '&quot;',
		"'": '&#39;',
		"/": '&#x2F;'
	};

	function escapeHtml(string) {
		return String(string).replace(/[&<>"'\/]/g, function (s) {
			return entityMap[s];
		});
	}
}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,window */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var match_styles = function (textbox, text, options) {
		textbox.style.position = "absolute";
		var anchor = text.attr("text-anchor");
		if (anchor === "start") {
			textbox.style.textAlign = "left";
		} else if (anchor === "middle") {
			textbox.style.textAlign = "center";
		} else {
			textbox.style.textAlign = "right";
		}
		textbox.style.fontFamily = text.attr("font-family");
		textbox.style.fontWeight = text.attr("font-weight");
		textbox.style.fontStyle = text.attr("font-style");
		textbox.style.fontSize = text.attr("font-size") + "px";
		var box = text.getBBox();
		textbox.style.top = box.y + "px";
		textbox.style.outline = "none";
		textbox.style.border = "none";
		textbox.style.padding = "0px";
		textbox.style.margin = "0px";
		textbox.style.boxSizing = "border-box";
		textbox.style.background = options.fill;
		textbox.style.color = options.color;
	};

	ist.EditableText = function (paper, options) {
		able.make_this_listenable(this);
		able.make_this_optionable(this, {
			x: 0,
			y: 0,
			text: "",
			width: 100,
			"text-anchor": "middle",
			animation_duration: 600,
			"default": "",
			font: "",
			"font-family": "Courier New, Courier",
			"font-size": 14,
			"font-weight": "normal",
			color: "#000000",
			default_color: "#AAAAAA",
			fill: "white",
			"fill-opacity": 0.7,
			textbox_background: "white",
			textbox_color: "black",
			edit_on_click: true
		}, options);

		this.text = paper.text(this.option("x"), this.option("y"), this.get_text())
			.attr({
				font: this.option("font"),
				"font-family": this.option("font-family"),
				"font-size": this.option("font-size"),
				"font-weight": this.option("font-weight"),
				"text-anchor": this.option("text-anchor")
			});

		if (this.show_default()) {
			this.text.attr("fill", this.option("default_color"));
		} else {
			this.text.attr("fill", this.option("color"));
		}
		var bbox = this.getBBox();
		this.label_background = paper.rect(bbox.x, bbox.y, bbox.width, bbox.height).insertBefore(this.text);
		this.label_background.attr({
			fill: this.option("fill"),
			"fill-opacity": this.option("fill-opacity"),
			stroke: "none"
		});
		this.$text = $(this.text[0]).tooltip();
		this.$text.on("click.onclick", _.bind(this.onClick, this));

		this.paper = paper;
	};
	(function (my) {
		var proto = my.prototype;
		able.make_proto_listenable(proto);
		able.make_proto_optionable(proto);

		proto.destroy = function() {
			this.$text.off("click.onclick");
			this.$text.tooltip("destroy")
						.remove();
			delete this.$text;
			delete this.text;
			if(this.textbox) {
				$(this.textbox)	.off("keydown.onkeydown")
								.off("blur.onblur")
								.remove();
				delete this.textbox;
			}
			able.destroy_this_listenable(this);
			able.destroy_this_optionable(this);
		};

		proto.get_raphael_object = function () {
			return this.text;
		};
		proto.toFront = function() {
			this.label_background.toFront();
			this.text.toFront();
		};

		proto.show_default = function () {
			return this.option("text") === "";
		};
		proto.get_text = function () {
			if (this.show_default()) {
				return this.option("default");
			} else {
				return this.option("text");
			}
		};
		proto.onClick = function (event) {
			if(this.option("edit_on_click") !== false) {
				this.edit();
			}
		};
		proto.edit = function () {
			this.textbox = window.document.createElement("input");
			this.textbox.type = "text";
			this.textbox.style.zIndex = 2;
			var bbox = this.getBBox();
			var width = Math.max(bbox.width, this.option("width"));

			var anchor = this.text.attr("text-anchor");
			if (anchor === "start") {
				this.textbox.style.left = this.option("x") + "px";
			} else if (anchor === "middle") {
				this.textbox.style.left = (this.option("x") - width / 2) + "px";
			} else {
				this.textbox.style.left = (this.option("x") - width) + "px";
			}

			this.textbox.style.width = width + "px";
			match_styles(this.textbox, this.text, {
					"color": this.option("textbox_color"),
					"fill": this.option("textbox_background")
				});
			this.paper.canvas.parentNode.insertBefore(this.textbox, this.paper.canvas);
			this.textbox.value = this.option("text");

			this.text.hide();
			this.textbox.focus();
			this.textbox.select();
			$(this.textbox)	.on("keydown.onkeydown", _.bind(this.onKeydown, this))
							.on("blur.onblur", _.bind(this.onBlur, this));
			return this;
		};
		proto.getBBox = function () {
			return this.text.getBBox();
		};
		proto.update_label_background = function () {
			var bbox = this.getBBox();
			if(bbox) {
				this.label_background.attr({
					x: bbox.x - 1,
					y: bbox.y - 1,
					width: bbox.width+2,
					height: bbox.height+2,
					fill: this.option("fill")
				});
			}
		};
		proto.onKeydown = function (event) {
			//var textbox = event.srcElement;
			if (event.keyCode === 27) { //esc
				this.onCancel();
				this.showText();
			} else if (event.keyCode === 13) { // enter
				this.onTextChange(this.textbox.value);
				this.showText();
			}
		};
		proto.onCancel = function() {
			this._emit("cancel");
		};
		proto.onTextChange = function (value) {
			this.option("text", value);
			this.text.attr("text", this.get_text());
			if (this.show_default()) {
				this.text.attr("fill", this.option("default_color"));
			} else {
				this.text.attr("fill", this.option("color"));
			}
			this.update_label_background();
			this._emit("change", {
				value: value,
				target: this
			});
		};
		proto.onBlur = function (event) {
			//var textbox = event.srcElement;
			this.onTextChange(this.textbox.value);
			this.showText();
		};
		proto.showText = function () {
			this.text.show();
			$(this.textbox)	.off("keydown.onkeydown")
							.off("blur.onblur")
							.remove();
			delete this.textbox;
		};
		proto._on_options_set = function (values, animated) {
			if(_.isNumber(animated)) {
				this.text.animate({
					//x: this.option("x"),
					//y: this.option("y"),
					fill: this.show_default() ? this.option("default_color") : this.option("color")
					//text: this.option("text")
				}, animated);
			} else {
				this.text.attr({
					x: this.option("x"),
					y: this.option("y"),
					width: this.option("width"),
					font: this.option("font"),
					"font-family": this.option("font-family"),
					"font-size": this.option("font-size"),
					"font-weight": this.option("font-weight"),
					"text-anchor": this.option("text-anchor"),
					fill: this.show_default() ? this.option("default_color") : this.option("color"),
					text: this.option("text")
				});
				this.update_label_background();
			}
		};
		proto.remove = function () {
			this.label_background.remove();
			this.text.remove();
		};
		proto.hide = function() {
			this.label_background.hide();
			this.text.hide();
			return this;
		};
		proto.show = function() {
			this.label_background.show();
			this.text.show();
			return this;
		};
		proto.focus = function() {
			this.textbox.focus();
			return this;
		};
		proto.select = function() {
			this.textbox.select();
			return this;
		};
	}(ist.EditableText));
}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,window,RedMap */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var show_all_start_states = ist.__debug_statecharts;

	var FAKE_ROOT_STATECHART = {
			hash: function () {
				return "null";
			},
			get_incoming_transitions: function () {
				return [];
			},
			id: function () {
				return "FAKE";
			},
			parent_is_concurrent: function() { return false; },
			is_initialized: function () { return true; },
			basis: function () { return false; }
		};

	ist.RootStatechartLayoutEngine = function (options) {
		able.make_this_optionable(this, {
			theta_degrees: 45,
			transition_height: 18,
			transition_margin: 1,
			state_name_width: 90,
			state_name_height: function() { return this.option("transition_height"); },
			state_padding_y: function() { return this.option("transition_margin"); },
			state_padding_x: 8,
			add_state_width: 50,
			start_state_width: function() { return this.option("state_name_width"); },
			start_state_radius: 5,
			theta_radians: function() { return this.option("theta_degrees") * Math.PI / 180; },
			tan_theta: function() { return Math.tan(this.option("theta_radians")); },
			transition_width: function() { return this.option("transition_height") / this.option("tan_theta"); },
			state_line_padding_factor: 1/2,
			padding_top: 0,
			statecharts_with_add_state_button: [],
			statecharts: []
		}, options);
		this.$layout = cjs(_.bind(this._compute_layout, this));
	};
	(function (My) {
		var proto = My.prototype;

		able.make_proto_optionable(proto);

		proto.destroy = function() {
			able.destroy_this_optionable(this);
			this.$layout.destroy();
			delete this.$layout;
		};

		proto.invalidate = function() {
			this.$layout.invalidate();
		};

		proto.get_statechart_tree = function () {
			var expand_node = function (node, is_root) {
				var sc = node.statechart;
				if (sc instanceof ist.Statechart && sc.is_initialized()) {
					var substates = sc.get_substates();

					if(_.size(substates) > 0 || is_root || show_all_start_states) { // use is_root for root statecharts with only a start state
						if(!sc.is_concurrent() || show_all_start_states) {
							node.children.push({statechart: sc.get_start_state(), children: []});
						}
						node.children.push.apply(node.children, _.map(substates, function (x) {
							var subnode = {statechart: x, children: []};
							expand_node(subnode);
							return subnode;
						}));
					}
				}
			};
			var curr_node = {
				statechart: FAKE_ROOT_STATECHART,
				children: _	.chain(this.option("statecharts"))
							.map(function (sc) {
								if(sc.destroyed) {
									return false;
								} else {
									var node = {statechart: sc, children: []};
									expand_node(node, true);
									return node;
								}
							}, this)
							.compact()
							.value()
				};
			return curr_node;
		};

		proto.get_x = function (state_wrapper) {
			var full_layout_info = this.get_layout();
			if (state_wrapper) {
				var id = state_wrapper.cobj_id;
				var layout = full_layout_info.locations;
				var keys = _.map(layout.keys(), function (x) { return x.puppet_master_id || x.id() || -1; }),
					values = layout.values();

				var i = _.indexOf(keys, id);
				var layout_info = values[i];
				if (layout_info) {
					if (state_wrapper.type() === "statechart") {
						return layout_info.center.x;
					} else if (state_wrapper.type() === "transition") {
						return layout_info.from.x;
					} else if(state_wrapper.type() === "start_state") {
						return layout_info.center.x;
					}
				}
			} else {
				return full_layout_info.width;
			}
		};
		proto.total_width = function () {
			var full_layout_info = this.get_layout();
			return full_layout_info.width;
		};

		proto.get_width = function (state_wrapper) {
			if (state_wrapper.type() === "statechart") {
				return this.option("state_name_width");
			} else if (state_wrapper.type() === "transition") {
				return this.option("transition_width");
			} else if (state_wrapper.type() === "start_state") {
				return this.option("start_state_width");
			}
			return 0;
		};

		proto.get_layout = function () {
			return this.$layout.get();
		};

		proto._compute_layout = function () {
			var THETA_DEGREES = this.option("theta_degrees"),
				TRANSITION_HEIGHT = this.option("transition_height"),
				TRANSITION_MARGIN = this.option("transition_margin"),
				STATE_NAME_WIDTH = this.option("state_name_width"),
				STATE_NAME_HEIGHT = this.option("state_name_height"),
				STATE_PADDING_Y = this.option("state_padding_y"),
				STATE_PADDING_X = this.option("state_padding_x"),
				ADD_STATE_WIDTH = this.option("add_state_width"),
				START_STATE_WIDTH = this.option("start_state_width"),
				THETA_RADIANS = this.option("theta_radians"),
				TAN_THETA = this.option("tan_theta"),
				TRANSITION_WIDTH = this.option("transition_width"),
				STATE_LINE_PADDING_FACTOR = this.option("state_line_padding_factor"),
				START_STATE_RADIUS = this.option("start_state_radius"),
				PADDING_TOP = this.option("padding_top");
			var statecharts_with_add_state_button = this.option("statecharts_with_add_state_button");

			var sc_tree = this.get_statechart_tree();
			var rows = [];
			var columns = [];
			var i, j;

			var col_indicies = new RedMap({
				hash: "hash"
			});
			var depth = 0;
			var push_node_columns = function (node, depth) {
				var statechart = node.statechart;
				var children = node.children;
				var children_split_index = children.length;// Math.ceil(children.length / 2);

				var col_len = columns.length;
				var li, ri;
				if (statechart instanceof ist.StartState) {
					columns.push({ state: statechart, lr: "c", depth: depth + 1});
					col_indicies.put(statechart, {c: col_len});
					li = ri = col_len;
				} else {
					li = col_len;
					columns.push({ state: statechart, lr: "l", depth: depth});

					_.each(children.slice(0, children_split_index), function (childnode) {
						push_node_columns(childnode, depth + 1);
					});

					var ci = columns.length;
					columns.push({ state: statechart, lr: "c", depth: depth});

					_.each(children.slice(children_split_index), function (childnode) {
						push_node_columns(childnode, depth + 1);
					});

					ri = columns.length;
					columns.push({ state: statechart, lr: "r", depth: depth});

					col_indicies.put(statechart, {l: li, r: ri });
				}

				var row;
				if (rows[depth]) {
					row = rows[depth];
				} else {
					rows[depth] = row = [];
				}
				for (i = li; i <= ri; i += 1) {
					row[i] = statechart;
				}
			};
			push_node_columns(sc_tree, 0);

			var from_to = [];
			var collect_from_to = function (node) {
				var statechart = node.statechart,
					indicies = col_indicies.get(statechart);

				var li, ri;
				if(statechart instanceof ist.StartState) {
					li = ri = indicies.c;
				} else {
					li = indicies.l;
					ri = indicies.r;
				}

				if (statechart.is_initialized()) {
					var incoming_transitions;

					if(statechart.parent_is_concurrent() && !ist.__debug_statecharts) {
						incoming_transitions = [];
					} else {
						incoming_transitions = statechart.get_incoming_transitions();
					}

					_.each(incoming_transitions, function (t) {
						if (!t.is_initialized()) {
							return;
						}
						var x = t.from();
						if (x === statechart) {
							if(!(statechart instanceof ist.StartState)) {
								from_to.push({min_x: ri, max_x: ri, type: "self", transition: t});
							}
						} else {
							if(x.parent_is_concurrent() && !ist.__debug_statecharts) {
								return;
							}

							var x_indicies = col_indicies.get(x);
							var min_x, max_x, type;
							if (statechart.order(x) < 0) {
								min_x = _.has(x_indicies, "r") ? x_indicies.r : x_indicies.c;
								max_x = li;
								type = "right";
							} else {
								min_x = ri;
								max_x = _.has(x_indicies, "l") ? x_indicies.l : x_indicies.c;
								type = "left";
							}
							from_to.push({ min_x: min_x, max_x: max_x, type: type, transition: t });
						}
					});
				}

				_.each(node.children, collect_from_to);
			};
			collect_from_to(sc_tree);

			_.each(from_to, function (info) {
				var from = info.min_x,
					to = info.max_x;

				var has_enough_space;
				var curr_row = false;
				var row_index;
				for (i = 0; i < rows.length; i += 1) {
					has_enough_space = true;
					var row = rows[i];
					for (j = from; j <= to; j += 1) {
						if (row[j]) {
							has_enough_space = false;
							break;
						}
					}
					if (has_enough_space) {
						curr_row = rows[i];
						row_index = i;
						break;
					}
				}
				if (!curr_row) {
					curr_row = [];
					row_index = rows.length;
					rows.push(curr_row);
				}

				var transition = info.transition;
				for (i = from; i <= to; i += 1) {
					curr_row[i] = transition;
				}
			});

	// FOR DEBUGGING
	/*
		if(uid.strip_prefix(this.statecharts[0].id()) == 24) {
			_.each(this.statecharts, function (statechart) {
				try {
				statechart.print();
				}
				catch(e) {}
			});
			var curr_element, curr_element_start_col;
			for (i = rows.length - 1; i >= 0; i -= 1) {
				row = rows[i];
				var row_arr = [];
				for (j = 0; j <= row.length; j += 1) {
					if (row[j] !== curr_element) {
						if (curr_element) {
							var col_length = j - curr_element_start_col;
							var cl_2 = Math.floor(col_length / 2);
							var id = "-" + uid.strip_prefix(curr_element.id());
							while (id.length < 4) {
								id += "-";
							}
							for (var k = curr_element_start_col; k<j; k += 1) {
								if (k === curr_element_start_col + cl_2) {
									row_arr[k] = id;
								} else {
									row_arr[k] = "----";
								}
							}
							row_arr[curr_element_start_col] = "|" + row_arr[curr_element_start_col].slice(1);
							row_arr[j-1] = row_arr[j-1].slice(0, 3) + "|";
						}
						curr_element_start_col = j;
						curr_element = row[j];
					}
					if (!curr_element) {
						row_arr[j] = "    ";
					}
				}
				var row_str = row_arr.join("");
				console.log(row_str);
				curr_element = false;
			}
		}
			/**/

			// So far, we have poles for each state's left transitions, the state itself, and its right transitions.
			// Now, we have to figure out how far to spread each state's left poles

			var location_info_map = new RedMap({
				hash: "hash"
			});

			var y = PADDING_TOP;
			var column_widths = [];
			var num_rows = rows.length;

			var H = TRANSITION_HEIGHT + 2 * TRANSITION_MARGIN;

			var dy = H / 2;
			var dx =  dy / TAN_THETA;

			var x = dx;

			var is_from, is_to, row, location_info, cell, wing_start_x, wing_start_y, column_values;
			var return_empty_obj = function () { return {}; };
			for (i = 0; i < columns.length; i += 1) {
				var column = columns[i];
				var state = column.state;
				if (column.lr === "l" || column.lr === "r") { //it's a transition pole
					column_values = _.pluck(rows, i);

					if (column.lr === "l") {
						x += STATE_PADDING_X / 2;
						y = PADDING_TOP + H * (num_rows - column_values.length + 1) + (H / 2);

						var found_relevant_transition = false;
						for (row = column_values.length - 1; row >= column.depth; row -= 1) {
							cell = column_values[row];

							//if (found_relevant_transition) {x += dx; y += dy; }
							if (cell === state) {
								if (!found_relevant_transition) {
									wing_start_x = x - dx * STATE_LINE_PADDING_FACTOR;
									wing_start_y = y - dy * STATE_LINE_PADDING_FACTOR;
								}
								break;
							} else {
								if (cell instanceof ist.StatechartTransition) {
									is_from = cell.from() === state;
									is_to = cell.to() === state;
									if (is_from || is_to) {
										var to_continue = false;
										if (!found_relevant_transition) {
											found_relevant_transition = true;
											wing_start_x = x - dx * STATE_LINE_PADDING_FACTOR;
											wing_start_y = y - dy * STATE_LINE_PADDING_FACTOR;
											to_continue = true;
										}
										location_info = location_info_map.get_or_put(cell, return_empty_obj);

										if (is_from && is_to) {
											location_info.from = location_info.to = {x: x, y: y};
										} else if (is_from) {
											location_info.from = {x: x, y: y};
										} else { // includes start state
											location_info.to = {x: x, y: y};
										}
									}
								}

							}
							if (found_relevant_transition) {x += 2 * dx; }
							y += H;
						}

						location_info = {};
						location_info.left_wing_start = { x: wing_start_x, y: wing_start_y };
						location_info.left_wing_end = { x: x, y: y };
						location_info_map.put(state, location_info);
					} else {
						var found_state;
						y = PADDING_TOP + H * (num_rows - column.depth) + H / 2;
						wing_start_x = x;
						wing_start_y = y;
						var wing_end_x = x + dx * STATE_LINE_PADDING_FACTOR,
							wing_end_y = y - dy * STATE_LINE_PADDING_FACTOR;

						var last_relevant_transition_index = -1;
						for (row = column_values.length - 1; row >= column.depth; row -= 1) {
							cell = column_values[row];
							if (cell instanceof ist.StatechartTransition && (cell.from() === state || cell.to() === state)) {
								last_relevant_transition_index  = row;
								break;
							}
						}
						for (row = column.depth; row < column_values.length; row += 1) {
							cell = column_values[row];
							if (cell === state) {
								wing_start_x = x;
								wing_start_y = y;
							} else {
								if (cell instanceof ist.StatechartTransition) {
									is_from = cell.from() === state;
									is_to = cell.to() === state;
									if (is_from || is_to) {
										wing_end_x = x + dx * STATE_LINE_PADDING_FACTOR;
										wing_end_y = y - dy * STATE_LINE_PADDING_FACTOR;

										location_info = location_info_map.get_or_put(cell, return_empty_obj);

										if (is_from && is_to) {
											location_info.from = location_info.to = {x: x, y: y};
										} else if (is_from) {
											location_info.from = {x: x, y: y};
										} else { // includes start state
											location_info.to = {x: x, y: y};
										}
									}
								}
							}
							if (row <= last_relevant_transition_index) { x += 2 * dx; }
							y -= H;
						}
						location_info = location_info_map.get(state);
						location_info.right_wing_start = { x: wing_start_x, y: wing_start_y };
						location_info.right_wing_end = { x: wing_end_x, y: wing_end_y };

						x += STATE_PADDING_X / 2;
						if (_.indexOf(this.option("statecharts_with_add_state_button"), state) >= 0) {
							x += ADD_STATE_WIDTH / 2;
							location_info.add_state_button_x = x;
							x += ADD_STATE_WIDTH / 2;
							location_info.right_wing_end.x += ADD_STATE_WIDTH;
							location_info.right_wing_start.x += ADD_STATE_WIDTH;
						}
					}
				} else {
					if (state === FAKE_ROOT_STATECHART) {
						x += STATE_PADDING_X;
					} else if (_.indexOf(this.option("statecharts"), state) >= 0) {
						//x += STATE_PADDING_X/2;
						y = PADDING_TOP + H * (num_rows - column.depth) + H / 2;
						location_info = location_info_map.get(state);
						location_info.center = { x: x, y: y };
						//x += STATE_PADDING_X/2;
					} else if (state instanceof ist.StartState) {
						x += START_STATE_WIDTH / 2;
						y = PADDING_TOP + H * (num_rows - column.depth) + H / 2;
						location_info_map.put(state, { center: { x: x, y: y } });

						column_values = _.pluck(rows, i);

						for (row = column_values.length - 1; row >= column.depth; row -= 1) {
							cell = column_values[row];
							if (cell instanceof ist.StatechartTransition && (cell.from() === state || cell.to() === state)) {
								is_from = cell.from() === state;
								is_to = cell.to() === state;

								location_info = location_info_map.get_or_put(cell, return_empty_obj);
								if (is_from && is_to) {
									location_info.from = location_info.to = {x: x, y: y};
								} else {
									if (is_from) {
										location_info.from = {x: x, y: y};
									} else { // includes start state
										location_info.to = {x: x, y: y};
									}
								}
							}
						}

						x += START_STATE_WIDTH / 2;
					} else {
						x += STATE_NAME_WIDTH / 2;
						y = PADDING_TOP + H * (num_rows - column.depth) + H / 2;
						location_info = location_info_map.get(state);
						location_info.center = { x: x, y: y };
						x += STATE_NAME_WIDTH / 2;
					}
				}
			}

			var width = x;
			var height = PADDING_TOP + (num_rows - 1) * H;

			return {width: width, height: height, locations: location_info_map};
		};
	}(ist.RootStatechartLayoutEngine));
}(interstate));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,jQuery*/

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var highlight_running = ist.__debug_statecharts;

	ist.StartStateView = function (options) {
		able.make_this_optionable(this, {
			state: null,
			paper: null,
			c: {x: 0, y: 0},
			radius: 6,
			fill_color: "black",
			padding_top: 0,
			paper_height: 9999,
			vline_color: "#CCC",
			vline_dasharray: ". ",
			active_fill: ist.__debug_statecharts ? "red" : "black",
			running_stroke: "#99E",
			stroke: "none",
			running_stroke_width: 3,
			stroke_width: 0
		}, options);

		var state = this.option("state");
		if (state.is_initialized()) {
			this.initialize();
		} else {
			state.once("initialized", this.initialize, this);
		}
	};

	(function (My) {
		var proto = My.prototype;
		able.make_proto_optionable(proto);

		proto.initialize = function() {
			var paper = this.option("paper");
			var center = this.option("c");
			var state = this.option("state");
			this.active_fn = cjs.liven(function () {
				if (state.is_initialized() && state.is_active()) {
					if (this.circle) {
						this.circle.attr({
							fill: this.option("active_fill")
						});
					}
				} else {
					if (this.circle) {
						this.circle.attr({
							fill: this.option("fill_color")
						});
					}
				}
			}, {
				context: this
			});
			if(highlight_running) {
				this.running_fn = cjs.liven(function () {
					var state = this.option("state");
					if (state.is_initialized() && state.get_$running()) {
						if (this.circle) {
							this.circle.attr({
								"stroke": this.option("running_stroke"),
								"stroke-width": this.option("running_stroke_width")
							});
						}
					} else {
						if (this.circle) {
							this.circle.attr({
								"stroke": this.option("stroke"),
								"stroke-width": this.option("stroke_width")
							});
						}
					}
				}, {
					context: this
				});
			}

			this.vline = paper	.path("M" + center.x + "," + center.y + "V" + this.option("paper_height"))
								.attr({
									stroke: this.option("vline_color"),
									"stroke-dasharray": this.option("vline_dasharray")
								});
			this.circle = paper.circle(center.x, center.y + this.option("padding_top"), this.option("radius"));
			this.circle.attr({
				fill: state.is_active() ? this.option("active_fill") : this.option("fill_color"),
				stroke: "none"
			});
			$(this.circle[0]).on("contextmenu.cm");
		};

		proto.toFront = function() {
			if(this.vline) {
				this.vline.toFront();
			}
			if(this.circle) {
				this.circle.toFront();
			}
		};

		proto._on_options_set = function (values) {
			var paper = this.option("paper");
			var center = this.option("c");
			var paper_height = this.option("paper_height");
			if(this.circle) {
				this.circle.attr({
					cx: center.x,
					cy: center.y + this.option("padding_top"),
					r: this.option("radius")
				});
			}
			if(this.vline) {
				this.vline	.attr({
								path: "M" + center.x + "," + center.y + "V" + paper_height
							})
							.toBack();
			}
		};

		proto.on_context_menu = function(event) {
			event.preventDefault();
			event.stopPropagation();
			var parent = this.option("parent");
			var outgoing_transition = this.option("state").get_outgoing_transition();
			var view = parent.get_view(outgoing_transition);
			if(view) {
				view.show_menu();
			}
		};

		proto.begin_editing = function() {
		};
		proto.done_editing = function() {
		};
		proto.remove = function () {
			if(this.circle) {
				this.circle.remove();
			}
			if(this.vline) {
				this.vline.remove();
			}
		};
		proto.destroy = function() {
			if(this.circle) {
				$(this.circle[0]).off("contextmenu.cm");
			}
			able.destroy_this_optionable(this);
			if(this.active_fn) {
				this.active_fn.destroy();
				delete this.active_fn;
			}
			if(this.running_fn) {
				this.running_fn.destroy();
				delete this.running_fn;
			}
		};
	}(ist.StartStateView));
}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,jQuery,window */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;
	var highlight_running = ist.__debug_statecharts;

	ist.StateView = function (options) {
		able.make_this_listenable(this);
		able.make_this_optionable(this, {
			state: null,
			paper: null,
			lws: {x: 0, y: 0},
			lwe: {x: 0, y: 0},
			rws: {x: 0, y: 0},
			rwe: {x: 0, y: 0},
			c: {x: 0, y: 0},
			default_stroke: "black",
			default_fill: "white",
			active_fill: "green",
			active_text_foreground: "#008000",
			active_stroke: "green",
			selectable_fill: "#AAA",
			text_foreground: "black",
			text_background: "white",
			font_family: "Source Sans Pro",
			font_size: 12,
			padding_top: 0,
			paper_height: 9999,
			vline_color: "#CCC",
			vline_dasharray: ". ",
			stroke_width: 1,
			running_width: 3
		}, options);

		this.active_fn = cjs.liven(function () {
			var state = this.option("state");
			if (state.is_initialized() && state.is_active()) {
				if (this.path) {
					this.path.animate({
						"fill": this.option("active_fill"),
						"stroke": this.option("active_stroke")
					}, 300, "ease-out");
					this.label.option("color", this.option("active_text_foreground"), 300);
				}
			} else {
				if (this.path) {
					this.path.animate({
						"fill": this.option("default_fill"),
						"stroke": this.option("default_stroke")
					}, 300, "ease-out");
					this.label.option("color", this.option("text_foreground"), 300);
				}
			}
		}, {
			context: this
		});
		if(highlight_running) {
			this.running_fn = cjs.liven(function () {
				var state = this.option("state");
				if (state.is_initialized() && state.get_$running()) {
					if (this.path) {
						this.path.attr("stroke-width", this.option("running_width"));
					}
				} else {
					if (this.path) {
						this.path.attr("stroke-width", this.option("stroke_width"));
					}
				}
			}, {
				context: this
			});
		}

		var state = this.option("state");
		var paper = this.option("paper");

		this.path = paper	.path("M0,0")
							.toBack();
		this.vline = paper	.path("M0,0")
							.attr({
								stroke: this.option("vline_color"),
								"stroke-dasharray": this.option("vline_dasharray")
							})
							.toBack();
		this.label = new ist.EditableText(paper, {x: -100, y: -100, text: "", fill: this.option("text_background"), color: this.option("text_foreground")});

		if (state.is_initialized()) {
			this.initialize();
		} else {
			state.once("initialized", this.initialize, this);
		}
	};

	(function (My) {
		var proto = My.prototype;
		able.make_proto_listenable(proto);
		able.make_proto_optionable(proto);
		proto.initialize = function () {
			var state = this.option("state");
			this.path .attr({
							"path": this.get_path_str(),
							"stroke": this.option(state.is_active() ? "active_stroke" : "default_stroke"),
							"fill": this.option(state.is_active() ? "active_fill" : "default_fill")
						});
			var center = this.option("c");

			this.label	.on("cancel", this.on_cancel_rename, this)
						.on("change", this.on_confirm_rename, this);
			this.label.option({
				"font-size": this.option("font_size"),
				"font-family": this.option("font_family"),
				x: center.x,
				y: center.y,
				text: this.get_name()
			});
			this.label.on("change", this.forward_event, this);
			this.$clickable = $([this.path[0], this.label.text[0]]);
			this.$clickable.on("contextmenu.show", _.bind(this.show_menu, this));
			if(state.parent_is_concurrent()) {
				this.path.attr({
					"stroke-dasharray": "- "
				});
			} else {
				this.path.attr({
					"stroke-dasharray": ""
				});
			}
		};

		proto.toFront = function() {
			this.path.toFront();
			this.vline.toFront();
			this.label.toFront();
		};

		proto.get_name = function() {
			var state = this.option("state");
			var name = state.get_name("parent");
			return name;
		};

		proto._on_options_set = function (values) {
			if (this.path) {
				var state = this.option("state");
				var path_str = this.get_path_str();
				this.path.attr({
					"path": path_str
				});
				if(state.parent_is_concurrent()) {
					this.path.attr({
						"stroke-dasharray": "- "
					});
				} else {
					this.path.attr({
						"stroke-dasharray": ""
					});
				}
				var paper_height = this.option("paper_height");
				var center = this.option("c");
				var name = state.get_name("parent");
				this.label.option({
					x: center.x,
					y: center.y,
					text: name
				});
				this.update_menu_position();
				this.vline.attr({
					path: "M" + center.x + "," + center.y + "V" + paper_height
				});
			}
		};

		proto.show_menu = function(event) {
			if(event) {
				event.preventDefault();
				event.stopPropagation();
			}
			this.add_transition = $("<div />")	.addClass("menu_item")
												.text("Add transition")
												.on("click.menu_item", _.bind(this.on_add_transition_item_pressed, this));
			this.rename_item = $("<div />")	.addClass("menu_item")
											.text("Rename")
											.on("click.menu_item", _.bind(this.on_rename_item_pressed, this));
			this.remove_item = $("<div />")	.addClass("menu_item")
											.text("Delete")
											.on("click.menu_item", _.bind(this.on_remove_item_pressed, this));

			this.add_substate_item = $("<div />")	.addClass("menu_item")
													.text("Add substate")
													.on("click.menu_item", _.bind(this.on_add_substate_item_pressed, this));

			var is_concurrent = this.option("state").is_concurrent();
			var checkbox_mark = is_concurrent ? "&#x2612;" : "&#x2610;";
			this.toggle_concurrency_item = $("<div />")	.addClass("menu_item")
														.html("Concurrent " + checkbox_mark)
														.on("click.menu_item", _.bind(this.on_toggle_concurrency_item_pressed, this));
			this.toggle_breakpoint_item = $("<div />")	.addClass("menu_item")
														.text("Add breakpoint")
														.on("click.menu_item", _.bind(this.on_toggle_breakpoint_item_pressed, this));
			var lwe = this.option("lwe"),
				rws = this.option("rws");
			var PADDING = 1;
			var HEIGHT = 10;
			var width = rws.x-lwe.x - 2*PADDING;
			var x = lwe.x + PADDING;
			var y = lwe.y - HEIGHT/2;

			var paper = this.option("paper");
			var parentElement = paper.canvas.parentNode;

			this.edit_dropdown = $("<div />")	.append(this.add_transition, this.add_substate_item, this.toggle_concurrency_item, this.toggle_breakpoint_item, this.rename_item, this.remove_item)
												.addClass("dropdown")
												.css({
													position: "absolute",
													left: x + "px",
													top: y + "px",
													width: width + "px"
												})
												.appendTo(parentElement);
			var state = this.option("state");
			$(window).on("mousedown.expanded_mousedown", _.bind(this.on_window_click_while_expanded, this));
			$(window).on("keydown.expanded_keydown", _.bind(this.on_window_keydown_while_expanded, this));
		};
		proto.add_transition_to_state = function(to_state) {
			this._emit("add_transition", {
				from: this.option("state"),
				to: to_state
			});
		};
		proto.on_add_transition_item_pressed = function(event) {
			event.preventDefault();
			event.stopPropagation();
			this.remove_edit_dropdown();
			var from_state = this.option("state");
			var root = from_state.root();
			var flat_statecharts = root.flatten_substates();
			var selectable_substates = flat_statecharts.splice(0, flat_statecharts.length-1); // the first element is the major statechart itself
			this._emit("awaiting_state_selection", {
				states: selectable_substates,
				on_select: _.bind(function() {
								this.add_transition_to_state.apply(this, arguments);
								$(window).off("mousemove.update_display_arrow");
								arrow_disp.remove();
								arrow_disp.destroy();
							}, this),
				on_cancel: _.bind(function() {
								$(window).off("mousemove.update_display_arrow");
								arrow_disp.remove();
								arrow_disp.destroy();
							}, this)
			});

			var paper = this.option("paper"),
				lwe = this.option("lwe"),
				rwe = this.option("rwe");
			var cx = (lwe.x + rwe.x) / 2;
			var cy = (this.option("padding_top") + lwe.y)/2;

			var arrow_disp = new ist.ArrowView({
				paper: paper,
				from: { x: cx, y: cy },
				to: {x: cx, y: cy}
			});
			$(arrow_disp.arrow_path[0]).css("pointer-events", "none");
			
			$(window).on("mousemove.update_display_arrow", function(event) {
				var offset = $(paper.canvas).offset();
				arrow_disp.option("to", { x: event.clientX - offset.left, y: event.clientY - offset.top });
			});
		};
		proto.on_add_substate_item_pressed = function() {
			this.remove_edit_dropdown();
			this._emit("add_state", {
				parent: this.option("state")
			});
		};
		proto.on_rename_item_pressed = function() {
			this.remove_edit_dropdown();
			this.begin_rename();
		};
		proto.on_remove_item_pressed = function() {
			this.remove_edit_dropdown();
			this._emit("remove_state", {
				state: this.option("state")
			});
		};
		proto.on_toggle_concurrency_item_pressed = function() {
			var my_state = this.option("state");
			this.remove_edit_dropdown();
			this._emit("make_concurrent", {
				state: my_state,
				concurrent: !my_state.is_concurrent()
			});
		};
		proto.on_toggle_breakpoint_item_pressed = function() {
			var my_state = this.option("state");
			this.remove_edit_dropdown();
			this._has_breakpoint = true;
			this._emit("toggle_breakpoint", {
				state: my_state
			});
			if(this.togglebreakpoint.text() === "Add breakpoint") {
				this.togglebreakpoint.text("Remove breakpoint");
				this._emit("toggle_breakpoint", {
					transition: my_transition
				});
			} else {
				this.togglebreakpoint.text("Add breakpoint");
				this._emit("toggle_breakpoint", {
					transition: my_transition
				});
			}
		};
		proto.on_window_click_while_expanded = function(event) {
			if(!$(event.target).parents().is(this.edit_dropdown)) {
				this.remove_edit_dropdown();
			}
		};
		proto.on_window_keydown_while_expanded = function(event) {
			if(event.keyCode === 27) { // esc
				this.remove_edit_dropdown();
			}
		};
		proto.update_menu_position = function() {
			if(this.edit_dropdown) {
				var lwe = this.option("lwe"),
					rws = this.option("rws");
				var PADDING = 1;
				var HEIGHT = 10;
				var width = rws.x-lwe.x - 2*PADDING;
				var x = lwe.x + PADDING;
				var y = lwe.y - HEIGHT/2;
				var state = this.option("state");
				var name = this.get_name();
				this.edit_dropdown.css({
					left: x + "px",
					top: y + "px",
					width: width + "px"
				});
			}
		};
		proto.remove_edit_dropdown = function() {
			if(this.edit_dropdown) {
				this.add_transition.off("click.menu_item").remove();
				this.rename_item.off("click.menu_item").remove();
				this.remove_item.off("click.menu_item").remove();
				this.add_substate_item.off("click.menu_item").remove();
				this.toggle_concurrency_item.off("click.menu_item").remove();
				this.toggle_breakpoint_item.off("click.menu_item").remove();
				this.edit_dropdown.remove();
				delete this.edit_dropdown;
			}
			$(window).off("mousedown.expanded_mousedown");
			$(window).off("keydown.expanded_keydown");
		};


		proto.begin_rename = function() {
			this.label.edit();
		};

		proto.on_cancel_rename = function(event) { };

		proto.on_confirm_rename = function(event) {
			var value = event.value;
			this._emit("rename", {
				name: value,
				state: this.option("state")
			});
		};

		proto.get_path_str = function () {
			var pts = [this.option("lws"), this.option("lwe"), this.option("rws"), this.option("rwe")];
			var padding_top = this.option("padding_top");
			var x0 = pts[0].x;
			var y0 = pts[0].y;
			var path_str = "M" + x0 + "," + padding_top + "L" + _.map(pts, function (pt) {
				return pt.x + "," + pt.y;
			}).join("L") + "V"+padding_top+"Z";
			return path_str;
		};
		proto.remove = function () {
			this.path.remove();
			this.label.remove();
			this.vline.remove();
			if(this.edit_dropdown) {
				this.edit_dropdown.remove();
				delete this.edit_dropdown;
			}
		};
		proto.destroy = function() {
			this.unmake_selectable();
			this.$clickable.off("contextmenu.show");
			delete this.$clickable;

			this.remove_edit_dropdown();

			this.active_fn.destroy();
			delete this.active_fn;
			if(this.edit_dropdown) {
				this.edit_dropdown.dropdown("destroy");
			}
			if(this.running_fn) {
				this.running_fn.destroy();
				delete this.running_fn;
			}

			this.label.destroy();
			delete this.label;

			able.destroy_this_listenable(this);
			able.destroy_this_optionable(this);
		};
		proto.make_selectable = function(callback) {
			this.path.attr({
				fill: this.option("selectable_fill"),
				cursor: "pointer"
			});
			if(this._selectable_callback) {
				this.path.unclick(this._selectable_callback);
			}
			this._selectable_callback = callback;
			this.path.click(this._selectable_callback);
			var even = false;
			var interval_time = 500;
			this.change_color_interval = window.setInterval(_.bind(function() {
				if(even) {
					this.path.animate({
						"fill": this.option("selectable_fill")
					}, interval_time);
				} else {
					this.path.animate({
						"fill": "#888"
					}, interval_time);
				}
				even = !even;
			}, this), interval_time);
		};
		proto.unmake_selectable = function() {
			if(this.change_color_interval) {
				this.path.stop();
				window.clearInterval(this.change_color_interval);
				delete this.change_color_interval;
			}
			if(this._selectable_callback) {
				this.path.unclick(this._selectable_callback);
				delete this._selectable_callback;
			}
			var state = this.option("state");
			this.path.attr({
				fill: this.option(state.is_active() ? "active_fill" : "default_fill"),
				cursor: ""
			});
		};
	}(ist.StateView));
}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global Raphael,interstate,esprima,able,uid,console,jQuery,window */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	var highlight_enabled = ist.__debug_statecharts;

	var get_arrow_paths = function (from, to, self_pointing_theta, radius, arrowLength, arrowAngleRadians) {
		var fromX = from.x,
			fromY = from.y,
			toX = to.x,
			toY = to.y;

		var xDiff = toX - fromX,
			yDiff = toY - fromY;

		var line_path_str;
		var lineStartX, lineStartY, lineEndX, lineEndY, theta, arrow_theta;

		if (Math.pow(xDiff, 2) + Math.pow(yDiff, 2) <= Math.pow(radius + arrowLength, 2)) {
			var curve_radius = 2 * radius * radius + arrowLength + 2;

			theta = self_pointing_theta * Math.PI / 180;
			arrow_theta = theta - (90 * Math.PI / 180);

			lineStartX = fromX + radius * Math.cos(theta);
			lineStartY = fromY + radius * Math.sin(theta);
			lineEndX = (fromX + (radius + arrowLength) * Math.cos(theta));
			lineEndY = (fromY - (radius + arrowLength) * Math.sin(theta));

			line_path_str = "M" + lineStartX + "," + lineStartY +
							"C" + (fromX + curve_radius * Math.cos(theta)) +
							"," + (fromY + curve_radius * Math.sin(theta)) +
							"," + (fromX + (curve_radius + arrowLength) * Math.cos(theta)) +
							"," + (fromY - (curve_radius + arrowLength) * Math.sin(theta)) +
							"," + lineEndX +
							"," + lineEndY;

			toX = (toX + radius * Math.cos(theta));
			toY = (toY - radius * Math.sin(theta));
		} else {
			theta = arrow_theta = Math.atan2(yDiff, xDiff);
			lineStartX = fromX + Math.cos(theta) * radius;
			lineStartY = fromY + Math.sin(theta) * radius;
			lineEndX = toX - Math.cos(theta) * arrowLength;
			lineEndY = toY - Math.sin(theta) * arrowLength;

			line_path_str = "M" + lineStartX + "," + lineStartY + "L" + lineEndX + "," + lineEndY;
		}

		var off_line = arrowLength * Math.tan(arrowAngleRadians);
		var arrow_path = [
			{ x: toX, y: toY},
			{ x: lineEndX + off_line * Math.cos(arrow_theta - Math.PI / 2),
				y: lineEndY + off_line * Math.sin(arrow_theta - Math.PI / 2)
				},
			{ x: lineEndX + off_line * Math.cos(arrow_theta + Math.PI / 2),
				y: lineEndY + off_line * Math.sin(arrow_theta + Math.PI / 2)
				}
		];
		var arrow_path_str = "M" + _.map(arrow_path, function (point) {
			return point.x + "," + point.y;
		}).join("L") + "Z";

		return {
			line: { path: line_path_str },
			arrow: { path: arrow_path_str },
			circle: { cx: fromX, cy: fromY, r: radius }
		};
	};

	var center = function (p1, p2) {
		return { x: (p1.x + p2.x) / 2,
					y: (p1.y + p2.y) / 2 };
	};

	ist.TransitionView = function (options) {
		able.make_this_listenable(this);
		able.make_this_optionable(this, {
			transition: null,
			paper: null,
			from: {x: 0, y: 0},
			to: {x: 0, y: 0},
			color: "black",
			active_color: "green",
			text_background: "white",
			text_foreground: "black",
			error_background: "#900",
			error_foreground: "white",
			font_family: "Sourse Sans Pro",
			font_size: 14,
			padding_top: 0,
			paper_height: 9999,
			vline_color: "#CCC",
			vline_dasharray: ". ",
		}, options);
		var paper = this.option("paper");

		this.arrow = new ist.ArrowView({
			paper: paper,
			color: this.option("color"),
			active_color: this.option("active_color"),
			transition: this.option("transition"),
			from: this.option("from"),
			to: this.option("to")
		});
		var transition = this.option("transition");

		var event = transition.event();
		var str = "";
		if (event instanceof ist.ParsedEvent) {
			str = event.get_str();
		}
		var c = center(this.option("from"), this.option("to"));
		this.label = new ist.EditableText(paper, {x: c.x, y: c.y + 8, text: str, fill: this.option("text_background"), color: this.option("text_foreground")});
		this.label.option({
			"font-size": this.option("font_size"),
			"font-family": this.option("font_family")
		});
		this.label	.on("cancel", this.on_cancel_rename, this)
					.on("change", this.on_confirm_rename, this)
					.on("change", this.forward_event, this);
		
		transition.on("fire", this.flash, this);
		var from = this.option("from");

		if (event instanceof ist.ParsedEvent) {
			event.on("setString", function (e) {
				if(this.label) {
					var str = e.to;
					this.label.option("text", str);
				}
			}, this);
			str = event.get_str();
			this.errors_fn = cjs.liven(function () {
				var errors = event.get_errors();
				if(errors && errors.length > 0) {
					this.label.option({
						fill: this.option("error_background"),
						color: this.option("error_foreground")
					});
					var err_text = errors[0];
					$(this.label.text[0])	.attr("title", err_text)
											.tooltip("option", {
												content: err_text
											});
				} else {
					this.label.option({
						fill: this.option("text_background"),
						color: this.option("text_foreground")
					});
					$(this.label.text[0])	.attr("title", "")
											.tooltip("option", {
												tooltipClass: "error",
												content: ""
											});
				}
			}, {
				context: this,
				destroy: function() {
				}
			});
		} else {
			str = "";
		}
		this.label.option("text", str);
		this.vline = paper	.path("M0,0")
							.attr({
								stroke: this.option("vline_color"),
								"stroke-dasharray": this.option("vline_dasharray")
							})
							.toBack();
		this.$clickable = $([this.label.text[0], this.label.label_background[0], this.arrow.line_path[0], this.arrow.circle[0], this.arrow.arrow_path[0]]);
		this.$clickable.on("contextmenu.cm", _.bind(this.show_menu, this));

		$(this.label.text[0]).tooltip({
			tooltipClass: "error"
		});
	};

	(function (My) {
		var proto = My.prototype;
		able.make_proto_listenable(proto);
		able.make_proto_optionable(proto);
		proto._on_options_set = function (values) {
			this.arrow.option(values);
			var transition = this.option("transition");
			var paper_height = this.option("paper_height");
			var event = transition.event();
			var from = this.option("from");
			var c = center(from, this.option("to"));
			this.label.option({
				x: c.x,
				y: c.y + 8
			});
			this.update_menu_position();
		};

		proto.toFront = function() {
			this.arrow.toFront();
			this.vline.toFront();
			this.label.toFront();
		};

		proto.get_str = function() {
			var transition = this.option("transition");
			var event = transition.event();
			var str = "";
			if (event instanceof ist.ParsedEvent) {
				str = event.get_str();
			} else {
				str = "(start)";
			}
			return str;
		};

		proto.flash = function () {
			this.arrow.flash();
		};

		proto.show_menu = function(event) {
			if(event) {
				event.preventDefault();
				event.stopPropagation();
			}

			var paper = this.option("paper");
			var transition = this.option("transition");
			var parentElement = paper.canvas.parentNode;
			this.edit_event = $("<div />").addClass("menu_item")
											.text("Change event")
											.on("click.menu_item", _.bind(this.on_edit_event_pressed, this));
			this.change_from = $("<div />")	.addClass("menu_item")
												.text("Change from")
												.on("click.menu_item", _.bind(this.on_change_from_pressed, this));
			this.change_to = $("<div />").addClass("menu_item")
											.text("Change to")
											.on("click.menu_item", _.bind(this.on_change_to_pressed, this));
			this.remove_item = $("<div />")	.addClass("menu_item")
											.text("Delete")
											.on("click.menu_item", _.bind(this.on_remove_item_pressed, this));
			this.togglebreakpoint = $("<div />").addClass("menu_item")
												.text("Add breakpoint")
												.on("click.menu_item", _.bind(this.on_toggle_breakpoint, this));
			var from = this.option("from"),
				to = this.option("to");
			var min_x = Math.min(from.x, to.x);
			var max_x = Math.max(from.x, to.x);
			var PADDING = 1;
			var HEIGHT = 10;
			var width = Math.max((max_x-min_x) - 2*PADDING, 100);
			var cx = (max_x + min_x)/2;
			var x = cx - width/2;
			var y = from.y;


			this.edit_dropdown = $("<div />")	.addClass("transition dropdown")
												.appendTo(parentElement)
												.css({
													position: "absolute",
													left: x + "px",
													top: y + "px",
													width: width + "px"
												});
			var items;
			if(transition.from() instanceof ist.StartState) {
				this.edit_dropdown.append(this.change_to);
			} else {
				this.edit_dropdown.append(this.edit_event, this.change_from, this.change_to, this.remove_item, this.togglebreakpoint);
			}
			$(window).on("mousedown.close_menu", _.bind(this.on_window_click_while_expanded, this));
			$(window).on("keydown.close_menu", _.bind(this.on_window_keydown_while_expanded, this));
		};

		proto.on_edit_event_pressed = function() {
			this.remove_edit_dropdown();
			this.begin_rename();
		};
		proto.emit_set_from = function(from_state) {
			this._emit("set_from", {
				transition: this.option("transition"),
				from: from_state
			});
		};
		proto.on_change_from_pressed = function() {
			this.remove_edit_dropdown();
			var root = this.option("transition").root();
			var selectable_substates = root.flatten_substates(); // the first element is the major statechart itself
			selectable_substates = selectable_substates.splice(0, selectable_substates.length-1);
			this._emit("awaiting_state_selection", {
				states: selectable_substates,
				on_select: _.bind(this.emit_set_from, this)
			});
		};
		proto.emit_set_to = function(to_state) {
			this._emit("set_to", {
				transition: this.option("transition"),
				to: to_state
			});
		};
		proto.on_change_to_pressed = function() {
			this.remove_edit_dropdown();
			var root = this.option("transition").root();
			var selectable_substates = root.flatten_substates(); // the first element is the major statechart itself
			selectable_substates = selectable_substates.splice(0, selectable_substates.length-1);
			this._emit("awaiting_state_selection", {
				states: selectable_substates,
				on_select: _.bind(this.emit_set_to, this)
			});
		};
		proto.on_remove_item_pressed = function() {
			this.remove_edit_dropdown();
			this._emit("remove_transition", {
				transition: this.option("transition")
			});
		};
		proto.on_toggle_breakpoint = function() {
			this.remove_edit_dropdown();
			var my_transition = this.option("transition");
			this._has_breakpoint = true;

			if(this.togglebreakpoint.text() === "Add breakpoint") {
				this.togglebreakpoint.text("Remove breakpoint");
				this._emit("toggle_breakpoint", {
					transition: my_transition
				});
			} else {
				this.togglebreakpoint.text("Add breakpoint");
				this._emit("toggle_breakpoint", {
					transition: my_transition
				});
			}
		};

		proto.on_window_click_while_expanded = function(event) {
			if(!$(event.target).parents().is(this.edit_dropdown)) {
				this.remove_edit_dropdown();
			}
		};
		proto.on_window_keydown_while_expanded = function(event) {
			if(event.keyCode === 27) { // esc
				this.remove_edit_dropdown();
			}
		};

		proto.update_menu_position = function() {
			if(this.edit_dropdown) {
				var from = this.option("from"),
					to = this.option("to");
				var min_x = Math.min(from.x, to.x);
				var max_x = Math.max(from.x, to.x);
				var PADDING = 1;
				var HEIGHT = 10;
				var width = Math.max((max_x-min_x) - 2*PADDING, 100);
				var cx = (max_x + min_x)/2;
				var x = cx - width/2;
				var y = from.y;

				this.edit_dropdown.css({
										left: x + "px",
										top: y + "px",
										width: width + "px"
									});
			}
		};
		proto.begin_rename = function() {
			this.label.edit();
		};

		proto.on_cancel_rename = function(event) {
			this.end_rename();
		};

		proto.on_confirm_rename = function(event) {
			var value = event.value;
			this.end_rename();
			this._emit("set_str", {
				str: value,
				transition: this.option("transition")
			});
		};

		proto.end_rename = function() { };

		proto.remove_edit_dropdown = function() {
			$(window).off("mousedown.close_menu");
			$(window).off("keydown.close_menu");
			if(this.edit_dropdown) {
				this.edit_event.off("click.menu_item").remove();
				this.change_from.off("click.menu_item").remove();
				this.change_to.off("click.menu_item").remove();
				this.remove_item.off("click.menu_item").remove();
				this.togglebreakpoint.off("click.menu_item").remove();
				this.edit_dropdown.remove();
				delete this.edit_dropdown;
			}
		};

		proto.remove = function () {
			this.arrow.remove();
			this.vline.remove();
			this.label.remove();
			if(this.edit_dropdown) {
				this.edit_dropdown.remove();
				delete this.edit_dropdown;
			}
		};

		proto.destroy = function () {
			this.arrow.destroy();
			this.$clickable.off("contextmenu.cm");
			delete this.$clickable;
			this.label	.off("cancel", this.on_cancel_rename, this)
						.off("change", this.on_confirm_rename, this);
			this.label.destroy();
			delete this.label;

			var transition = this.option("transition");
			if(!transition.destroyed) {
				transition.off("fire", this.flash, this);
			}
			if(this.edit_dropdown) {
				this.edit_dropdown.dropdown("destroy");
			}
			if(this.enabled_fn) {
				this.enabled_fn.destroy();
			}

			able.destroy_this_listenable(this);
			able.destroy_this_optionable(this);
		};
	}(ist.TransitionView));

	ist.ArrowView = function (options) {
		able.make_this_listenable(this);
		able.make_this_optionable(this, {
			paper: null,
			from: {x: 0, y: 0},
			to: {x: 0, y: 0},
			arrowLength: 8,
			radius: 1,
			arrowAngle: 20,
			self_pointing_theta: 40,
			color: "black",
			active_color: "green",
			enabled_dasharray: "",
			disabled_dasharray: ". "
		}, options);
		var paper = this.option("paper");
		var paths = this.get_paths();
		this.line_path = paper.path(paths.line.path);
		this.line_path.attr({
			stroke: this.option("color")
		});
		this.arrow_path = paper.path(paths.arrow.path);
		this.arrow_path.attr({
			fill: this.option("color"),
			stroke: "none"
		});
		this.circle = paper.circle(paths.circle.cx, paths.circle.cy, paths.circle.r);
		this.circle.attr({
			fill: this.option("color"),
			stroke: "none"
		});

		if(highlight_enabled) {
			this.enabled_fn = cjs.liven(function () {
				var transition = this.option("transition");
				if (transition && transition.is_initialized() && transition.get_$enabled()) {
					if (this.line_path) {
						this.line_path.attr("stroke-dasharray", this.option("enabled_dasharray"));
					}
				} else {
					if (this.line_path) {
						this.line_path.attr("stroke-dasharray", this.option("disabled_dasharray"));
					}
				}
			}, {
				context: this
			});
		}
	};
	(function (My) {
		var proto = My.prototype;
		able.make_proto_listenable(proto);
		able.make_proto_optionable(proto);

		proto.get_paths = function () {
			var from = this.option("from"),
				to = this.option("to"),
				self_pointing_theta = this.option("self_pointing_theta"),
				radius = this.option("radius"),
				arrowLength = this.option("arrowLength"),
				arrowAngleRadians = this.option("arrowAngle") * Math.PI / 180;
			
			return get_arrow_paths(from, to, self_pointing_theta, radius, arrowLength, arrowAngleRadians);
		};

		proto._on_options_set = function (values) {
			var paths = this.get_paths();
			this.line_path.attr("path", paths.line.path);
			this.arrow_path.attr("path", paths.arrow.path);
			var from = this.option("from");
			this.circle.attr({
				cx: paths.circle.cx,
				cy: paths.circle.cy,
				r: paths.circle.r
			});
		};
		proto.toFront = function() {
			this.line_path.toFront();
			this.circle.toFront();
			this.arrow_path.toFront();
		};
		var anim_time = 400;
		proto.flash = function () {
			var paper = this.option("paper");
			var this_option_color = this.option("color");
			var this_option_active_color = this.option("active_color");
			var line_elem = this.line_path;
			var arrow = this.arrow_path;
			var len = line_elem.getTotalLength();

			this.circle.attr({
				r: this.option("radius") * 4,
				fill: this_option_active_color
			});
			this.circle.animate({
				fill: this_option_color,
				r: this.option("radius")
			}, anim_time);

			var the_flash = paper.path(line_elem.getSubpath(0, 0));
			the_flash.attr({
				stroke: this_option_active_color,
				"stroke-width": 3,
				guide: line_elem,
				along: [0, 0]
			});

			var flash_1_to_0_anim = Raphael.animation({
												path: line_elem.getSubpath(4 * len / 4.1, len)
											}, anim_time/2, "ease-out", function() {
												the_flash.remove();
											});
			var reset_arrow_color_anim = Raphael.animation({
												fill: this_option_color
											}, anim_time/2, "ease_out");

			var flash_0_to_1_anim = Raphael.animation({
												path: line_elem.getSubpath(0, len)
											}, anim_time/2, "ease-in", function() {
												if(paper.height === null) { // we were deleted
													return;
												} else if(arrow[0] === null) {
													the_flash.remove();
													return;
												}
												arrow.attr({"fill": this_option_active_color});
												the_flash.animate(flash_1_to_0_anim);
												arrow.animate(reset_arrow_color_anim);
											});
			the_flash.animate(flash_0_to_1_anim);
		};
		proto.remove = function () {
			this.circle.remove();
			this.line_path.remove();
			this.arrow_path.remove();
		};

		proto.destroy = function () {
			if(this.enabled_fn) {
				this.enabled_fn.destroy();
			}

			able.destroy_this_listenable(this);
			able.destroy_this_optionable(this);
		};
	}(ist.ArrowView));
}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,RedMap,jQuery,window,Snap */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	cjs.registerPartial("statechartView", function(options, parent_elem) {
		if(!parent_elem) {
			parent_elem = $("<div />")[0];
		}
		$(parent_elem).statechart(options);
		return parent_elem;
	});
	$.widget("interstate.statechart", {
		options: {
			transition_font_family: "Source Sans Pro",
			transition_font_size: 12,
			transition_arrow_color: "#000",
			transition_text_background_color: "#FFF",
			transition_text_color: "#000",
			active_transition_color: "#007000",

			state_font_family: "Source Sans Pro",
			state_font_size: 13,
			state_text_background_color: "#FFF",
			state_text_color: "#000",
			state_fill: "#EEE",
			state_stroke: "#999",
			active_state_fill: "#FFF",
			active_state_stroke: "#007000",
			active_state_text_color: "#007000",
			start_state_color: "#000",
			start_state_radius: 6,
			add_state_width: 50,

			statecharts: [],

			hrange_y: 5,
			hrange_height: 14,

			client: false,

			padding_top: function() {
				return this.option("hrange_y") + this.option("hrange_height");
			}
		},

		_create: function () {
			this.element.addClass("statechart");
			this.paper = new Raphael(this.element[0], 0, 0);
			var statecharts = this.option("statecharts");
			this.layout_manager = new ist.RootStatechartLayoutEngine({
				statecharts: statecharts,
				statecharts_with_add_state_button: [statecharts[0]],
				start_state_radius: this.option("start_state_radius"),
				padding_top: this.option("padding_top").call(this),
				add_state_width: this.option("add_state_width")
			});
			this.statechart_view = new ist.RootStatechartView(statecharts, this.layout_manager, this.paper, this.options);
			this.statechart_view.on("add_state", this.add_state, this);
			this.statechart_view.on("remove_state", this.remove_state, this);
			this.statechart_view.on("remove_transition", this.remove_transition, this);
			this.statechart_view.on("add_transition", this.add_transition, this);
			this.statechart_view.on("set_to", this.set_transition_to, this);
			this.statechart_view.on("set_from", this.set_transition_from, this);
			this.statechart_view.on("rename", this.rename_state, this);
			this.statechart_view.on("set_str", this.set_transition_str, this);
			this.statechart_view.on("make_concurrent", this.make_concurrent, this);
			this.statechart_view.on("reset", this.reset, this);
		},
		_destroy: function () {
			this._super();
			this.statechart_view.off("add_state", this.add_state, this);
			this.statechart_view.off("remove_state", this.remove_state, this);
			this.statechart_view.off("remove_transition", this.remove_transition, this);
			this.statechart_view.off("add_transition", this.add_transition, this);
			this.statechart_view.off("set_to", this.set_transition_to, this);
			this.statechart_view.off("set_from", this.set_transition_from, this);
			this.statechart_view.off("rename", this.rename_state, this);
			this.statechart_view.off("set_str", this.set_transition_str, this);
			this.statechart_view.off("make_concurrent", this.make_concurrent, this);
			this.statechart_view.off("reset", this.reset, this);
			this.statechart_view.destroy();

			delete this.statechart_view;

			this.paper.remove();

			this.element.removeClass("statechart");
			delete this.options.statecharts;
			delete this.options;

			this.layout_manager.destroy();
			delete this.layout_manager;
		},

		get_layout_manager: function() {
			return this.layout_manager;
		},

		_setOption: function(key, value) {
			this._super(key, value);
			if(key === "statecharts") {
				this.layout_manager.option("statecharts_with_add_state_button", [value[0]]);
				this.layout_manager.invalidate();
			}
		},
		add_state: function(e) {
			var event = new $.Event("command");
			event.command_type = "add_state";
			event.state = e.parent;

			this.element.trigger(event);
		},
		remove_state: function(e) {
			var event = new $.Event("command");
			event.command_type = "remove_state";
			event.state = e.state;

			this.element.trigger(event);
		},
		remove_transition: function(e) {
			var event = new $.Event("command");
			event.command_type = "remove_transition";
			event.transition = e.transition;

			this.element.trigger(event);
		},
		add_transition: function(e) {
			var event = new $.Event("command");
			event.command_type = "add_transition";
			event.from = e.from;
			event.to = e.to;

			this.element.trigger(event);
		},
		set_transition_to: function(e) {
			var event = new $.Event("command");
			event.command_type = "set_transition_to";
			event.transition = e.transition;
			event.to = e.to;

			this.element.trigger(event);
		},
		set_transition_from: function(e) {
			var event = new $.Event("command");
			event.command_type = "set_transition_from";
			event.transition = e.transition;
			event.from = e.from;

			this.element.trigger(event);
		},
		set_transition_event: function(e) {
			var event = new $.Event("command");
			event.command_type = "set_transition_event";
			event.transition = e.transition;
			event.from = e.from;

			this.element.trigger(event);
		},
		rename_state: function(e) {
			var event = new $.Event("command");
			event.command_type = "rename_state";
			event.state = e.state;
			event.new_name = e.name;

			this.element.trigger(event);
		},
		set_transition_str: function(e) {
			var event = new $.Event("command");
			event.command_type = "set_transition_str";
			event.transition = e.transition;
			event.str = e.str;

			this.element.trigger(event);
		},
		make_concurrent: function(e) {
			var event = new $.Event("command");
			event.command_type = "make_concurrent";
			event.state = e.state;
			event.concurrent = e.concurrent;

			this.element.trigger(event);
		},
		reset: function(e) {
			var event = new $.Event("command");
			event.command_type = "reset";
			event.client = cjs.get(this.option("client"));
			if(event.client) {
				this.element.trigger(event);
			}
		}
	});


	ist.RootStatechartView = function (statecharts, layout_engine, paper, options) {
		able.make_this_listenable(this);
		able.make_this_optionable(this, {}, options);

		this.statecharts = statecharts;
		this.layout_engine = layout_engine;
		this.object_views = new RedMap({
			hash: "hash"
		});
		this.hranges = new RedMap({
			hash: "hash"
		});
		this.paper = paper;
		this.add_state_shape = this.paper.path("M0,0").hide();
		this.add_state_button = this.paper.text(0,0,"+").hide();
		this.add_state_shape	.attr({
									fill: this.option("state_fill"),
									stroke: this.option("state_stroke"),
									opacity: 0.5,
									cursor: "pointer"
								})
								.click(_.bind(this.on_add_state_click, this));

		this.add_state_button	.attr({
									"font-size": "42px",
									fill: this.option("state_stroke"),
									opacity: 0.5,
									cursor: "pointer"
								})
								.click(_.bind(this.on_add_state_click, this));

		var curr_items = [];
		this.live_layout = cjs.liven(function () {
			var layout_info = this.layout_engine.get_layout();
			var width = layout_info.width,
				height = layout_info.height,
				layout = layout_info.locations;
			this.paper.setSize(width, height);
			var new_items = [];
			layout.each(function (layout_info, state) {
				var view;
				if (state instanceof ist.State) {
					if (_.indexOf(this.statecharts, state) >= 0) {
						if (layout_info.add_state_button_x) {
							this.add_state_button.attr({
								x: layout_info.add_state_button_x,
								y: height / 2
							}).show();
							var shorten_height = this.layout_engine.option("state_name_height");
							var dx = layout_info.right_wing_end.x - layout_info.right_wing_start.x;
							var padding_top = this.option("padding_top");
							var x = layout_info.add_state_button_x;
							var width = this.option("add_state_width");
							this.add_state_shape.attr({
								path: "M"+(x-width/2)+","+padding_top +
										"H" + (x + width/2) +
										"V" + (layout_info.right_wing_end.y-shorten_height) +
										"L" + (layout_info.right_wing_start.x) + "," + (layout_info.right_wing_start.y - shorten_height) +
										"H" + (x - width/2 + dx) + 
										"L" + (x - width/2) + "," + (layout_info.right_wing_end.y - shorten_height) +
										"Z"
							}).show();
						}
						var hrange;
						var text = "inherited";
						if(this.statecharts[0] === state) {
							text = "own";
						}

						if(this.hranges.has(state)) {
							hrange = this.hranges.get(state);
							hrange.option({
								from_x: layout_info.left_wing_start.x,
								to_x: layout_info.right_wing_end.x
							});
						} else {
							hrange = this.get_hrange(state, text, layout_info);
							hrange.on("add_state", this.forward_event, this);
							hrange.on("make_concurrent", this.forward_event, this);
							hrange.on("reset", this.forward_event, this);
						}
						return; //it's a root statechart
					}
					if (this.object_views.has(state)) {
						view = this.get_view(state, layout_info);
						if (state instanceof ist.StartState) {
							view.option({
								c: layout_info.center
							});
						} else {
							view.option({
								lws: layout_info.left_wing_start,
								lwe: layout_info.left_wing_end,
								rws: layout_info.right_wing_start,
								rwe: layout_info.right_wing_end,
								c: layout_info.center
							});
						}
						new_items.push(view);
					} else {
						view = this.get_view(state, layout_info);
						new_items.push(view);
					}
					view.toFront();
				} else if (state instanceof ist.StatechartTransition) {
					if (this.object_views.has(state)) {
						view = this.get_view(state, layout_info);
						view.option({
							from: layout_info.from,
							to: layout_info.to
						});
						new_items.push(view);
					} else {
						view = this.get_view(state, layout_info);
						new_items.push(view);
					}
				}
			}, this);

			var key;
			_.each(curr_items, function (ci) {
				if (new_items.indexOf(ci) < 0) {
					key = ci instanceof ist.TransitionView ? ci.option("transition") : ci.option("state");
					this.object_views.remove(key);
					ci.remove();
					ci.destroy();
				}
			}, this);
			_.each(new_items, function(view) {
				if(view instanceof ist.TransitionView) {
					view.toFront();
				}
			});
			curr_items = new_items;
		}, {
			context: this
		});
		this.editing = false;
	};

	(function (My) {
		var proto = My.prototype;
		able.make_proto_listenable(proto);
		able.make_proto_optionable(proto);
		proto.get_hrange = function(statechart, text, layout_info) {
			return this.hranges.get_or_put(statechart, function () {
				return new ist.HorizontalRangeDisplay({
					from_x: layout_info.left_wing_start.x,
					to_x: layout_info.right_wing_end.x,
					paper: this.paper,
					text: text,
					line_color: "#AAA",
					color: "#999",
					background: "#EEE",
					y: this.option("hrange_y"),
					height: this.option("hrange_height"),
					state: statechart
				});
			}, this);
		};
		proto.on_add_state_click = function() {
			this._emit("add_state", {
				parent: this.statecharts[0]
			});
		};
		proto.get_view = function (obj, layout_info) {
			return this.object_views.get_or_put(obj, function () {
				var rv;
				if (obj instanceof ist.StatechartTransition) {
					rv = new ist.TransitionView({
						paper: this.paper,
						transition: obj,
						from: layout_info.from,
						to: layout_info.to,
						active_color: this.option("active_transition_color"),
						color: this.option("transition_arrow_color"),
						text_background: this.option("transition_text_background_color"),
						text_foreground: this.option("transition_text_color"),
						font_family: this.option("transition_font_family"),
						font_size: this.option("transition_font_size"),
						parent: this
					});
					rv.on("change", function (event) {
						var value = event.value;
						if (value === "") {
							this._emit("remove_transition", {transition: obj});
						} else {
							this._emit("change_transition_event", {transition: obj, str: value});
						}
					}, this);
					rv.on("remove_transition", this.forward_event, this);
					rv.on("awaiting_state_selection", this.on_awaiting_state_selection, this);
					rv.on("set_to", this.forward_event, this);
					rv.on("set_from", this.forward_event, this);
					rv.on("set_str", this.forward_event, this);
				} else if (obj instanceof ist.StartState) {
					rv = new ist.StartStateView({
						state: obj,
						paper: this.paper,
						c: layout_info.center,
						fill_color: this.option("start_state_color"),
						radius: this.option("start_state_radius"),
						parent: this
					});
				} else {
					rv = new ist.StateView({
						state: obj,
						paper: this.paper,
						lws: layout_info.left_wing_start,
						lwe: layout_info.left_wing_end,
						rws: layout_info.right_wing_start,
						rwe: layout_info.right_wing_end,
						c: layout_info.center,
						font_family: this.option("state_font_family"),
						font_size: this.option("state_font_size"),
						default_stroke: this.option("state_stroke"),
						default_fill: this.option("state_fill"),
						active_stroke: this.option("active_state_stroke"),
						active_fill: this.option("active_state_fill"),
						text_foreground: this.option("state_text_color"),
						active_text_fireground: this.option("active_state_text_color"),
						text_background: this.option("state_text_background_color"),
						padding_top: this.option("padding_top"),
						parent: this
					});
					rv.on("remove_state", this.forward_event, this);
					rv.on("add_transition", this.forward_event, this);
					rv.on("add_state", this.forward_event, this);
					rv.on("make_concurrent", this.forward_event, this);
					rv.on("rename", this.forward_event, this);
					rv.on("awaiting_state_selection", this.on_awaiting_state_selection, this);
				}
				return rv;
			}, this);
		};

		proto.pause = function () {
			this.live_layout.pause();
		};
		proto.resume = function () {
			this.live_layout.resume();
			this.live_layout.run();
		};
		proto.on_awaiting_state_selection = function(event) {
			if(this._awaiting_state_selection) {
				this._awaiting_state_selection();
			}
			var states = event.states,
				on_select = event.on_select,
				on_cancel = event.on_cancel;
			var select_obj_text = this.paper.text(this.paper.width/2, 10, "(click a destination state)")
											.attr({
												"font-size": 16,
												"fill": '#777',
												"font-family": "Source Sans Pro"
											});
			var bbox = select_obj_text.getBBox();
			var select_obj_bg = this.paper	.rect(bbox.x-3, bbox.y-3, bbox.width+6, bbox.height+6)
											.attr({
												"stroke": "none",
												"fill": "white",
												"opacity": 0.7
											});
			select_obj_text.toFront();
			var on_keydown = function(e) {
				if(e.keyCode === 27) { //esc
					on_cancel();
					unmake_selectable();
				}
			};
			$(window).on("keydown.awaiting_state_selection", on_keydown);

			var state_views = _.map(states, this.get_view, this);

			var unmake_selectable = this._awaiting_state_selection = _.bind(function() {
				select_obj_text.remove();
				select_obj_bg.remove();
				$(window).off("keydown.awaiting_state_selection mousedown.cancel_state_selection");
				_.each(state_views, function(view) {
					view.unmake_selectable();
				});
				on_select = state_views = states = null;
				delete this._awaiting_state_selection;
			}, this);

			_.each(states, function(state, i) {
				state_views[i].make_selectable(function() {
					on_select(states[i]);
					unmake_selectable();
				});
			});
			var this_element = $(this.paper.canvas.parentNode);
			$(window).on("mousedown.cancel_state_selection", function(event) {
				if(this_element.has(event.target).length === 0) {
					on_cancel();
					unmake_selectable();
					event.preventDefault();
					event.stopPropagation();
					return false;
				}
			});
		};
		proto.remove = function () {
		};
		proto.destroy = function () {
			$(window).off("keydown.awaiting_state_selection");
			delete this.statecharts;

			this.live_layout.destroy();
			delete this.live_layout;
			delete this.layout_engine;
			this.object_views.each(function(object_view) {
				object_view.destroy();
			});
			this.object_views.destroy();
			delete this.object_views;
			this.hranges.each(function(hrange) {
				hrange.destroy();
			});
			this.hranges.destroy();
			delete this.hranges;

			able.destroy_this_listenable(this);
			able.destroy_this_optionable(this);

			this.add_state_shape.remove();
			delete this.add_state_shape;
			this.add_state_button.remove();
			delete this.add_state_button;
		};

	}(ist.RootStatechartView));
	
}(interstate, jQuery));

/*jslint nomen: true, vars: true */
/*global interstate,esprima,able,uid,console,jQuery,window,Raphael */

(function (ist, $) {
	"use strict";
	var cjs = ist.cjs,
		_ = ist._;

	ist.HorizontalRangeDisplay = function (options) {
		able.make_this_optionable(this, {
			font_family: "Source Sans Pro",
			font_size: "12px",
			line_color: "black",
			color: "black",
			background: "white",
			height: 10,
			y: 1,
			from_x: 0,
			to_x: 0,
			paper: false,
			text: "",
			state: null
		}, options);
		able.make_this_listenable(this);
		var paper = this.option("paper");

		this.left_vline = paper.path("M0,0");
		this.right_vline = paper.path("M0,0");
		this.hline = paper.path("M0,0");
		this.text_background = paper.rect(0,0,0,0);
		this.text_foreground = paper.text(0, 0, this.option("text"));

		this.left_vline.attr({
			stroke: this.option("line_color")
		});
		this.right_vline.attr({
			stroke: this.option("line_color")
		});
		this.hline.attr({
			stroke: this.option("line_color")
		});
		this.text_background.attr({
			stroke: "none",
			fill: this.option("background"),
			"fill-opacity": 0.5
		});
		this.text_foreground.attr({
			fill: this.option("color"),
			"font-family": this.option("font_family"),
			"font-size": this.option("font_size")
		});
		this.update();

		$(this.hline[0]).add(this.text_foreground[0]).on("contextmenu.showmenu", _.bind(function(event) {
			event.preventDefault();
			event.stopPropagation();

			this.show_menu();
		}, this));
	};

	(function (My) {
		var proto = My.prototype;
		able.make_proto_optionable(proto);
		able.make_proto_listenable(proto);

		proto.destroy = function() {
			$(this.hline[0]).add(this.text_foreground[0]).off("contextmenu.showmenu");
			this.remove_edit_dropdown();
			able.destroy_this_optionable(this);
			able.destroy_this_listenable(this);
		};

		proto.update = function() {
			var from_x = this.option("from_x"),
				to_x = this.option("to_x"),
				text = this.option("text"),
				y = this.option("y"),
				height = this.option("height");
			this.left_vline.attr({
				path: "M"+from_x+","+y+"V"+(y+height)
			});
			this.right_vline.attr({
				path: "M"+to_x+","+y+"V"+(y+height)
			});
			this.hline.attr({
				path: "M"+from_x+","+(y+height/2)+"H"+to_x
			});
			this.text_foreground.attr({
				x: (from_x + to_x)/2,
				y: y+height/2
			});
			var bbox = this.text_foreground.getBBox();
			this.text_background.attr({
				x: bbox.x,
				y: bbox.y,
				height: bbox.height,
				width: bbox.width
			});
		};

		proto._on_options_set = function () {
			this.update();
		};
		proto.show_menu = function() {
			var my_state = this.option("state");
			this.add_substate_item = $("<div />")	.addClass("menu_item")
													.text("Add substate")
													.on("click", _.bind(function() {
														this.remove_edit_dropdown();
														this._emit("add_state", {
															parent: my_state
														});
													}, this));

			var is_concurrent = this.option("state").is_concurrent();
			var checkbox_mark = is_concurrent ? "&#x2612;" : "&#x2610;";
			this.toggle_concurrency_item = $("<div />")	.addClass("menu_item")
														.html("Concurrent " + checkbox_mark)
														.on("click", _.bind(function() {
															this.remove_edit_dropdown();
															this._emit("make_concurrent", {
																state: my_state,
																concurrent: !my_state.is_concurrent()
															});
														}, this));
			this.reset_item = $("<div />")	.addClass("menu_item")
													.text("Reset")
													.on("click", _.bind(function() {
														this.remove_edit_dropdown();
														this._emit("reset", {
															parent: my_state
														});
													}, this));

			var x = this.option("from_x");
			var y = this.option("y");
			var width = this.option("to_x") - x;

			var paper = this.option("paper");
			var parentElement = paper.canvas.parentNode;

			this.edit_dropdown = $("<div />")	.append(this.add_substate_item, this.toggle_concurrency_item, this.reset_item)
												.addClass("dropdown")
												.css({
													position: "absolute",
													left: x + "px",
													top: y + "px",
													width: width + "px"
												})
												.appendTo(parentElement);
			$(window).on("mousedown.collapse", _.bind(this.on_window_click_while_expanded, this));
			$(window).on("keydown.collapse", _.bind(this.on_window_keydown_while_expanded, this));
		};
		proto.on_window_click_while_expanded = function(event) {
			if(!$(event.target).parents().is(this.edit_dropdown)) {
				this.remove_edit_dropdown();
			}
		};
		proto.on_window_keydown_while_expanded = function(event) {
			if(event.keyCode === 27) { // esc
				this.remove_edit_dropdown();
			}
		};
		proto.remove_edit_dropdown = function() {
			if(this.edit_dropdown) {
				this.edit_dropdown.remove();
				delete this.edit_dropdown;
			}
			$(window).off("mousedown.collapse");
			$(window).off("keydown.collapse");
		};
	}(ist.HorizontalRangeDisplay));
	
}(interstate, jQuery));

//# sourceMappingURL=interstate.js.map